{"meta":{"title":"Stand-Down Comedian","subtitle":"","description":"","author":"Dacle","url":"http://Giantslayer1980.github.io","root":"/"},"pages":[],"posts":[{"title":"2023-7-15","slug":"2023-7-15","date":"2023-07-14T16:00:00.000Z","updated":"2023-07-15T10:18:06.499Z","comments":true,"path":"2023-7-15/","link":"","permalink":"http://giantslayer1980.github.io/2023-7-15/","excerpt":"","text":"","categories":[{"name":"Paintings","slug":"Paintings","permalink":"http://giantslayer1980.github.io/categories/Paintings/"}],"tags":[]},{"title":"2023-6-17 -- mum and cat","slug":"2023-6-17","date":"2023-06-16T16:00:00.000Z","updated":"2023-06-17T07:22:50.180Z","comments":true,"path":"2023-6-17/","link":"","permalink":"http://giantslayer1980.github.io/2023-6-17/","excerpt":"","text":"","categories":[{"name":"Paintings","slug":"Paintings","permalink":"http://giantslayer1980.github.io/categories/Paintings/"}],"tags":[]},{"title":"定期自动将云端数据库备份至云存储中","slug":"backupFromTablesToStorageInCloud","date":"2023-06-16T16:00:00.000Z","updated":"2023-06-17T16:53:36.442Z","comments":true,"path":"backupFromTablesToStorageInCloud/","link":"","permalink":"http://giantslayer1980.github.io/backupFromTablesToStorageInCloud/","excerpt":"微信小程序使用的是云开发,之前都是通过手工保存云端数据库中多个表单的方式,以此进行数据备份。显然不够智能,也比较浪费时间。所以,此次写了个云函数,命名为autoBackupDatabase,设置好触发器后,即可自动将云数据库保存至云存储中。 从云数据库备份至云存储的主要步骤: 取得access_token; 取得数据库表单查询后的job_id; 通过取得的job_id获取到对应的数据库备份文件的url; 通过数据库备份文件的url,取得该url对应的文件内容; 将取得的文件内容上传至云存储中; 上传云函数并设置触发器。 以下为autoBackupDatabase云函数的全部代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// 云函数入口文件const cloud = require(&#x27;wx-server-sdk&#x27;);const request = require(&#x27;request&#x27;);cloud.init(&#123; env: &#x27;xxxxxx&#x27; &#125;); // 使用当前云环境// 1.// 获得access_tokenasync function getAccessToken(appid, secret) &#123; return new Promise((resolve, reject) =&gt; &#123; request.get( `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$&#123;appid&#125;&amp;secret=$&#123;secret&#125;`, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; resolve(JSON.parse(body)) &#125; ) &#125;)&#125;// 2.// 进行数据库的查询操作,并导出一个job_id以获取文件地址async function createExportJob(access_token, env, collection) &#123; const date = new Date().toISOString(); return new Promise((resolve, reject) =&gt; &#123; request.post( `https://api.weixin.qq.com/tcb/databasemigrateexport?access_token=$&#123;access_token&#125;`, &#123; body: JSON.stringify(&#123; env, // 云开发的环境ID file_path: `$&#123;date&#125;.json`, // 准备生成的文件名称 file_type: &#x27;1&#x27;, // &#x27;1&#x27; 为 JSON, &#x27;2&#x27; 为 CSV query: `db.collection(&quot;$&#123;collection&#125;&quot;).get()` // 预设的查询命令 &#125;) &#125;, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; resolve(JSON.parse(body)) &#125; ) &#125;)&#125;// 3.// 从 access_token 和 job_id 获取到 目标文件的url,// 防止无法取到值,设置了一个500ms的setInterval去不断执行。async function waitJobFinished(access_token, env, job_id) &#123; return new Promise((resolve, reject) =&gt; &#123; const timer = setInterval(() =&gt; &#123; request.post( `https://api.weixin.qq.com/tcb/databasemigratequeryinfo?access_token=$&#123;access_token&#125;`, &#123; body: JSON.stringify(&#123; env, job_id &#125;) &#125;, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; const &#123; status, file_url &#125; = JSON.parse(body) console.log(&quot;查询&quot;) if (status === &#x27;success&#x27;) &#123; clearInterval(timer) resolve(file_url) &#125; &#125; ) &#125;, 500) &#125;)&#125;// 4.// 从目标文件的url取得具体内容async function getJsonContent(file_url) &#123; return new Promise((resolve, reject) =&gt; &#123; request.get( `$&#123;file_url&#125;`, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; resolve(body) &#125; ) &#125;)&#125;// 云函数入口函数exports.main = async (event, context) =&gt; &#123; const appid = &quot;xxxxxxx&quot;; const secret = &quot;xxxxxxx&quot;; const envId = &quot;xxxxxxx&quot; // 云开发的环境ID // 需要备份的集合名称 const backupFromTables = [&quot;table1&quot;, &quot;table2&quot;, &quot;table3&quot;]; // 云端备份所存放的目录 const folderName = &quot;databaseBackup&quot; const dateString = (new Date()).toISOString() // count是为统计backupFromTables中已完成备份多少张表单的计数器 var count = 0 var access_token = &quot;&quot; // 1. try &#123; const result = await getAccessToken(appid, secret) access_token = result.access_token if (typeof access_token == null || access_token== &quot;&quot; || access_token == &quot;undefined&quot;) &#123; throw new Error(`获取 access_token 失败: $&#123;result.errmsg&#125;` || &#x27;获取 access_token 为空&#x27;) &#125; &#125; catch (e) &#123; throw new Error(`获取 access_token: $&#123;e.message&#125;`); &#125; for(index in backupFromTables) &#123; const backupFromTable = backupFromTables[index] // 2. createExportJob(access_token, envId, backupFromTable) .then(res =&gt; &#123; console.log(res) if(res.errcode !== 0) &#123; throw new Error(&quot;Can&#x27;t get job_id&quot;) &#125; console.log(res.job_id) // 3. return waitJobFinished(access_token, envId, res.job_id) &#125;) .then(file_url =&gt; &#123; // 4. return getJsonContent(file_url) &#125;) .then(fileContent =&gt; &#123; // 5. return cloud.uploadFile(&#123; cloudPath: &#x27;./&#x27; + folderName + &#x27;/&#x27; + dateString.slice(0,10) + &#x27;/&#x27; + dateString + &#x27;_&#x27; + backupFromTable + &#x27;.json&#x27;, fileContent: fileContent &#125;) &#125;) .then(res =&gt; &#123; count++ console.log(&quot;---&gt;---- &quot; + count + &quot;/&quot; + backupFromTables.length+ &quot;:&quot; + backupFromTable + &quot;已完成备份 ---&lt;----&quot;) &#125;) .catch( error =&gt; &#123; throw new Error(`导出数据库异常: $&#123;error.message&#125;`); &#125;) &#125;&#125;","text":"微信小程序使用的是云开发,之前都是通过手工保存云端数据库中多个表单的方式,以此进行数据备份。显然不够智能,也比较浪费时间。所以,此次写了个云函数,命名为autoBackupDatabase,设置好触发器后,即可自动将云数据库保存至云存储中。 从云数据库备份至云存储的主要步骤: 取得access_token; 取得数据库表单查询后的job_id; 通过取得的job_id获取到对应的数据库备份文件的url; 通过数据库备份文件的url,取得该url对应的文件内容; 将取得的文件内容上传至云存储中; 上传云函数并设置触发器。 以下为autoBackupDatabase云函数的全部代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// 云函数入口文件const cloud = require(&#x27;wx-server-sdk&#x27;);const request = require(&#x27;request&#x27;);cloud.init(&#123; env: &#x27;xxxxxx&#x27; &#125;); // 使用当前云环境// 1.// 获得access_tokenasync function getAccessToken(appid, secret) &#123; return new Promise((resolve, reject) =&gt; &#123; request.get( `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$&#123;appid&#125;&amp;secret=$&#123;secret&#125;`, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; resolve(JSON.parse(body)) &#125; ) &#125;)&#125;// 2.// 进行数据库的查询操作,并导出一个job_id以获取文件地址async function createExportJob(access_token, env, collection) &#123; const date = new Date().toISOString(); return new Promise((resolve, reject) =&gt; &#123; request.post( `https://api.weixin.qq.com/tcb/databasemigrateexport?access_token=$&#123;access_token&#125;`, &#123; body: JSON.stringify(&#123; env, // 云开发的环境ID file_path: `$&#123;date&#125;.json`, // 准备生成的文件名称 file_type: &#x27;1&#x27;, // &#x27;1&#x27; 为 JSON, &#x27;2&#x27; 为 CSV query: `db.collection(&quot;$&#123;collection&#125;&quot;).get()` // 预设的查询命令 &#125;) &#125;, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; resolve(JSON.parse(body)) &#125; ) &#125;)&#125;// 3.// 从 access_token 和 job_id 获取到 目标文件的url,// 防止无法取到值,设置了一个500ms的setInterval去不断执行。async function waitJobFinished(access_token, env, job_id) &#123; return new Promise((resolve, reject) =&gt; &#123; const timer = setInterval(() =&gt; &#123; request.post( `https://api.weixin.qq.com/tcb/databasemigratequeryinfo?access_token=$&#123;access_token&#125;`, &#123; body: JSON.stringify(&#123; env, job_id &#125;) &#125;, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; const &#123; status, file_url &#125; = JSON.parse(body) console.log(&quot;查询&quot;) if (status === &#x27;success&#x27;) &#123; clearInterval(timer) resolve(file_url) &#125; &#125; ) &#125;, 500) &#125;)&#125;// 4.// 从目标文件的url取得具体内容async function getJsonContent(file_url) &#123; return new Promise((resolve, reject) =&gt; &#123; request.get( `$&#123;file_url&#125;`, (err, res, body) =&gt; &#123; if (err) &#123; reject(err) &#125; resolve(body) &#125; ) &#125;)&#125;// 云函数入口函数exports.main = async (event, context) =&gt; &#123; const appid = &quot;xxxxxxx&quot;; const secret = &quot;xxxxxxx&quot;; const envId = &quot;xxxxxxx&quot; // 云开发的环境ID // 需要备份的集合名称 const backupFromTables = [&quot;table1&quot;, &quot;table2&quot;, &quot;table3&quot;]; // 云端备份所存放的目录 const folderName = &quot;databaseBackup&quot; const dateString = (new Date()).toISOString() // count是为统计backupFromTables中已完成备份多少张表单的计数器 var count = 0 var access_token = &quot;&quot; // 1. try &#123; const result = await getAccessToken(appid, secret) access_token = result.access_token if (typeof access_token == null || access_token== &quot;&quot; || access_token == &quot;undefined&quot;) &#123; throw new Error(`获取 access_token 失败: $&#123;result.errmsg&#125;` || &#x27;获取 access_token 为空&#x27;) &#125; &#125; catch (e) &#123; throw new Error(`获取 access_token: $&#123;e.message&#125;`); &#125; for(index in backupFromTables) &#123; const backupFromTable = backupFromTables[index] // 2. createExportJob(access_token, envId, backupFromTable) .then(res =&gt; &#123; console.log(res) if(res.errcode !== 0) &#123; throw new Error(&quot;Can&#x27;t get job_id&quot;) &#125; console.log(res.job_id) // 3. return waitJobFinished(access_token, envId, res.job_id) &#125;) .then(file_url =&gt; &#123; // 4. return getJsonContent(file_url) &#125;) .then(fileContent =&gt; &#123; // 5. return cloud.uploadFile(&#123; cloudPath: &#x27;./&#x27; + folderName + &#x27;/&#x27; + dateString.slice(0,10) + &#x27;/&#x27; + dateString + &#x27;_&#x27; + backupFromTable + &#x27;.json&#x27;, fileContent: fileContent &#125;) &#125;) .then(res =&gt; &#123; count++ console.log(&quot;---&gt;---- &quot; + count + &quot;/&quot; + backupFromTables.length+ &quot;:&quot; + backupFromTable + &quot;已完成备份 ---&lt;----&quot;) &#125;) .catch( error =&gt; &#123; throw new Error(`导出数据库异常: $&#123;error.message&#125;`); &#125;) &#125;&#125;","categories":[{"name":"WeChat Mini Program","slug":"WeChat-Mini-Program","permalink":"http://giantslayer1980.github.io/categories/WeChat-Mini-Program/"}],"tags":[]},{"title":"2023-6-3","slug":"2023-6-3","date":"2023-06-02T16:00:00.000Z","updated":"2023-06-03T08:11:29.284Z","comments":true,"path":"2023-6-3/","link":"","permalink":"http://giantslayer1980.github.io/2023-6-3/","excerpt":"","text":"","categories":[{"name":"Paintings","slug":"Paintings","permalink":"http://giantslayer1980.github.io/categories/Paintings/"}],"tags":[]},{"title":"Tennis Singles","slug":"Tennis-Singles","date":"2023-05-22T16:00:00.000Z","updated":"2023-05-23T12:28:53.838Z","comments":true,"path":"Tennis-Singles/","link":"","permalink":"http://giantslayer1980.github.io/Tennis-Singles/","excerpt":"“Tennis Singles” 是一款用于发布、记录、查询和统计网球单打比赛的小程序。","text":"“Tennis Singles” 是一款用于发布、记录、查询和统计网球单打比赛的小程序。","categories":[{"name":"WeChat Mini Program","slug":"WeChat-Mini-Program","permalink":"http://giantslayer1980.github.io/categories/WeChat-Mini-Program/"}],"tags":[]},{"title":"2023-5-21","slug":"2023-5-21","date":"2023-05-20T16:00:00.000Z","updated":"2023-05-23T13:19:13.777Z","comments":true,"path":"2023-5-21/","link":"","permalink":"http://giantslayer1980.github.io/2023-5-21/","excerpt":"","text":"","categories":[{"name":"Paintings","slug":"Paintings","permalink":"http://giantslayer1980.github.io/categories/Paintings/"}],"tags":[]},{"title":"Tennis Booking","slug":"Tennis-Booking","date":"2023-05-19T16:00:00.000Z","updated":"2023-05-23T12:54:50.033Z","comments":true,"path":"Tennis-Booking/","link":"","permalink":"http://giantslayer1980.github.io/Tennis-Booking/","excerpt":"“Tennis Booking” 是一款基于云开发的网球场管理工具。它具有网球场地发布、会员管理、场地预订等基本模块。","text":"“Tennis Booking” 是一款基于云开发的网球场管理工具。它具有网球场地发布、会员管理、场地预订等基本模块。","categories":[{"name":"WeChat Mini Program","slug":"WeChat-Mini-Program","permalink":"http://giantslayer1980.github.io/categories/WeChat-Mini-Program/"}],"tags":[]},{"title":"3PTS","slug":"3PTS","date":"2023-05-19T16:00:00.000Z","updated":"2023-05-23T12:55:13.791Z","comments":true,"path":"3PTS/","link":"","permalink":"http://giantslayer1980.github.io/3PTS/","excerpt":"“3PTS” 是一款用于记录篮球三分球练习成绩的小程序。","text":"“3PTS” 是一款用于记录篮球三分球练习成绩的小程序。","categories":[{"name":"WeChat Mini Program","slug":"WeChat-Mini-Program","permalink":"http://giantslayer1980.github.io/categories/WeChat-Mini-Program/"}],"tags":[]},{"title":"Swift","slug":"Swift","date":"2023-01-02T16:00:00.000Z","updated":"2023-05-20T12:49:42.446Z","comments":true,"path":"Swift/","link":"","permalink":"http://giantslayer1980.github.io/Swift/","excerpt":"相关术语: UIKit is the iOS user interface toolkit. IB is Interface Builder. CA is Core Animation. Like CALayer is a Core Animation data type responsible for managing the way your view looks. Core Animation handles animation. CG is Apple’s Core Graphics framework. Like CGColor. Core Graphics handles drawing. KVO is key-value observing. NS is Next Step. Steve Jobs did lots. VFL is a technique called Auto Layout Visual Format Language. GCD is Grand Central Dispatch. FIFO is First In, First Out. MK is Mapkit. NS came from the NeXTSTEP libraries Foundation and AppKit(those names are still used by Apple’s Cocoa frameworks). UN is UserNotification. CL is CoreLocation. MC is Multipeer Connectivity. CM is Core Motion. LA is the Local Authentication framework. HSB is Hue, Saturation and Brightness. Using this method of creating colors you specify values between 0 and 1 to control how saturated a color is (from 0 &#x3D; gray to 1 &#x3D; pure color) and brightness (from 0 &#x3D; black to 1 &#x3D; maximum brightness), and 0 to 1 for hue. “Hue” is a value from 0 to 1 also, but it represents a position on a color wheel, like using a color picker on your Mac. Hues 0 and 1 both represent red, with all other colors lying in between. FileManager枚举程序设备目录内的所有文件1234567let fm = FileManager.defaultlet path = Bundle.main.resourcePath!let items = try! fm.contentsOfDirectory(atPath: path)for item in items &#123;&#125; BundleBundle.main.url(forResource:) – 仅通过文件名而返回该文件的urlFinding a path to a file is something you’ll do a lot, because even though you know the file is called “start.txt” you don’t know where it might be on the filesystem. So, we use a built-in method of Bundle to find it: path(forResource:). This takes as its parameters the name of the file and its path extension, and returns a String? – i.e., you either get the path back or you get nil if it didn’t exist. 1234567// 假设要找寻到start.txt这个文件if let startWordsURL = Bundle.main.url(forResource: &quot;start&quot;, withExtension: &quot;txt&quot;) &#123; // 若找到该start.txt的url后读取里面的文本内容 if let startWords = try? String(contentsOf: startWordsURL) &#123; // 省略后续代码 &#125;&#125; Bundle.main.urls(forResourcesWithExtension: String?, subdirectory: String?) – 从直接指定文件名及具体目录名称来找所有文件","text":"相关术语: UIKit is the iOS user interface toolkit. IB is Interface Builder. CA is Core Animation. Like CALayer is a Core Animation data type responsible for managing the way your view looks. Core Animation handles animation. CG is Apple’s Core Graphics framework. Like CGColor. Core Graphics handles drawing. KVO is key-value observing. NS is Next Step. Steve Jobs did lots. VFL is a technique called Auto Layout Visual Format Language. GCD is Grand Central Dispatch. FIFO is First In, First Out. MK is Mapkit. NS came from the NeXTSTEP libraries Foundation and AppKit(those names are still used by Apple’s Cocoa frameworks). UN is UserNotification. CL is CoreLocation. MC is Multipeer Connectivity. CM is Core Motion. LA is the Local Authentication framework. HSB is Hue, Saturation and Brightness. Using this method of creating colors you specify values between 0 and 1 to control how saturated a color is (from 0 &#x3D; gray to 1 &#x3D; pure color) and brightness (from 0 &#x3D; black to 1 &#x3D; maximum brightness), and 0 to 1 for hue. “Hue” is a value from 0 to 1 also, but it represents a position on a color wheel, like using a color picker on your Mac. Hues 0 and 1 both represent red, with all other colors lying in between. FileManager枚举程序设备目录内的所有文件1234567let fm = FileManager.defaultlet path = Bundle.main.resourcePath!let items = try! fm.contentsOfDirectory(atPath: path)for item in items &#123;&#125; BundleBundle.main.url(forResource:) – 仅通过文件名而返回该文件的urlFinding a path to a file is something you’ll do a lot, because even though you know the file is called “start.txt” you don’t know where it might be on the filesystem. So, we use a built-in method of Bundle to find it: path(forResource:). This takes as its parameters the name of the file and its path extension, and returns a String? – i.e., you either get the path back or you get nil if it didn’t exist. 1234567// 假设要找寻到start.txt这个文件if let startWordsURL = Bundle.main.url(forResource: &quot;start&quot;, withExtension: &quot;txt&quot;) &#123; // 若找到该start.txt的url后读取里面的文本内容 if let startWords = try? String(contentsOf: startWordsURL) &#123; // 省略后续代码 &#125;&#125; Bundle.main.urls(forResourcesWithExtension: String?, subdirectory: String?) – 从直接指定文件名及具体目录名称来找所有文件如果我在某个项目目录中放了一些文件,这些文件都放在Cards.bundle目录的子目录Characters中,且不指定文件的名称和后缀: 123456789let urls = Bundle.main.urls(forResourcesWithExtension: nil, subdirectory: &quot;Cards.bundle/Characters&quot;)/*Optional([Dog.png -- file:///Users/vito/Library/Developer/CoreSimulator/Devices/428C06DC-515B-4870-BFC9-F8650821F110/data/Containers/Bundle/Application/D3A66460-669B-4539-BA09-DF69E0B9BE5D/Milestone-Project28-30-V3.app/Cards.bundle/Characters/, AdventurerGirl.png -- file:///Users/vito/Library/Developer/CoreSimulator/Devices/428C06DC-515B-4870-BFC9-F8650821F110/data/Containers/Bundle/Application/D3A66460-669B-4539-BA09-DF69E0B9BE5D/Milestone-Project28-30-V3.app/Cards.bundle/Characters/, TheBoy.png --............................file:///Users/vito/Library/Developer/CoreSimulator/Devices/428C06DC-515B-4870-BFC9-F8650821F110/data/Containers/Bundle/Application/D3A66460-669B-4539-BA09-DF69E0B9BE5D/Milestone-Project28-30-V3.app/Cards.bundle/Characters/])*/ subdirectory目录必须是详细具体的。 URL的lastPathComponent返回文件名上例来说: 12print(urls?[0].lastPathComponent)// Dog.png NSObjectNSObject is what’s called a universal base class for all Cocoa Touch classes. That means all UIKit classes ultimately come from NSObject, including all of UIKit. DataData(contentsOf: URL)从特定url取得数据 123456789101112override func viewDidLoad() &#123; super.viewDidLoad() // let urlString = &quot;https://api.whitehouse.gov/v1/petitions.json?limit=100&quot; let urlString = &quot;https://www.hackingwithswift.com/samples/petitions-1.json&quot; if let url = URL(string: urlString) &#123; if let data = try? Data(contentsOf: url) &#123; // we&#x27;re OK to parse! &#125; &#125;&#125; Data.write(to:)下面是通过UIImagePickerController取得照片后写入本地的一个例子：见 UIImagePickerController –&gt; 一般示例代码 跳转到 Data 与 String 的转换123456// 初始的字符串let str = &quot;This is a demo string.&quot;// 转换成Data数据let data = Data(str.utf8)// Data数据再转换成字符串let strFromData = String(decoding: data, as: UTF8.self) UIViewUIView是UIKit框架里面最基础的视图类，UIView类定义了一个矩形的区域，并管理该区域内的所有屏幕显示。UIView is the parent class of all of UIKit’s view types: labels, buttons, progress views, and more.程序启动后，创建的第一个视图就是UIWindow，接着创建视图控制器的view，并把view放到UIWindow上，于是控制器的view就显示在屏幕上了。 所以我们可以这样使用UIView(): 123456override func loadView() &#123; view = UIView() view.backgroundColor = .white // more code to come!&#125; Previously we assigned a WKWebView instance directly as our view, meaning that it automatically took up all the space. Here, though, we’re going to be adding lots of child views and positioning them by hand, so we need a big, empty canvas to work with. 下面是在一个UIView()的基础上再添加一个UIView() 1234// buttonsView是为了后续添加大量UIButton进行显示的一个容器viewlet buttonsView = UIView()buttonsView.translatesAutoresizingMaskIntoConstraints = falseview.addSubview(buttonsView) tintColor任何UIView子类的tintColor属性,可以改变应用在其上的颜色效果,但具体什么效果,取决于你应用在什么上面。在navigationBar和tab bars上面,意味着改变button上的text和icons的颜色;在text views上面,意味着改变被选择和高亮的text部分的颜色;在progress bars上面,意味着改变它的track color(这是不是progress前半进程的颜色？)的颜色。在tableView的cell上面,改变的就是在editing模式下,选择区域的颜色,具体见tableView的tintColor一块的笔记。 设置单个页面的tintColor123override func viewDidLoad() &#123; view.tintColor = UIColor.red&#125; frame.size – 查看UIView的框架大小 view.frame.size.width view.frame.size.height layoutMargins属性 – 查看Margins的大小通过查看一个view的layoutMargins属性,返回的结果是:UIEdgeInsets(top: 8.0, left: 8.0, bottom: 8.0, right: 8.0)这时候就可以查看或者修改 top&#x2F;left&#x2F;bottom&#x2F;right 等的值了。 设置项目中所有views的tint – 需要在AppDelegate.swift中设置AppDelegate.swift: 123456func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. window?.tintColor = UIColor.red return true&#125; UITapGestureRecognizer – 点击响应事件实例1:(拿UIImageView示例) 1234// 创建一个UITapGestureRecognizer的事件响应函数@objc func imageViewTap(_ sender: UITapGestureRecognizer) &#123; print(&quot;This view is tapped&quot;)&#125; 12// 创建UITapGestureRecognizer实例let tapGesture = UITapGestureRecognizer(target: self, action: #selector(imageViewTap)) 1234// @IBOutlet var imageView: UIImageView!// imageView已设置imageimageView.isUserInteractionEnabled = true // 允许用户交互imageView.addGestureRecognizer(tapGesture) 实例2:(拿UILabel示例) 12// 创建UITapGestureRecognizer实例let tapGesture2 = UITapGestureRecognizer(target: self, action: #selector(imageViewTap)) 1234// @IBOutlet var label: UILabel!// label已设置textlabel.isUserInteractionEnabled = true // 允许用户交互label.addGestureRecognizer(tapGesture) UITableViewControllerIndexPath(row: Int, section: Int) let indexPath = IndexPath(row: 1, section: 0) 需要实现的方法override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { }override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { }123456override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 在IB中的cell设置中必须注明Identifier是&quot;Picture&quot; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Picture&quot;, for: indexPath) cell.textLabel?.text = pictures[indexPath.row] return cell&#125; 如果tableView没有在storyBoard中设置过cell可复用的情况12345var cell: UITableViewCell! = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)if cell == nil &#123; cell = UITableViewCell(style: .default, reuseIdentifier: &quot;Cell&quot;)&#125; 一般我们使用上面的代码,先查看storyBoard中是否设置过cell可复用的情况,则会使用cell = UITableViewCell(style: .default, reuseIdentifier: &quot;Cell&quot;),但会带来一个问题,每次tableView都会新建一个cell,而不是复用,这对于资源的消耗是很大的。解决办法: 12345// 在ViewDidLoad()中注册可复用的celltableView.register(UITableViewCell.self, forCellReuseIdentifier: &quot;Cell&quot;)// 在cellForRowAt中使用该可复用的celllet cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) 这样即使你在storyBoard中没有设置过,也可以高效率的使用了。 可以实现的方法override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { }12345678910override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; // 1: try loading the &quot;Detail&quot; view controller and typecasting it to be DetailViewController if let vc = storyboard?.instantiateViewController(withIdentifier: &quot;Detail&quot;) as? DetailViewController &#123; // 2: success! Set its selectedImage property vc.selectedImage = pictures[indexPath.row] // 3: now push it onto the navigation controller navigationController?.pushViewController(vc, animated: true) &#125;&#125; override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) { }可以划动删除&#x2F;添加的操作。（在模拟器上没有成功,但在真机上向左划动会出现”删除”字样。） 12345678override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; objects.remove(at: indexPath.row) tableView.deleteRows(at: [indexPath], with: .fade) &#125; else if editingStyle == .insert &#123; // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view. &#125;&#125; tableView.layoutMargins &#x2F; tableView.separatorInset &#x2F; UIEdgeInsets – 修改边缘的空白空间的大小未设置前: 在viewDidLoad()中加入代码: 1234// tableView.layoutMargins -- the default spacing to use when laying out content in the view.tableView.layoutMargins = UIEdgeInsets.zero// tableView.separatorInset -- the default inset of cell separators.tableView.separatorInset = UIEdgeInsets.zero 在tableView的cellForRowAt方法中加入代码: 12// 这里是给每个cell设置layoutMarginscell.layoutMargins = UIEdgeInsets.zero 设置后的效果: tableView.backgroundColor – 设置tableView的底色将某张图片设置tableView的底色,并编排该底色 123if let backgroundImage = UIImage(named: &quot;white_wall&quot;) &#123; tableView.backgroundColor = UIColor(patternImage: backgroundImage)&#125; tableView.allowsMultipleSelection – 除了编辑状态下,允许多行选定1tableView.allowsMultipleSelection = true tableView.allowsMultipleSelectionDuringEditing – 编辑状态下允许多行选定1tableView.allowsMultipleSelectionDuringEditing = true tableView.reloadData()Reloads the rows and sections of the table view: 1tableView.reloadData() override func setEditing(_ editing: Bool, animated: Bool) {} – 默认这是个默认在tableView中会实现的方法,一般不需要去修改它。比如你定义了一个UIBarButtonItem: 1editButton = UIBarButtonItem(barButtonSystemItem: .edit, target: self, action: #selector(enterEditingMode)) 若点击该edit的button,就会自动调用到setEditing方法。setEditing(true, animated: true) – 就是出现editing模式;setEditing(false, animated: true) – 就是取消editing模式。 那么,什么时候需要覆写该setEditing方法呢?比如当你想点击该edit按钮后,你想让toolbarItems出现你自定义的按钮,包括你想取消editing模式时,又出现toolbarItems自定义的其他按钮,那你就可以去使用它,但每次覆写都必须实现super.setEditing(editing, animated: animated): 1234567891011121314151617181920212223// 点击edit按钮调用的方法:@objc func enterEditingMode() &#123; navigationItem.rightBarButtonItems = [cancelButton]// toolbarItems = [spacerButton, deleteAllButton] setEditing(true, animated: true)&#125;// 取消edit模式调用的方法:@objc func cancelEditingMode() &#123; navigationItem.rightBarButtonItems = [editButtonItem]// toolbarItems = [spacerButton, notesCountButton, spacerButton, newNoteButton] setEditing(false, animated: true)&#125;override func setEditing(_ editing: Bool, animated: Bool) &#123; // ?? super.setEditing(editing, animated: animated) if editing &#123; toolbarItems = [spacerButton] &#125; else &#123; toolbarItems = [spacerButton, notesCountButton, spacerButton, newNoteButton] &#125;&#125; tableView.isEditing – 反映tableView是否在editing模式tableView.isEditing is a boolean value that determines whether the table view is in editing mode.例子请结合 tableView.indexPathsForSelectedRows 一起看。 tableView.indexPathsForSelectedRowsThe index paths that represent the selected rows. 就是一个所有被选中cell的index列表。 12345678override func tableView(_ tableView: UITableView, didDeselectRowAt indexPath: IndexPath) &#123; if tableView.isEditing &#123; if tableView.indexPathsForSelectedRows == nil || tableView.indexPathsForSelectedRows!.isEmpty &#123; toolbarItems = [spacerButton, deleteAllButton] &#125; // 其他代码省略 &#125;&#125; tableView.indexPathForSelectedRow – 返回被选中列的IndexPathcell.selectedBackgroundView – 设置cell在选中状态下的背景view123// cell: UITableViewCell// selectedCellView: UIView?cell.selectedBackgroundView = selectedCellView cell.multipleSelectionBackgroundView – 设置cell在被多选状态下的背景view1234// cell: UITableViewCelllet multipleSelectedCellView = UIView()multipleSelectedCellView.backgroundColor = UIColor.orange.withAlphaComponent(0.2)cell.multipleSelectionBackgroundView = multipleSelectedCellView UITableViewCell.tintColor – cell在editing模式下选择区域的背景颜色12// cell: UITableViewCellcell.tintColor = .orange tableView.rowHeight – 设置tableView的每个cell的高度tableView.rowHeight = 90 tableView.separatorStyle – 设置每个cell的分隔类型tableView.separatorStyle = .singleLinetableView.separatorStyle = .none UITableViewDataSource – protocol具体实例参考:github上clarknt写的关于100daysOfswift的Milestone-Project28-30的实例代码。从代码实例中的一些思考:主页面push出一个setting页面,setting页面内有两个tableView,所以在setting页面需要识别tableView是哪一个,而两个tableView分别有1个section和26个section,所以在UITableViewDataSource协议的实现方法中要手动去识别区分是哪个table。学习到的是,以前写UITableView的时候,从来没有去实现过UITableViewDataSource协议。 必须要实现的方法: numberOfRowsInSection cellForRowAt 可选择实现的方法1:numberOfSections – 确定有多少个分区(section)例如: 1234567func numberOfSections(in tableView: UITableView) -&gt; Int &#123; if tableView == cardsTable &#123; return 1 &#125; return grids.count&#125; 可选择实现的方法2:titleForHeaderInSection – 每个section的标题例如: 1234567func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123; if tableView == cardsTable &#123; return &quot;&quot; &#125; return &quot;Cards: \\(grids[section].numberOfElements)&quot;&#125; 可选择实现的方法3:titleForFooterInSection – 每个section的脚标 可选择实现的方法4:canMoveRowAtIndexPath – 用来控制cell是否可以移动,只有实现了才行移动。 UIImage生成UIImage的方法UIImage(named:)12let imageName = &quot;nssl0042.jpg&quot;let image = UIImage(named: imageName) UIImage(named:)和UIImage(contentsOfFile:)的区别UIImage(named:)可以不写明图片文件的具体路径,UIImage(contentsOfFile:)必须要写明图片文件的具体路径,这个比较麻烦,但我们可以这样: 12let path = Bundle.main.path(forResource: imageName, ofType: nil)!let original = UIImage(contentsOfFile: path)! 此外,最重要的一个区别,也是会影响到app性能的一个区别就是:UIImage(named:)加载完图片后会加入缓存,而UIImage(contentsOfFile:)并不会加入缓存。那么前者加载图片会比较快,而后者会比较慢,但前者会占据大量缓存,加载大量图片后,可能会让缓存吃紧,而后者就不会出现这种情况。 UINavigationControllerDeclaration: 1@MainActor class UINavigationController : UIViewController title - 标题直接在页面使用 title &#x3D; “ I’m the title, etc. “ 即可。 largeTitle在UINavigationController中,title的default style都是small text,那么如何设置成largeTitle呢? 1navigationController?.navigationBar.prefersLargeTitles = true 以上。 那么,一些类似detail的页面不需要largeTitle而主页面需要的情况下,该怎么设置呢？只要在detail页面加入代码: 1navigationItem.largeTitleDisplayMode = .never 以上。 UINavigationBarBy default, a UINavigationController has a bar across the top, called a UINavigationBar, and as developers we can add buttons to this navigation bar that call our methods. 1navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .action, target: self, action: #selector(shareTapped)) 这里选择的是barButtonSystemItem: .action, 可以选择其他的,比如 .cancel &#x2F; .done &#x2F; .add &#x2F; .camera &#x2F;.bookmarks &#x2F;.edit 等等很多其他的。 还可以让图标自定义显示: 1navigationItem.leftBarButtonItem = UIBarButtonItem(title: &quot;Score&quot;, style: .plain, target: self, action: #selector(showScore)) 该自定义的图标可设置样式: 1navigationItem.leftBarButtonItem.setTitleTextAttributes([NSAttributedString.Key.font: UIFont.systemFont(ofSize: 11), NSAttributedString.Key.foregroundColor : UIColor.darkText], for: .normal) 点击页面即隐藏或显示navigationBar123456789override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) navigationController?.hidesBarsOnTap = true&#125;override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) navigationController?.hidesBarsOnTap = false&#125; 在显示该页面时,即开启点击页面任何处可隐藏navigationBar,再点击可显示navigationBar的功能。但为何在viewWillDisappear中还要取消该功能?想想这样的场景,在detail页面可观看一张图片,点击可显示&#x2F;隐藏navigationBar,但如果你点击返回退回到前一页(可能是主页面),该页面并不需要隐藏navigationBar,但却在navigationController中开启了该功能,会非常的不好,所以需要取消。 Disclosure IndicatorDisclosure Indicator 即如下图每个cell右边的箭头(&gt;)符号:如何设置显示或不显示:在storyBoard中选中cell,在其的属性中的Accessory中去设置:可以看到我们选择的是DisclosureIndicator,还有DetailDisclosure&#x2F;Checkmark&#x2F;Detail都是很好的选择,主要看所使用的场景。 UINavigationController? 的 popViewController &#x2F; pushViewControllerUINavigationController是IOS编程中的一个view controller的容器，通过栈管理viewControllers，每一次pushViewController操作都将在栈顶添加一个view controller，然后通过popViewController将该栈最顶端的controller移除。上面说的栈最顶端是这样的,navigationController?.viewControllers中保存着所有的view controller,你push进去一个view controller,就放在这个列表的最后面,你pop的话,也是将列表的最后面那个view controller删除。这就是栈的后进先出的概念。 这里自己写了个例子: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ViewController.swiftclass ViewController: UIViewController &#123; @IBOutlet var textView: UITextView! override func viewDidLoad() &#123; super.viewDidLoad() navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .action, target: self, action: #selector(toDetailView)) print(navigationController?.viewControllers) // Optional([&lt;SwiftTest001.ViewController: 0x117e07490&gt;]) // 一个ViewController navigationController?.popViewController(animated: true) // 这里pop了,为什么下面显示的栈里面还是有一个ViewController? // 感觉是因为栈里总得有一个ViewController吧, // 所以这行代码是没有意义的。 print(navigationController?.viewControllers) // Optional([&lt;SwiftTest001.ViewController: 0x117e07490&gt;]) // 还是原来那个ViewController &#125; @objc func toDetailView() &#123; if let vc = storyboard?.instantiateViewController(withIdentifier: &quot;Detail&quot;) as? DetailViewController &#123; navigationController?.pushViewController(vc, animated: true) &#125; &#125;&#125;// DetailViewController.swiftclass DetailViewController: UIViewController &#123; override func viewDidLoad() &#123; navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .cancel, target: self, action: #selector(deleteTopView)) print(navigationController?.viewControllers) // Optional([&lt;SwiftTest001.ViewController: 0x117e07490&gt;, &lt;SwiftTest001.DetailViewController: 0x117e22d20&gt;]) // 有二个ViewController了,栈顶就是这个DetailViewController &#125; @objc func deleteTopView() &#123; navigationController?.popViewController(animated: true) print(navigationController?.viewControllers) // Optional([&lt;SwiftTest001.ViewController: 0x117e07490&gt;]) // 又回到原来的那个ViewController了,pop出的就是后进来的DetailViewController了。 &#125;&#125; UIButton设置UIButton上的文字 – .setTitle()12345let submit = UIButton(type: .system)submit.translatesAutoresizingMaskIntoConstraints = false// 设置显示的文字submit.setTitle(&quot;SUBMIT&quot;, for: .normal)view.addSubview(submit) 在UIButton上设置UIImage12// 前提是,button1是UIButton类型的按钮button1.setImage(UIImage(named: countries[0]), for: .normal) 设置UIButton的边框粗细1button1.layer.borderWidth = 1 our border will be 1 pixel on non-retina devices, 2 pixels on retina devices, and 3 on retina HD devices. 设置UIButton的边框颜色1button1.layer.borderColor = UIColor.lightGray.cgColor By default, the border of CALayer is black, but you can change that if you want by using the UIColor data type. I said that CALayer brings with it a little more complexity, and here’s where it starts to be visible: CALayer sits at a lower technical level than UIButton, which means it doesn’t understand what a UIColor is. UIButton knows what a UIColor is because they are both at the same technical level, but CALayer is below UIButton, so UIColor is a mystery. Don’t despair, though: CALayer has its own way of setting colors called CGColor, which comes from Apple’s Core Graphics framework. This, like CALayer, is at a lower level than UIButton, so the two can talk happily – again, as long as you’re happy with the extra complexity. Even better, UIColor (which sits above CGColor) is able to convert to and from CGColor easily, which means you don’t need to worry about the complexity. 以上的颜色也可以写成这种表现形式: 1UIColor(red: 1.0, green: 0.6, blue: 0.2, alpha: 1.0).cgColor 设置UIButton的大小1234let letterButton = UIButton(type: .system)letterButton.setTitle(&quot;WWW&quot;, for: .normal)let frame = CGRect(x: col * width, y: row * height, width: width, height: height)letterButton.frame = frame 通过IB来创建UIButton的Action方法 https://www.hackingwithswift.com/read/2/5/from-outlets-to-actions-creating-an-ibaction 在IB中通过ctrl拉动UIButton按钮至assistant页面中,跳出页面选项选择Connection:Action而非Connection:Outlet。 会生成按钮点击的@IBAction方法: 12@IBAction func buttonTapped(_ sender: UIButton) &#123;&#125; 通过此方法,可以使多个按钮使用同一方法的情况。注意:有可能上面的sender的属性是Any,这时候最好把Any改成UIButton。 如何在多个按钮使用同一方法的情况下,识别是哪个按钮被点击?在IB界面的这个UIButton属性中设置其的tag为一个唯一的数字: 随后在这个UIButton按钮的action中可查看其的tag: 123@IBAction func buttonTapped(_ sender: UIButton) &#123; print(sender.tag)&#125; sender.isHidden 的Bool值 让UIButton隐身在 @IBAction func buttonTapped(_ sender: UIButton) { 中设置sender.isHidden &#x3D; true 或者 false 可让该UIButton隐藏或显示。 通过代码来给UIButton()添加action12345678910let submit = UIButton(type: .system)submit.translatesAutoresizingMaskIntoConstraints = falsesubmit.setTitle(&quot;SUBMIT&quot;, for: .normal)view.addSubview(submit)// 为submit按钮添加一个objc类型的submitTapped方法,而且激活按钮要求是.touchUpInside,即按钮按下并松开时,松开手势得在按钮正上方submit.addTarget(self, action: #selector(submitTapped), for: .touchUpInside)@objc func submitTapped(_ sender: UIButton) &#123; &#125; 让UIButton()隐藏但仍占据位置1234567let submit = UIButton(type: .system)submit.translatesAutoresizingMaskIntoConstraints = falsesubmit.setTitle(&quot;SUBMIT&quot;, for: .normal)view.addSubview(submit)// 隐藏该submit按钮但仍旧占位submit.isHidden = true UIAlertController一般使用12345678let ac = UIAlertController(title: title, message: &quot;Your score is \\(score).&quot;, preferredStyle: .alert)ac.addAction(UIAlertAction(title: &quot;Continue&quot;, style: .default, handler: askQuestion))present(ac, animated: true)// 对应的askQuestion方法// 既设置了必要的action参数,也可在调用时不输入该参数。func askQuestion(action: UIAlertAction! = nil) &#123; &#125; Apple recommends you use .alert when telling users about a situation change, and .actionSheet when asking them to choose from a set of options. 像下面这样的方式 (preferredStyle: .actionSheet) 1234567891011121314151617181920navigationItem.rightBarButtonItem = UIBarButtonItem(title: &quot;Open&quot;, style: .plain, target: self, action: #selector(openTapped))@objc func openTapped() &#123; let ac = UIAlertController(title: &quot;Open page…&quot;, message: nil, preferredStyle: .actionSheet) // var websites = [&quot;apple.com&quot;, &quot;hackingwithswift.com&quot;] for website in websites &#123; ac.addAction(UIAlertAction(title: website, style: .default, handler: openPage)) &#125; ac.addAction(UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler: nil)) // 感觉主要是下面的代码,让菜单从下往上弹的。 // 没感觉下面这行代码的意义,没有也一样可以, // 但看到的很多代码都有这一样,而且一般是哪个button点击后调用的, // 就设置ac.popoverPresentationController?.barButtonItem对应该button。 // 但为啥要这么设置啊？？？？？？？？？？ ac.popoverPresentationController?.barButtonItem = self.navigationItem.rightBarButtonItem present(ac, animated: true)&#125; 添加TextField文本框供输入12345678910111213@objc func promptForAnswer() &#123; let ac = UIAlertController(title: &quot;Enter answer&quot;, message: nil, preferredStyle: .alert) // 可以添加不止一个TextField输入框 ac.addTextField() let submitAction = UIAlertAction(title: &quot;Submit&quot;, style: .default) &#123; [weak self, weak ac] action in guard let answer = ac?.textFields?[0].text else &#123; return &#125; self?.submit(answer) &#125; ac.addAction(submitAction) present(ac, animated: true)&#125; ac.addTextField(configurationHandler: &lt;#T##((UITextField) -&gt; Void)?##((UITextField) -&gt; Void)?##(UITextField) -&gt; Void#&gt;)下面是当注册需要设置密码时的例子: 1234ac.addTextField &#123; textField in textField.isSecureTextEntry = true textField.placeholder = &quot;Password&quot;&#125; UIActivityViewControllerUIActivityViewController will automatically give us functionality to share by iMessage, by email and by Twitter and Facebook, as well as saving the image to the photo library, assigning it to contact, printing it out via AirPrint, and more. It even hooks into AirDrop and the iOS extensions system so that other apps can read the image straight from us. 123456789101112131415navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .action, target: self, action: #selector(shareTapped))@objc func shareTapped() &#123; guard let image = imageView.image?.jpegData(compressionQuality: 0.8) else &#123; print(&quot;No image found&quot;) return &#125; // &quot;activityItems:&quot;是要传递的东西。这里传递的是一张图片。 let vc = UIActivityViewController(activityItems: [imageView.image!], applicationActivities: []) // 这里将vc.popoverPresentationController?.barButtonItem也绑定在navigationItem.rightBarButtonItem, // 感觉是,总得绑在一个触发的UIBarButtonItem上面,而只有这个正在被触发。 vc.popoverPresentationController?.barButtonItem = navigationItem.rightBarButtonItem present(vc, animated: true)&#125; 若选择Save Image,还需要编辑Info.plist在Info.plist中添加row,选择 “Privacy - Photo Library Additions Usage Description”, 添加String值类似“We need to save photos you like.” UIToolbarUIToolbar holds and shows a collection of UIBarButtonItem objects that the user can tap on. 123456let spacer = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil)let refresh = UIBarButtonItem(barButtonSystemItem: .refresh, target: webView, action: #selector(webView.reload))toolbarItems = [spacer, refresh]// 决定toolbarItems是否显示navigationController?.isToolbarHidden = false toolbar的样式设定123456789guard let toolbar = navigationController?.toolbar else &#123; return &#125;// background: transparenttoolbar.setBackgroundImage(UIImage(), forToolbarPosition: .any, barMetrics: .default)toolbar.setShadowImage(UIImage(), forToolbarPosition: .any)toolbar.isTranslucent = true// foregroundtoolbar.tintColor = .orange WKWebViewimport1import WebKit 正常使用1234567891011121314151617class ViewController: UIViewController, WKNavigationDelegate &#123; var webView: WKWebView! // 为什么要在loadView()而非viewDidLoad()中加载webView,那是因为这个view需要直接load成功,而非load完后再去加载,感觉会造成资源浪费 override func loadView() &#123; webView = WKWebView() // 因为下面这行,所以ViewController需要遵循WKNavigationDelegate !!! webView.navigationDelegate = self view = webView &#125; override func viewDidLoad() &#123; let url = URL(string: &quot;https://www.hackingwithswift.com&quot;)! webView.load(URLRequest(url: url)) webView.allowsBackForwardNavigationGestures = true &#125;&#125; 使用webView加载内容,并显示出来显示效果是类似这样的: 1234567891011121314151617181920212223242526272829303132333435363738import UIKitimport WebKitstruct Petition: Codable &#123; var title: String var body: String var signatureCount: Int&#125;class DetailViewController: UIViewController &#123; var webView: WKWebView! var detailItem: Petition? override func loadView() &#123; webView = WKWebView() view = webView &#125; override func viewDidLoad() &#123; super.viewDidLoad() guard let detailItem = detailItem else &#123; return &#125; let html = &quot;&quot;&quot; &lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;style&gt; body &#123; font-size: 150%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; \\(detailItem.body) &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot; webView.loadHTMLString(html, baseURL: nil) &#125;&#125; webView可实现的方法func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) { }123func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) &#123; title = webView.title&#125; 可实现网页显示标题 func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) { }1234567891011121314func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) &#123; let url = navigationAction.request.url if let host = url?.host &#123; for website in websites &#123; if host.contains(website) &#123; decisionHandler(.allow) return &#125; &#125; &#125; decisionHandler(.cancel)&#125; 这方法就像是网页浏览器的过滤器,任何url都会在这边过滤一下,最终决定是decisionHandler(.allow)运行呢,还是decisionHandler(.cancel)拒绝呢。 UIProgressViewUIProgressView is a colored bar that shows how far a task is through its work, sometimes called a “progress bar.” 实际案例 + 使用到addObserver&#x2F;observeValue这两个观察者&#x2F;处理者(即KVO)通过网页的加载进度,直接反映在UIProgressView进度条上: https://www.hackingwithswift.com/read/4/4/monitoring-page-loads-uitoolbar-and-uiprogressview 123456789101112131415161718192021222324252627282930313233343536var progressView: UIProgressView!override func loadView() &#123; webView = WKWebView() webView.navigationDelegate = self view = webView&#125;override func viewDidLoad() &#123; // 省略其他代码 let url = URL(string: &quot;https://hackingwithswift.com&quot;)! webView.load(URLRequest(url: url)) progressView = UIProgressView(progressViewStyle: .default) progressView.sizeToFit() let progressButton = UIBarButtonItem(customView: progressView) // 这里就让progressButton占满toolbarItems这一整行 toolbarItems = [progressButton] // 决定toolbarItems是否显示 navigationController?.isToolbarHidden = false // 在这个被定位主view的webView中增加一个观察者,主要观察这个key--WKWebView.estimatedProgress,有变化就会被告知 webView.addObserver(self, forKeyPath: #keyPath(WKWebView.estimatedProgress), options: .new, context: nil)&#125;// 这是观察后实时进行处理的函数override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123; if keyPath == &quot;estimatedProgress&quot; &#123; // estimatedProgress is a Double, Unhelpfully, UIProgressView&#x27;s progress property is a Float progressView.progress = Float(webView.estimatedProgress) &#125;&#125; UITextCheckerUITextChecker类来源于UIKit,在SwiftUI没有替代方案的情况下,只能使用该方法了。 使用的案例(简单实现,下面的NSRange和rangeOfMisspelledWord又会重复一遍这个操作):查找用户输入的英语单词是否在字典里,有没有拼错的情况: 12345678910111213141516import UIKitlet word = &quot;swift&quot;let checker = UITextChecker()// location是从哪个位置开始,一般都是0,length是计算word在utf16中的长度let range = NSRange(location: 0, length: word.utf16.count)// in是要核对的词,range是核对的范围长度,wrap是持续核对的意思(具体没有试过)let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: &quot;en&quot;)// 返回值要么是The range of the first misspelled word encountered// 没找到就是&#123;NSNotFound, 0&#125; if none is found.let allGood = misspelledRange.location == NSNotFound// 有这个单词也没拼错的情况返回true,不然返回false 方法的解释可以参考下面的文章: https://www.hackingwithswift.com/books/ios-swiftui/working-with-stringshttps://www.hackingwithswift.com/books/ios-swiftui/validating-words-with-uitextchecker 注意：UITextChecker uses the built-in system dictionary.我们不用为其特意准备单词表等文档。 Auto Layout 自动页面布局的设置通过Storyboard来设置 https://www.hackingwithswift.com/read/6/2/advanced-auto-layout 以上是三面国旗间如何通过storyboard来自动设置布局,以让起在portrait&#x2F;landscape中均能够有一个好的效果。通过该视频就能大致了解了,而看文字的话比较繁琐。 通过Storyboard自动布局后如何让它变为自动布局在Storyboard中布局各个view后,可以让屏幕自动布局页面,这样在landscape或是不同屏幕大小的机型上,都可以自动适应布局: Select the view controller by clicking on “View Controller” in the document outline, then go to the Editor menu and choose Resolve Auto Layout Issues &gt; Reset To Suggested Constraints. 通过Storyboard布局后,如何让一个view在Storyboard上回到它应该显示的位置上？我们在Storyboard上扔下一个UILabel,让其显示”Here is a UILbale !”,字体设置为30,随后通过鼠标contrl指向空白处,此时选择”Center Horizontally in safe area” &#x2F; “Center Vertically in safe area”,随后鼠标点击该label,我们看的是:我们来分析一个这个图:可以看到实线包围的label和一个虚线包围的label。实线的(the solid orange lines)代表你的label现在在的位置,而虚线的(the dashed orange lines)代表程序运行后你的label会在的位置。 那么如何让这个label回到它在程序运行后应该在的位置呢?Editor menu and choosing Resolve Auto Layout Issues &gt; Update Frames设置后是这样的:这样就这样了,没有橙线了。 通过addConstraints with Visual Format Language (VFL) https://www.hackingwithswift.com/read/6/3/auto-layout-in-code-addconstraints-with-visual-format-language 一个不通过Storyboard可视化布局来显示页面的简单例子:(因为之前有执念一直在想有没有办法能够实现,所以一知道怎么做了,就写进了笔记里) 123456789101112131415override func viewDidLoad() &#123; super.viewDidLoad() let imageView = UIImageView() // 关键的translatesAutoresizingMaskIntoConstraints的设置 imageView.translatesAutoresizingMaskIntoConstraints = false imageView.image = UIImage(systemName: &quot;star&quot;) imageView.layer.backgroundColor = UIColor.red.cgColor // 这里不要关心我这里布局代码用到的是anchor,只是随便用了个布局方法 imageView.widthAnchor.constraint(equalToConstant: 100).isActive = true imageView.heightAnchor.constraint(equalToConstant: 100).isActive = true view.addSubview((imageView)) &#125; 这里之前一直想随便写个view让其能够显示,始终没有显示,后来发觉是因为没有这行代码: 1imageView.translatesAutoresizingMaskIntoConstraints = false because by default iOS generates Auto Layout constraints for you based on a view’s size and position. We’ll be doing it by hand, so we need to disable this feature. Q: 为什么 imageView.translatesAutoresizingMaskIntoConstraints &#x3D; true 的时候就没有显示这个view呢？A: I have no answer……. 详细一点的例子: 12345678910111213141516171819202122232425262728293031323334353637383940// 首先是 五个label图像元素verride func viewDidLoad() &#123; super.viewDidLoad() let label1 = UILabel() label1.translatesAutoresizingMaskIntoConstraints = false label1.backgroundColor = UIColor.red label1.text = &quot;THESE&quot; label1.sizeToFit() let label2 = UILabel() label2.translatesAutoresizingMaskIntoConstraints = false label2.backgroundColor = UIColor.cyan label2.text = &quot;ARE&quot; label2.sizeToFit() let label3 = UILabel() label3.translatesAutoresizingMaskIntoConstraints = false label3.backgroundColor = UIColor.yellow label3.text = &quot;SOME&quot; label3.sizeToFit() let label4 = UILabel() label4.translatesAutoresizingMaskIntoConstraints = false label4.backgroundColor = UIColor.green label4.text = &quot;AWESOME&quot; label4.sizeToFit() let label5 = UILabel() label5.translatesAutoresizingMaskIntoConstraints = false label5.backgroundColor = UIColor.orange label5.text = &quot;LABELS&quot; label5.sizeToFit() view.addSubview(label1) view.addSubview(label2) view.addSubview(label3) view.addSubview(label4) view.addSubview(label5)&#125; 现在这些图像都挤在左上角！还互相叠着！ 设置一个dict: 1let viewsDictionary = [&quot;label1&quot;: label1, &quot;label2&quot;: label2, &quot;label3&quot;: label3, &quot;label4&quot;: label4, &quot;label5&quot;: label5] 添加布局: 123for label in viewsDictionary.keys &#123; view.addConstraints( NSLayoutConstraint.constraints(withVisualFormat: &quot;H:|[\\(label)]|&quot;, options: [], metrics: nil, views: viewsDictionary))&#125; NSLayoutConstraint.constraints(withVisualFormat:)相对比较关键。里面的用字符串表示的”H:|[label1]|”中,H代表Horizontal,前后的两个｜分别代表了屏幕的左右边缘。 看懂下面的代码: 1view.addConstraints( NSLayoutConstraint.constraints(withVisualFormat: &quot;V:|[label1]-[label2]-[label3]-[label4]-[label5]&quot;, options: [], metrics: nil, views: viewsDictionary)) 5个label按照次序沿着屏幕左侧开始依次排列。其中分隔每个label的符号”-“意味着有间隔,这个间隔的默认值是10,可以自定义。 以及设置更精确的数据: 1view.addConstraints( NSLayoutConstraint.constraints(withVisualFormat: &quot;V:|[label1(==88)]-[label2(==88)]-[label3(==88)]-[label4(==88)]-[label5(==88)]-(&gt;=10)-|&quot;, options: [], metrics: nil, views: viewsDictionary)) 以及使用到metrics参数的情况: 12let metrics = [&quot;labelHeight&quot;: 88]view.addConstraints( NSLayoutConstraint.constraints(withVisualFormat: &quot;V:|[label1(labelHeight)]-[label2(labelHeight)]-[label3(labelHeight)]-[label4(labelHeight)]-[label5(labelHeight)]-&gt;=10-|&quot;, options: [], metrics: metrics, views: viewsDictionary)) So when your designer &#x2F; manager &#x2F; inner-pedant decides that 88 points is wrong and you want some other number, you can change it in one place to have everything update. 以及使用优先级priority的情况:(优先级是从1-1000,数字越大优先级越高) - @数字 1&quot;V:|[label1(labelHeight@999)]-[label2(label1)]-[label3(label1)]-[label4(label1)]-[label5(label1)]-&gt;=10-|&quot; 自己理解:label1设置了一个高度,并对该高度设置了一个优先级,那么其他四个label的高度和其一样(包括优先级)。 通过Auto Layout anchors来自动布局Every UIView has a set of anchors that define its layouts rules.The most important ones arewidthAnchor, heightAnchor, topAnchor, bottomAnchor, leftAnchor, rightAnchor, leadingAnchor, trailingAnchor, centerXAnchor, and centerYAnchor. 一般用例: 1234for label in [label1, label2, label3, label4, label5] &#123; label.widthAnchor.constraint(equalTo: view.widthAnchor).isActive = true label.heightAnchor.constraint(equalToConstant: 88).isActive = true&#125; 一般用例: 1234567if let previous = previous &#123; // we have a previous label – create a height constraint label.topAnchor.constraint(equalTo: previous.bottomAnchor, constant: 10).isActive = true&#125; else &#123; // this is the first label label.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 0).isActive = true&#125; 这里用到的view.safeAreaLayoutGuide其实理解下来就是除了上下那两块的其他安全区域的屏幕范围。 还有这样的: 1yourView.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 0.5, constant: 50).isActive = true 就是在0.5倍的基础上再加50的意思。 还可以用到NSLayoutConstraint.activate集合很多规则: 123456NSLayoutConstraint.activate([ scoreLabel.topAnchor.constraint(equalTo: view.layoutMarginsGuide.topAnchor), scoreLabel.trailingAnchor.constraint(equalTo: view.layoutMarginsGuide.trailingAnchor), // more constraints to be added here!]) Notice the way I’m pinning the label to view.layoutMarginsGuide – that will make the score label have a little distance from the right edge of the screen. yourView.setContentHuggingPriority(UILayoutPriority(Int), for: )12cluesLabel.setContentHuggingPriority(UILayoutPriority(1), for: .vertical)answersLabel.setContentHuggingPriority(UILayoutPriority(1), for: .vertical) 优先级是从1-1000的,此处设置为1,代表最没有优先级,for是指适用于垂直面的。 创建的Game项目的屏幕大小layout的适配 https://www.hackingwithswift.com/read/14/2/getting-up-and-running-skcropnode 创建了一个Game项目,之前教程中均是使用spriteKit来制作的,一般都会设置屏幕大小为1024*768,这在一般iPad上都没问题,11-inch iPad Pro会比较特殊,所以需要做一个适配:在GameViewController.swift中,将“scene.scaleMode &#x3D; .aspectFill”替换成“scene.scaleMode &#x3D; .fill” UIEdgeInsets – 类似于给UIView加一个padding的设置我们创建一个UITextView: 1@IBOutlet var textView: UITextView! 并在storyboard上设置了它的大小,执行后是这样的: 如果我们给它加上Inset: 1textView.contentInset = UIEdgeInsets(top: 50, left: 50, bottom: 50, right: 50) 它就会是这样: UITabBarController如何更改Tabbar的显示文字和图标假设3个页面依次嵌套是这样的:View Controller Scene – Navigation Controller Scene – Tab Bar Controller Scene 如何更改Tabbar的显示文字和图标？需要在Storyboard中找到Navigation Controller Scene(而非Tab Bar Controller Scene),随后选到这个Tabbar元素(a new type of object called a UITabBarItem),再右侧属性栏的Bar Item中去更改其的Title和Image。 如何增加Tab页面 https://www.hackingwithswift.com/read/7/5/finishing-touches-didfinishlaunchingwithoptions 打开AppDelegate.swif,找寻到didFinishLaunchingWithOptions方法,在里面添加如下代码,最终的代码是: 12345678910111213141516func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -&gt; Bool &#123; if let tabBarController = window?.rootViewController as? UITabBarController &#123; // 以上代码,因为上面讲过3个页面嵌套,Tab Bar Controller Scene是最root的view // 找到我们的storyboard,我们的storyboard默认取名是Main let storyboard = UIStoryboard(name: &quot;Main&quot;, bundle: nil) // 之前给Navigation Controller Scene起过一个StoryboardID是NavController,这里生成一个这样的页面 let vc = storyboard.instantiateViewController(withIdentifier: &quot;NavController&quot;) // 从storyboard中可以看到,Navigation Controller Scene里面有一个tabBarItem, // 所以给tabBarItem定义成一个UITabBarItem,重要的是tag为1,因为本来就有存在的那个tag为0 vc.tabBarItem = UITabBarItem(tabBarSystemItem: .topRated, tag: 1) // 将该tabBarItem所在的vc添加进tabBarController tabBarController.viewControllers?.append(vc) &#125; return true&#125; 随后,如何在相同的一个ViewControllerScene中区别开是哪个tab页面? 123456789let urlString: Stringif navigationController?.tabBarItem.tag == 0 &#123; // urlString = &quot;https://api.whitehouse.gov/v1/petitions.json?limit=100&quot; urlString = &quot;https://www.hackingwithswift.com/samples/petitions-1.json&quot;&#125; else &#123; // urlString = &quot;https://api.whitehouse.gov/v1/petitions.json?signatureCountFloor=10000&amp;limit=100&quot; urlString = &quot;https://www.hackingwithswift.com/samples/petitions-2.json&quot;&#125; UILabel()12345678910111213scoreLabel = UILabel()scoreLabel.translatesAutoresizingMaskIntoConstraints = false// 设置对齐scoreLabel.textAlignment = .right// 设置内容scoreLabel.text = &quot;Score: 0&quot;// 设置字体大小scoreLabel.font = UIFont.systemFont(ofSize: 24)// 设置背景色scoreLabel.backgroundColor = .blue// 设置字体颜色scoreLabel.textColor = UIColor.redview.addSubview(scoreLabel) UITextfield1234567891011currentAnswer = UITextField()currentAnswer.translatesAutoresizingMaskIntoConstraints = false// 设置placeholdercurrentAnswer.placeholder = &quot;Tap letters to guess&quot;// 设置对齐currentAnswer.textAlignment = .center// 设置字体大小currentAnswer.font = UIFont.systemFont(ofSize: 44)// 设置是否用户可输入currentAnswer.isUserInteractionEnabled = falseview.addSubview(currentAnswer) 注意:UITextField只能显示一行,而UITextView可以显示多行,这就是两者的区别。 UITextViewUITextView可以显示多行,而UITextField只能显示一行,这就是两者的区别。 UITextView.contentInset – 类似于一个padding具体操作见 “Auto Layout 自动页面布局的设置” -&gt; “UIEdgeInsets” 。 UITextView.endEditing(true&#x2F;false) – 隐藏&#x2F;显示 keyboard12// textView: UITextViewtextView.endEditing(true) UITextView的resignFirstResponder()就是取消focus,让键盘隐藏的作用。This is used to tell a view that has input focus that it should give up that focus. Or, in Plain English, to tell our text view that we’re finished editing it, so the keyboard can be hidden. 12345678@objc func saveSecretMessage() &#123; guard secret.isHidden == false else &#123; return &#125; KeychainWrapper.standard.set(secret.text, forKey: &quot;SecretMessage&quot;) secret.resignFirstResponder() secret.isHidden = true title = &quot;Nothing to see here&quot;&#125; p.s. GCD - Grand Central DispatchGCD是帮助你自动化管理进程的一套东西。GCD中的三个方法之一，最重要的就是async()。 后台进程中,有四种选择,或者叫QoS level set: User Interactive: this is the highest priority background thread, and should be used when you want a background thread to do work that is important to keep your user interface working. This priority will ask the system to dedicate nearly all available CPU time to you to get the job done as quickly as possible. User Initiated: this should be used to execute tasks requested by the user that they are now waiting for in order to continue using your app. It’s not as important as user interactive work – i.e., if the user taps on buttons to do other stuff, that should be executed first – but it is important because you’re keeping the user waiting. The Utility queue: this should be used for long-running tasks that the user is aware of, but not necessarily desperate for now. If the user has requested something and can happily leave it running while they do something else with your app, you should use Utility. The Background queue: this is for long-running tasks that the user isn’t actively aware of, or at least doesn’t care about its progress or when it completes. Those QoS queues affect the way the system prioritizes your work: User Interactive and User Initiated tasks will be executed as quickly as possible regardless of their effect on battery life, Utility tasks will be executed with a view to keeping power efficiency as high as possible without sacrificing too much performance, whereas Background tasks will be executed with power efficiency as its priority. 如何使用: 123// 在默认的Background queue进程中// The default GCD background queue has a lower priority than .userInitiated but higher than .utility.DispatchQueue.global().async &#123; 12// 指定在User Initiated进程中DispatchQueue.global(qos: .userInitiated).async &#123; 此外,在 async() 里面的代码不需要使用[weak self] in之类的语句,因为async()执行完就会被丢弃,不存在留存东西的情况。 performSelector(inBackground:) 和 performSelector(onMainThread:) 这两种方法更好用一些,因为更加简单,只要决定是放在main thread,还是background上运行就行。(初步用下来,performSelector会有些问题,莫名的警告之类的,可能更推荐使用DispatchQueue.global()&#x2F;DispatchQueue.main之类的吧)示例代码: 1234567performSelector(onMainThread: #selector(showError), with: nil, waitUntilDone: false)@objc func showError() &#123; let ac = UIAlertController(title: &quot;Loading error&quot;, message: &quot;There was a problem loading the feed; please check your connection and try again.&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) present(ac, animated: true)&#125; This is an Objective-C call, so the @objc attribute is required. 这里发现个情况，几种代码的情况竟然都是可以的:场景是,一个class ViewController: UITableViewController内定义了fun tableView的实现,这时候,需要在background中对tabaleView中的UI数据进行更新,肯定是要在主线程即main thread中更新的,我们可以: 123DispatchQueue.main.async &#123; self?.tableView.reloadData()&#125; 也可以: 12// 这里写self?是因为在DispatchQueue.global().async这个closure中,里面引用的外部self必须是个optional,这里请忽略self?.tableView.performSelector(onMainThread: #selector(self?.tableView.reloadData), with: nil, waitUntilDone: false) 竟然还可以: 1self?.tableView.performSelector(onMainThread: #selector(UITableView.reloadData), with: nil, waitUntilDone: false) 没想到的是,#selector(UITableView.reloadData)中的“UITableView.”竟然也是可以引用到这个方法的,一时半会儿有点概念不清晰，但又感觉可能可以。 DispatchWorkItem – dispatch queue 或 dispatch group 下的运行单元定义:A DispatchWorkItem encapsulates work to be performed on a dispatch queue or a dispatch group. It is primarily used in scenarios where we require the capability of delaying or canceling a block of code from executing. 为什么需要DispatchWorkItem,而不是直接在DispatchQueue.global()&#x2F;DispatchQueue.main中直接定义要运行的代码?因为DispatchWorkItem可以为后续停止该DispatchWorkItem埋下伏笔。在开始或运行该DispatchWorkItem之前,你都可以cancel掉或delay掉。 示例代码1: 12345678910111213141516171819202122232425class Controller &#123; var workItem: DispatchWorkItem? func getSearchResults(query: String) &#123; workItem?.cancel() let newWorkItem = DispatchWorkItem &#123; print(&quot;send a backend request for \\(query)&quot;) // async task to fetch results based on the query &#125; workItem = newWorkItem DispatchQueue.global().asyncAfter( deadline: .now() + .milliseconds(30), execute: newWorkItem ) &#125;&#125;let cont = Controller()cons.getSearchResults(query: &quot;s&quot;)cons.getSearchResults(query: &quot;sh&quot;)Thread.sleep(forTimeInterval: Double.random(in: 1...3))cons.getSearchResults(query: &quot;shi&quot;)cons.getSearchResults(query: &quot;shir&quot;)// 执行后的打印结果:// send a backend request for sh// send a backend request for shir 以上代码的使用场景,比如用户在注册用户名时,当用户输入时,下一个输入字符超过多少时长的情况下,程序就会将该输入的字符放松到服务器进行校验;若在规定时间内输入了,由于有workItem?.cancel(),所以就会取消校验,等下次用户的输入超时的情况。 示例代码2: 1234567891011121314151617181920class MainViewController: UIViewController &#123; var showAnimatedPresentation: DispatchWorkItem? override func viewDidAppear(_ animated: Bool) &#123; showAnimatedPresentation = DispatchWorkItem &#123; // show some cool animated presentation print(&quot;showing animated Presentation&quot;) &#125; // show the animated presentation, if the user hasn&#x27;t interacted with // the app for more than 4 seconds DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(4), execute: showAnimatedPresentation!) &#125; func usedTheApp() &#123; // will cancel the workitem from executing showAnimatedPresentation?.cancel() print(&quot;app used&quot;) &#125;&#125; 以上代码,若正常运行,且用户未执行usedTheApp方法,则会在4秒后执行该DispatchWorkItem;但若4秒内用户执行了usedTheApp方法,则该DispatchWorkItem不会被执行到,因为被cancel()掉了。 DispatchWorkItem 的 notify() 和 perform()DispatchWorkItem 的 Notify() 的作用是:一个DispatchWorkItem可以指定一个特殊的workItem,使用DispatchWorkItem的Notify()来实现。当DispatchWorkItem执行完毕后,这个特殊的workItem会接着执行,像是一个执行的序列一样:示例代码3: 123456789101112131415161718192021222324252627class Controller &#123; func getSomethingFromServer() &#123; let newWorkItem = DispatchWorkItem &#123; print(&quot;fetching data from the server&quot;) // async task to fetch results based on the query &#125; // work item to notify the view that the info is ready let notifyTheView = DispatchWorkItem &#123; print(&quot;the info from server has arrived&quot;) &#125; // this get executed when newWorkItem has finished execution newWorkItem.notify(queue: .main) &#123; notifyTheView.perform() &#125; DispatchQueue.global().async(execute: newWorkItem) &#125;&#125;let cont = Controller()cont.getSomethingFromServer()/*fetching data from the server&lt;NSThread: 0x600001ced040&gt;&#123;number = 5, name = (null)&#125;the info from server has arrived&lt;_NSMainThread: 0x600001ce81c0&gt;&#123;number = 1, name = main&#125;*/ newWorkItem执行完的同时,将会执行notify中的内容,而DispatchWorkItem的perform()是同步执行的,并非异步执行。 DispatchWorkItem 的 perform()Perform():Executes the work item’s block synchronously on the current thread. 12345let worker = DispatchWorkItem &#123; [weak self] in // 省略代码&#125;worker.perform() // 在当前进程中同步执行 DispatchWorkItem 的 wait()DispatchWorkItem的wait()的作用,是由某个DispatchWorkItem来阻塞(block)这个thread,直到这个DispatchWorkItem执行完毕。示例代码4: 123456789101112131415161718192021222324class Controller &#123; func getSomethingFromServer() &#123; let newWorkItem = DispatchWorkItem &#123; print(&quot;fetching data from the server&quot;) print(Thread.current) &#125; DispatchQueue.global().async(execute: newWorkItem) // blocks the thread until newWorkItem finishes execution newWorkItem.wait() // This gets printed after newWorkItem finishes execution print(&quot;finishes execution&quot;) &#125;&#125;let cont = Controller()cont.getSomethingFromServer()/*fetching data from the server&lt;NSThread: 0x600003090f40&gt;&#123;number = 6, name = (null)&#125;finishes execution*/ 但并不推荐使用wait(),因为会在执行时造成阻塞。 非常非常奇怪:为何示例代码4代码中,DispatchQueue.global().async(execute: newWorkItem)换成xxxx.main.xxx,在playground中就会停止运行也未报错。这是为何？ UICollectionView https://www.hackingwithswift.com/read/10/2/designing-uicollectionview-cells 在Storyboard上创建UIColletionView的过程,与创建UITableView差不多,也是在删除原有的controller,在libraries里拖拉出一个Collection View Controller拖进storyboard。 接下来要建立一个对应UICollectionViewCell的Cocoa Touch Class的文件,在storyboard中找到CollectionViewCell(就如同找到table cell一样),让其的class对应该协议,此外要给该CollectionViewCell的identifier取个名字,好在代码中生成这个cell。 IndexPath(item: Int, section: Int) let indexPath = IndexPath(item: 1, section: 0) 需要实现的方法override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int { }示例代码: 123override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 10&#125; override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {}示例代码: 123456789override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;Person&quot;, for: indexPath) as? PersonCell else &#123; // we failed to get a PersonCell – bail out! fatalError(&quot;Unable to dequeue PersonCell.&quot;) &#125; // if we&#x27;re still here it means we got a PersonCell, so we can return it return cell&#125; 可以实现的方法override func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) { }示例代码1: 1234567891011121314151617override func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; let person = people[indexPath.item] let ac = UIAlertController(title: &quot;Rename person&quot;, message: nil, preferredStyle: .alert) ac.addTextField() ac.addAction(UIAlertAction(title: &quot;Cancel&quot;, style: .cancel)) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default) &#123; [weak self, weak ac] _ in guard let newName = ac?.textFields?[0].text else &#123; return &#125; person.name = newName self?.collectionView.reloadData() &#125;) present(ac, animated: true)&#125; 示例代码2: 1234567override func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; // 取得被点击的cell guard let cell = collectionView.cellForItem(at: indexPath) as? CardCell else &#123; return &#125; // ......&#125; collectionView.cellForItem(at: IndexPath) – 取得collectionView中指定的cell具体用法见上面的例子。 func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize { }要求处理collectionView的delegate给每个collectionView设置指定的layOut,比如说大小等。 Asks the delegate for the size of the specified item’s cell. 如果你不使用本方法来定义,则collectionView就会使用默认的itemSize,那么如何改变默认尺寸的值呢,应该是在storyBoard中设置Collection View、cell的尺寸以及Collection View Flow Layout的具体数值。见图:在代码中查看itemSize的办法: 123456let layout = collectionView.collectionViewLayout as? UICollectionViewFlowLayoutlayout?.itemSize = CGSize(width: 200, height: 200)print(layout?.itemSize)/*Optional((200.0, 200.0))*/ 这样的话,能够查看了,虽然上述代码也改变了itemSize的值,但却发现没有效果。是不是一定要用到下面collectionView的sizeForItemAt方法来实时变更itemSize的值？ 看一下某个例子中的代码: 1234567891011121314extension GameViewController: UICollectionViewDelegateFlowLayout &#123; // 必须要让实现UICollectionViewController协议的类再遵循UICollectionViewDelegateFlowLayout协议,不然会无效!!! func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize &#123; if currentCardSizeValid &#123; return currentCardSize &#125; currentCardSize = cardSize.getCardSize(collectionView: collectionView) currentCardSizeValid = true return currentCardSize &#125; &#125; 上面方法中,cardSize.getCardSize方法是自定义的用来计算尺寸的方法,此外,还多了一个flag就是currentCardSizeValid,为何要设置这个,因为多少个cell,就会计算多少次尺寸,为了节约资源,毕竟每个cell应该都是一样大小的(应该会有例外的情况),这时候只要沿用而不是重复计算才是最好的。 cardSize.getCardSize(collectionView: collectionView)的具体代码实现见下面。 如何更好地计算collectionCell的图片的合适大小场景是:比如给到图片的大小(这就能算到图片的比例),又给到34的排放顺序(43也是可以的,需要计算哪个更划算),这时候就需要根据屏幕是横屏还是竖屏,来最终决定图片的实际大小,也就是collectionCell的最终大小。 具体见文件 CardSize.swift,以及如何分配横竖排的关系的文件Grids.swift和Grid.swift。 UIImagePickerControllerThis new class is designed to let users select an image from their camera to import into an app. When you first create a UIImagePickerController, iOS will automatically ask the user whether the app can access their photos. 注意:使用UIImagePickerController不需要取得用户的同意,因为它是整个被UIKit掌控的,iOS知道我们不会去滥用它,所以不需要取得用户的许可。 privacy permission查看、使用用户的照片,需要对用户进行告知:we need to add a text string describing our intent. So, open Info.plist, select any item, click +, then choose the key name “Privacy - Photo Library Additions Usage Description”. Give it the value “We need to import photos” then press return. 一般示例代码123456789101112// 先由一个按钮引出navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(addNewPerson))// 引出方法@objc func addNewPerson() &#123; let picker = UIImagePickerController() picker.allowsEditing = true // 由于这行代码,需要本身的class必须遵循到UIImagePickerControllerDelegate protocol, // 而且还要额外遵循 UINavigationControllerDelegate protocol. picker.delegate = self present(picker, animated: true)&#125; 用户选择照片后,会自动运行到一个方法: 1234567891011121314151617func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) &#123; guard let image = info[.editedImage] as? UIImage else &#123; return &#125; let imageName = UUID().uuidString let imagePath = getDocumentsDirectory().appendingPathComponent(imageName) if let jpegData = image.jpegData(compressionQuality: 0.8) &#123; try? jpegData.write(to: imagePath) &#125; dismiss(animated: true)&#125;func getDocumentsDirectory() -&gt; URL &#123; let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask) return paths[0]&#125; 其中,info参数是一个dict,它有两个参数,分别是 .editedImage (the image that was edited) or .originalImage , but in our case it should only ever be the former unless you change the allowsEditing property. UIImagePickerController实例的.sourceType.sourceType 可取值 UIImagePickerController.camera, 表示从camera中拍照并取得照片。但前提还得去判断是否开放该功能:UIImagePickerController.isSourceTypeAvailable(.camera) 123456789// 先判断用户是不是允许从camera中拍摄并取得照片if UIImagePickerController.isSourceTypeAvailable(.camera) &#123; // 省略用户选择从camera拍摄并取得照片的部分代码 let picker = UIImagePickerController() picker.allowsEditing = true picker.delegate = self picker.sourceType = .camera present(picker, animated: true)&#125; 详细的实现代码可供参考: 12345678910111213141516171819202122232425262728293031323334// viewDidLoad()中的代码addPersonButton = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(addNewPerson))navigationItem.leftBarButton = addPerButton// addNewPerson方法@objc func addNewPerson() &#123; if UIImagePickerController.isSourceTypeAvailable(.camera) &#123; let ac = UIAlertController(title: &quot;Source&quot;, message: nil, preferredStyle: .actionSheet) ac.addAction(UIAlertAction(title: &quot;Photos&quot;, style: .default, handler: &#123; [weak self] _ in self?.showPicker(fromCamera: false) &#125;)) ac.addAction(UIAlertAction(title: &quot;Camera&quot;, style: .default, handler: &#123; [weak self] _ in self?.showPicker(fromCamera: true) &#125;)) ac.addAction(UIAlertAction(title: &quot;Cancel&quot;, style: .cancel)) ac.popoverPresentationController?.barButtonItem = navigationItem.leftBarButtonItem present(ac, animated: true) &#125; else &#123; showPicker(fromCamera: false) &#125;&#125;// showPicker方法func showPicker(fromCamera: Bool) &#123; let picker = UIImagePickerController() picker.allowsEditing = true picker.delegate = self if fromCamera &#123; picker.sourceType = .camera &#125; present(picker, animated: true)&#125; SpriteKit(According to the project 11 from “100 hundred days of Swift”) Create a new project in xCode and choose Game, sets its Game Technology to be Spritekit. 坐标系统的不同1.UIKit的物体坐标都是基于一个view的左上角为起点的,而SpriteKit是基于物体的中心点。2.UIKit的坐标系Y:0是基于屏幕的上边沿,而SpriteKit是基于屏幕的下边沿。 GameScene.sks 是类似于Interface Builder的双击打开GameScene.sks,就打开了Scene Editor,这图形界面类似于Interface Builder。 SKScene当建立一个project是基于Game的，那么GameScene.swift文件的GameScene这个class就是基于SKScene协议的。 didMove(to:) 类似于viewDidLoad()在里面写入代码: 123456789101112override func didMove(to view: SKView) &#123; // 建立一个背景图片的节点 let background = SKSpriteNode(imageNamed: &quot;background.jpg&quot;) // 图片的中心点是基于CGPoint坐标的,这里设置的是屏幕的中心点 background.position = CGPoint(x: 512, y: 384) // The .replace option means &quot;just draw it, ignoring any alpha values,&quot; which makes it fast for things without gaps such as our background. background.blendMode = .replace // 这个背景图片的节点在整个场景的z坐标的-1位置,其实就是放在最后面 background.zPosition = -1 // 这是用于给场景添加节点的方法 addChild(background)&#125; override func didMove(to view: SKView) { }这个类似于viewDidLoad方法。 override func update(_ currentTime: TimeInterval) { }The update() method is called once every frame, and lets us make changes to our game.Try not to do too much work, because it can slow your game down. override func touchesBegan(_ touches: Set, with event: UIEvent?) { }1234567891011121314override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; // 每次触碰到屏幕就会进入循环 if let touch = touches.first &#123; // 取得触碰的位置坐标 let location = touch.location(in: self) // 生成一个SKSpriteNode节点,该节点是基于CGSize生成的一个红色正方形 let box = SKSpriteNode(color: UIColor.red, size: CGSize(width: 64, height: 64)) // 该正方形所放置的位置 box.position = location // 添加进场景 addChild(box) &#125;&#125; override func touchesEnded(_ touches: Set, with event: UIEvent?) {}Tells the responder when one or more fingers raised from a view or window. override func touchesMoved(_ touches: Set, with event: UIEvent?) { }测试下来,跟touchesBegan一样的用法,只是它只在触摸屏幕并移动时,才会被触发。touchesMoved() is called when an existing touch changes position. SKSpriteNode 类似于各个主页面的节点建立一个正方形: 1SKSpriteNode(color: UIColor.red, size: CGSize(width: 64, height: 64)) 建立一个基于image文件的图形: 1SKSpriteNode(imageNamed:) 好像不能直接建立一个圆形,是不是先要做一个圆形出来,随后再基于该圆形设计出该SKSpriteNode?待后续碰到了再补充吧…但下面代码中ball.physicsBody &#x3D; SKPhysicsBody(circleOfRadius: ball.size.width &#x2F; 2.0)就可以设计出一个圆形的物理属性来。 SKSpriteNode.texture -&gt; SKTexture(imageNamed:)class called SKTexture, which is to SKSpriteNode sort of what UIImage is to UIImageView – it holds image data, but isn’t responsible for showing it. 1234567// 之前设定的charNode是一个SKSpriteNode,显示的是图片&quot;penguinGood&quot;charNode = SKSpriteNode(imageNamed: &quot;penguinGood&quot;)// 但现在我想把charNode显示的图片改成是&quot;penguinEvil&quot;// 这时只要更改charNode的材质,即charNode.texture// open class SKSpriteNode : SKNode, SKWarpable &#123;// open var texture: SKTexture?charNode.texture = SKTexture(imageNamed: &quot;penguinEvil&quot;) Changing the character node’s texture like this is helpful because it means we don’t need to keep adding and removing nodes. Instead, we can just change the texture to match what kind of penguin this is, then change the node name to match so we can do tap detection later on. SKSpriteNode(texture:)可以直接用SKTexture生成SKSpriteNode,而不需要再设置SKSpriteNode的texture: 1234// 先设置SKTexturelet skyTexture = SKTexture(imageNamed: &quot;sky&quot;)// 再生成SKSpriteNodelet sprite = SKSpriteNode(texture: skyTexture) SKSpriteNode.colorBlendFactor &#x3D; 1 &amp;&amp; SkSpriteNode.color &#x3D; .redOnly SKSpriteNode has a colorBlendFactor property !!!SKSpriteNode.colorBlendFactor是一个CGFloat,从0.0到1.0,代表与原材质的颜色的混同程序,0.0代表颜色不会改变,就是原材质,1.0代表可以完全改变原材质的颜色。 1234let firework = SKSpriteNode(imageNamed: &quot;rocket&quot;)firework.colorBlendFactor = 1// 这时可以设置其的颜色fireworl.color = .cyan SKShapeNodeSKShapeNode是SpriteKit的一个class,它可以让你在Game中方便且快捷地画出随意的图形,比如画圆形、线、长方形,之前接触到的就是使用贝塞尔图形来画画,在Project23中,水果忍者游戏中用来切水果划屏幕的那条线,它的容器就是SKShapeNode。 SKShapeNode有一个属性叫path,是用来描绘我们想要画的图形的。当path为nil,就什么都不画了;当path被设置为一个有效的路径的话,就可以按照SKShapeNode的设置来画图形了。另外,SKShapeNode期望的path是一个CGPath属性,而我们使用UIBezierPath.cgPath就能够符合这一要求了。 1234567let shape = SKShapeNode()shape.path = UIBezierPath(roundedRect: CGRect(x: -128, y: -128, width: 256, height: 256), cornerRadius: 64).cgPathshape.position = CGPoint(x: frame.midX, y: frame.midY)shape.fillColor = UIColor.redshape.strokeColor = UIColor.blueshape.lineWidth = 10addChild(shape) 水果忍者中那条划过屏幕的线代码太多,还是看教程中的代码,读一遍就懂了。 https://www.hackingwithswift.com/example-code/games/how-to-create-shapes-using-skshapenode SKPhysicsBody属性感觉是给 场景 或 节点 添加物理属性范围的。 1234567// box虽然有两个框架,就是上面设置的正方形// 但还得给这个box设置一个物理框架,范围就是这个正方形的范围(也就是说也能设置个圆形物理框架吧吧)box.physicsBody = SKPhysicsBody(rectangleOf: CGSize(width: 64, height: 64))// The second line of code adds a physics body to the whole scene that is a line on each edge, effectively acting like a container for the scene.physicsBody = SKPhysicsBody(edgeLoopFrom: frame) 还能添加圆形的球以及圆形的物理属性范围,以及使用到 .resitution 的反弹属性,值范围为0-1的小数。 1234567let ball = SKSpriteNode(imageNamed: &quot;ballRed&quot;)// ball的物理属性范围仍旧是其本身ball.physicsBody = SKPhysicsBody(circleOfRadius: ball.size.width / 2.0)// restitution是 恢复原状 的意思ball.physicsBody?.restitution = 0.4ball.position = locationaddChild(ball) 设计一个有物理属性但不会跟着动的东西,简单说就是,我造了个东西,这东西被撞了却不会动,但撞它的其他东西会被弹开:这里使用到了 .isDynamic : 12345let bouncer = SKSpriteNode(imageNamed: &quot;bouncer&quot;)bouncer.position = CGPoint(x: 512, y: 0)bouncer.physicsBody = SKPhysicsBody(circleOfRadius: bouncer.size.width / 2.0)bouncer.physicsBody?.isDynamic = falseaddChild(bouncer) SKPhysicsBody(texture: &lt;#T##SKTexture#&gt;, size: &lt;#T##CGSize#&gt;)之前都是SKPhysicsBody(circleOfRadius),或者SKPhysicsBody(rectangleOf: &lt;#T##CGSize#&gt;)来定义,虽然对生成SKPhysicsBody的效率会有很大的提高,但有时候需要让该物体的每个pixel都作为SKPhysicsBody的时候,就需要用到SKPhysicsBody(texture: &lt;#T##SKTexture#&gt;, size: &lt;#T##CGSize#&gt;),虽然会降低效率,但有时是有必要的。SpriteKit can create pixel-perfect collision detection by examining the pixels in a sprite’s texture. 123// let sprite = SKSpriteNode(imageNamed: &quot;enemy&quot;)sprite.physicsBody = SKPhysicsBody(texture: sprite.texture!, size: sprite.size) 节点的physicsBody?.categoryBitMask属性碰撞的时候,需要识别碰撞体,最简单的方式,是给节点设置一个name的值,但也可以给节点的physicsBody?.categoryBitMask添加值,这里的bit可以理解为是位运算的意思。注意：UInt8,UInt16,UInt32,UInt64 分别表示 8 位,16 位,32 位 和 64 位的无符号整数形式。比如: 12345// 设置物理体的标示符 &lt;&lt;左移运算符 左移一位，相当于扩大2倍let birdCategory: UInt32 = 1 &lt;&lt; 0 //1let worldCategory: UInt32 = 1 &lt;&lt; 1 //2let pipeCategory: UInt32 = 1 &lt;&lt; 2 //4let scoreCategory: UInt32 = 1 &lt;&lt; 3 //8 具体的例子见 ontactTestBitMask &amp;&amp; collisionBitMask 知识点。(会带上上面的四个标识符一起使用) 节点的physicsBody?的velocity速度属性可设置该节点的速度,比如在touchesBegan方法中,当用户点击屏幕,就对速度进行更改: 12345678910override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; // 省略其他代码 // 本来因为重力等原因dy是负值,用户点击的同时,值为0 bird.physicsBody?.velocity = CGVector(dx: 0, dy: 0) // 但一旦停止点击,dy的值又会变成负值,小鸟又会不断下降,这是因为 // self.physicsWorld.gravity = CGVector(dx: 0.0, dy: -3.0) 这个的预先设定 // 此时可以给其一个向上的速度或是力 bird.physicsBody?.applyImpulse(CGVector(dx: 0, dy: 10)) 节点的physicsBody?的applyImpulse方法在 “节点的physicsBody?的velocity速度属性”知识点的例子中已经出现。 这里还有一个例子: 123456// 给香蕉一个自转速度和顺时针方向banana.physicsBody?.angularVelocity = -20// 之前给用户两个slider以设置角度(后换算成radians)和速度(speed),let impulse = CGVector(dx: cos(radians) * speed, dy: sin(radians) * speed)banana.physicsBody?.applyImpulse(impulse) 节点的physicsBody?的angularVelocity属性angularVelocity 是指自身旋转的速度。 123// sprite.physicsBody = SKPhysicsBody(texture: sprite.texture!, size: sprite.size)sprite.physicsBody?.angularVelocity = 5 节点的physicsBody?的angularDamping属性angularDamping 是指减少自身旋转的速度。 1234// sprite.physicsBody = SKPhysicsBody(texture: sprite.texture!, size: sprite.size)// sprite.physicsBody?.angularVelocity = 5sprite.physicsBody?.angularDamping = 2 节点的physicsBody?的linearDamping属性linearDampin 是指减少linear上的移动速度。 1234// sprite.physicsBody = SKPhysicsBody(texture: sprite.texture!, size: sprite.size)// sprite.physicsBody?.velocity = CGVector(dx: -500, dy: 0)sprite.physicsBody?.linearDamping = 0 节点的physicsBody?的usesPreciseCollisionDetection属性注意:Precise collision detection should be used rarely, and only generally with small, fast-moving objects. 12345678banana = SKSpriteNode(imageNamed: &quot;banana&quot;)banana.name = &quot;banana&quot;banana.physicsBody = SKPhysicsBody(circleOfRadius: banana.size.width / 2)banana.physicsBody?.categoryBitMask = CollisionTypes.banana.rawValuebanana.physicsBody?.collisionBitMask = CollisionTypes.building.rawValue | CollisionTypes.player.rawValuebanana.physicsBody?.contactTestBitMask = CollisionTypes.building.rawValue | CollisionTypes.player.rawValuebanana.physicsBody?.usesPreciseCollisionDetection = trueaddChild(banana) 示例游戏中,旋转的香蕉会撞向大楼,具体撞击的点会把大楼轰出一个半圆出来,这时候使用usesPreciseCollisionDetection属性,感觉是让返回的撞击点更加精确。 SKScene的physicsWorld属性SKScene的physicsWorld.gravity–重力属性其实感觉不能叫重力属性,因为你可以设置成各个方向都有引力。self.physicsWorld.gravity是CGVector数据类型。 1self.physicsWorld.gravity = CGVector(dx: 0.0, dy: -3.0) 以上代码,代表x方向没有正引力也没有负引力,y方向有3个负引力。 SKScene的physicsWorld.contactDelegate 代理物理世界的碰撞检测代理一般都设置为场景自己: 1self.physicsWorld.contactDelegate = self 此时场景需要遵循 SKPhysicsContactDelegate 的代理协议。 SKActionSKAction.setTexture()给予SKNode一个新的Texture,目的是为了在SKAction.sequence中有一个动画效果。例如: 12345678banana.physicsBody?.angularVelocity = -20// player1 = SKSpriteNode(imageNamed: &quot;player&quot;)let raiseArm = SKAction.setTexture(SKTexture(imageNamed: &quot;player1Throw&quot;))let lowerArm = SKAction.setTexture(SKTexture(imageNamed: &quot;player&quot;))let pause = SKAction.wait(forDuration: 0.15)let sequence = SKAction.sequence([raiseArm, pause, lowerArm])player1.run(sequence) SKAction.rotate先加载一个图形: 1var slotGlow: SKSpriteNode = SKSpriteNode(imageNamed: &quot;slotGlowGood&quot;) 是这个样子的: 我们要让它沿着中心点始终在转: 123456789// 如何运动:// 1.旋转 -- rotate// 2.角度一个pi,即180度// 3.时间为10秒,就是旋转的快慢let spin = SKAction.rotate(byAngle: .pi, duration: 10)// 始终在旋转不停止let spinForever = SKAction.repeatForever(spin)// 让这个slotGlow运行这个运动模式slotGlow.run(spinForever) SKAction.moveBy(x:y:duration:)移动位置及持续时间。 123// charNode = SKSpriteNode(imageNamed: &quot;penguinGood&quot;)// charNode已可在主画面显示charNode.run(SKAction.moveBy(x: 0, y: 80, duration: 0.05)) SKAction.wait(forDuration:)等待。以秒计算。 1let delay = SKAction.wait(forDuration: 0.25) SKAction.animate(with: &lt;#T##[SKTexture]#&gt;, timePerFrame: &lt;#T##TimeInterval#&gt;)比如做一个小鸟飞翔的动画,可以拿到的小鸟的照片分别是bird-01&#x2F;bird-02&#x2F;bird-03,图像分别是:代码是: 1234567891011// bird = SKSpriteNode(imageNamed: &quot;bird-01&quot;)let birdTexture1 = SKTexture(imageNamed: &quot;bird-01&quot;)birdTexture1.filteringMode = .nearestlet birdTexture2 = SKTexture(imageNamed: &quot;bird-02&quot;)birdTexture2.filteringMode = .nearestlet birdTexture3 = SKTexture(imageNamed: &quot;bird-03&quot;)birdTexture3.filteringMode = .nearestlet anim = SKAction.animate(with: [birdTexture1,birdTexture2,birdTexture3], timePerFrame: 0.2)bird.run(SKAction.repeatForever(anim), withKey: &quot;fly&quot;) SKAction.run(block:)SKAction.run(block:) will run any code we want, provided as a closure. “Block” is Objective-C’s name for a Swift closure. 1let notVisible = SKAction.run &#123; [unowned self] in self.isVisible = false &#125; 为何要用SKAction.run来执行这段代码,而不是直接去执行呢?感觉是因为类似下面的SKAction.sequence()需要依序执行action和改变一些属性的情况。 SKSpriteNode.run(&lt;#T##action: SKAction##SKAction#&gt;, withKey: &lt;#T##String#&gt;)这里出现一个withKey参数,可以这么设置: 1bird.run(SKAction.repeatForever(anim), withKey: &quot;fly&quot;) 如果要停止这个动画,就可以使用到: 1bird.removeAction(forKey: &quot;fly&quot;) 还有一个让SKLabelNode显示的文字瞬间变大又还原的案例: 1scoreLabelNode.run(SKAction.sequence([SKAction.scale(to: 1.5, duration: TimeInterval(0.1)), SKAction.scale(to: 1.0, duration: TimeInterval(0.1))])) SKSpriteNode.removeAction(forKey: &lt;#T##String#&gt;)紧接着上面的例子,用法是: 1bird.removeAction(forKey: &quot;fly&quot;) SKAction.sequence()SKAction.sequence() takes an array of actions, and executes them in order. Each action won’t start executing until the previous one finished. 12345678func hit() &#123; isHit = true let delay = SKAction.wait(forDuration: 0.25) let hide = SKAction.moveBy(x: 0, y: -80, duration: 0.5) let notVisible = SKAction.run &#123; [unowned self] in self.isVisible = false &#125; charNode.run(SKAction.sequence([delay, hide, notVisible]))&#125; SKAction.group()An action group specifies that all actions inside it should execute simultaneously.这里要注意的一点是,SKAction.group()内的SKAction,是同时执行的,所以我们平时可以配合SKAction.sequence()一起使用,但要注意两者的明显不同之处。 123456let scaleOut = SKAction.scale(to: 0.001, duration: 0.2)let fadeOut = SKAction.fadeOut(withDuration: 0.2)let group = SKAction.group([scaleOut, fadeOut])let seq = SKAction.sequence([group, .removeFromParent()])node.run(seq) 背景闪电的案例使用到 SKAction.sequence() &#x2F; SKAction.run &#x2F; SKAction.wait &#x2F; SKScene.run效果图: 1234567891011121314151617// var skyColor = SKColor(red: 81.0/255.0, green: 192.0/255.0, blue: 201.0/255.0, alpha: 1.0)// self.backgroundColor = skyColor// 当系统检测到特定碰撞时,即调用该bgFlash方法:func bgFlash() &#123; let bgFlash = SKAction.run (&#123; self.backgroundColor = SKColor(red: 1, green: 0, blue: 0, alpha: 1.0) &#125;) let bgNormal = SKAction.run (&#123; self.backgroundColor = self.skyColor &#125;) let bgFlashAndNormal = SKAction.sequence([bgFlash, SKAction.wait(forDuration: TimeInterval(0.05)), bgNormal, SKAction.wait(forDuration: TimeInterval(0.05))]) self.run(SKAction.sequence([SKAction.repeat(bgFlashAndNormal, count: 4)]), withKey: &quot;flash&quot;) // 加了下面这行代码就没了效果,感觉是异步的原因, // 上一行代码还没执行完,下一行就开始执行了,所以无效了。 // self.removeAction(forKey: &quot;flash&quot;)&#125; “Game Over” 字样从天而降 的案例使用到SKScene的默认Bool属性isUserInteractionEnabled,值为true。 以下例子是在游戏结束的瞬间:1、玩家不能点击屏幕;2、Game Over 字样从天而降;3、玩家此时才能点击屏幕得到响应。 12345678910111213141516//lazy var gameOverLabel: SKLabelNode = &#123;// let label = SKLabelNode(fontNamed: &quot;Chalkduster&quot;)// label.text = &quot;Game Over&quot;// return label//&#125;()// SKScene的默认属性isUserInteractionEnabled为true,此时用户是可以随便点击屏幕并有响应的isUserInteractionEnabled = falseaddChild(gameOverLabel)gameOverLabel.position = CGPoint(x: self.size.width * 0.5, y: self.size.height)let delay = SKAction.wait(forDuration: TimeInterval(1))let move = SKAction.move(by: CGVector(dx: 0, dy: -self.size.height * 0.5), duration: 1)gameOverLabel.run(SKAction.sequence([delay, move]), completion: &#123; self.isUserInteractionEnabled = true&#125;) SKAction.playSoundFileNamed()SKAction.playSoundFileNamed()是在SKAction中用来播放声音的。 The three main sound file formats you’ll use are MP3, M4A and CAF, with the latter being a renamed AIFF file. AIFF is a pretty terrible file format when it comes to file size, but it’s much faster to load and use than MP3s and M4As, so you’ll use them often. 1run(SKAction.playSoundFileNamed(&quot;whackBad.caf&quot;, waitForCompletion: false)) 这里是直接run,其实是因为func是在GameScene中,所以可以直接用run。而若你是在其他SKNode中,个人认为是可以使用SKNode.run()的。注意:这里的run不同于SKAction.run(block:) SKaction.follow(&lt;#T##CGPath#&gt;, asOffset: &lt;#T##Bool#&gt;, orientToPath: &lt;#T##Bool#&gt;, speed: &lt;#T##CGFloat#&gt;)意思是action是跟随者着CGPath的路径进行。 1234567let path = UIBezierPath()path.move(to: .zero)path.addLine(to: CGPoint(x: xMovement, y: 1000))// orientToPath 的意思是跟着路径一起旋转角度。let move = SKAction.follow(path.cgPath, asOffset: true, orientToPath: true, speed: 200)node.run(move) 给这个node设置了一个SKAction,这个SKAction是跟随这贝塞尔曲线(但上面确实直线,应该是跟上面的path有关系)运动。 The follow() method takes three other parameters, all of which are useful. The first decides whether the path coordinates are absolute or are relative to the node’s current position. If you specify asOffset as true, it means any coordinates in your path are adjusted to take into account the node’s position.The third parameter to follow() is orientToPath and makes a complicated task into an easy one. When it’s set to true, the node will automatically rotate itself as it moves on the path so that it’s always facing down the path. Perfect for fireworks, and indeed most things! Finally, you can specify a speed to adjust how fast it moves along the path. SKPhysicsContactDelegateSKPhysicsContactDelegate协议 就类似于针对物理碰撞的处理器,所以一般都是符合SKScene协议的class(比如例子里就是GameScene) 需要另外去遵循的: 1class GameScene: SKScene, SKPhysicsContactDelegate &#123; 此外,在didMove(to:)中我们需要添加的: 123456789override func didMove(to view: SKView) &#123; // 之前这行代码,就是让整个屏幕作为一个物理属性范围 physicsBody = SKPhysicsBody(edgeLoopFrom: frame) // 让这整理屏幕作为一个物理属性范围,那么它的碰撞处理器是什么呢? // 是self,就是 class GameScene: SKScene, SKPhysicsContactDelegate &#123; // 这也是GameScene为什么要遵循SKPhysicsContactDelegate协议的原因 physicsWorld.contactDelegate = self contactTestBitMask &amp;&amp; collisionBitMaskThe collisionBitMask bitmask means “which nodes should I bump into?” By default, it’s set to everything, which is why our ball are already hitting each other and the bouncers. The contactTestBitMask bitmask means “which collisions do you want to know about?” and by default it’s set to nothing. So by setting contactTestBitMask to the value of collisionBitMask we’re saying, “tell me about every collision.” The categoryBitMask property is a number defining the type of object this is for considering collisions. The collisionBitMask property is a number defining what categories of object this node should collide with, The contactTestBitMask property is a number defining which collisions we want to be notified about. 两者的默认设置值是什么?collisionBitMask的默认值是”everything”,contactTestBitMask的默认值是”nothing”。所以,能得出结论是,两者会碰撞,但永远收不到碰撞的相关通知。 所以下面的代码: 1ball.physicsBody!.contactTestBitMask = ball.physicsBody!.collisionBitMask ball.physicsBody!.collisionBitMask代表 球 的所有碰撞情况,前半句ball.physicsBody!.contactTestBitMask的意思是,哪些是需要进行上报的碰撞。整个连起来就是,每个球的所有碰撞都得上报碰撞事件。 下面是一个完整的关于多个物体碰撞的例子: 12345// 设置物理体的标示符 &lt;&lt;左移运算符 左移一位，相当于扩大2倍let birdCategory: UInt32 = 1 &lt;&lt; 0 //1 二进制表示是1let worldCategory: UInt32 = 1 &lt;&lt; 1 //2 二进制表示是10let pipeCategory: UInt32 = 1 &lt;&lt; 2 //4 二进制表示是100let scoreCategory: UInt32 = 1 &lt;&lt; 3 //8 二进制表示是1000 给每个物理体设置physicsBody?.categoryBitMask的标识符: 12345678// 给地面添加一个识别ground.physicsBody?.categoryBitMask = worldCategory// 给鸟添加一个识别bird.physicsBody?.categoryBitMask = birdCategory// 给管道添加一个识别pipe.physicsBody?.categoryBitMask = pipeCategory// 给得分墙添加一个识别contactNode.physicsBody?.categoryBitMask = scoreCategory 给所有对于鸟可能发生的碰撞进行定义: 1234bird.physicsBody?.collisionBitMask = worldCategory | pipeCategory | scoreCategory // 或运算,答案是14, 二进制表示是1110// 上面这行代码可以不写的,因为你不定义collisionBitMask的话,collisionBitMask就代表所有会发生的碰撞。// 但这样把所有可能发生的碰撞全写上,毕竟是笔记,尽量要全一点 给所有对于鸟来说需要上报通知的碰撞进行定义: 1234bird.physicsBody?.contactTestBitMask = worldCategory | pipeCategory | scoreCategory// 把以上三种会碰到的碰撞规定需要上报// 这三种碰撞是所有可能的碰撞,所以代码也可以这样写:// bird.physicsBody?.contactTestBitMask = bird.physicsBody?.collisionBitMask 以上是对鸟可能发生的碰撞以及需要上报通知的定义,你完全可以去定义 地面&#x2F;管道&#x2F;得分墙 的可能发生的碰撞以及需要上报通知的情况,毕竟这里代码参考的文章中就是这么写的。 https://www.jianshu.com/p/bc22ee0f87b4但觉得没必要,你只要定义鸟的collisionBitMask和contactTestBitMask部分就可以了,如果遇到更复杂的情况,倒是可以对类似 地面&#x2F;管道&#x2F;得分墙 进行细节上的再定义。 所以当碰撞发生的时候就可以去判断: 12345678910111213141516func didBegin(_ contact: SKPhysicsContact) &#123; // 当上报的是scoreCategory,就知道是和得分墙的碰撞,这是就要进行加分等操作了 if contact.bodyA.categoryBitMask == scoreCategory || contact.bodyB.categoryBitMask == scoreCategory &#123; score += 1 scoreLabelNode.text = String(score) scoreLabelNode.run(SKAction.sequence([SKAction.scale(to: 1.5, duration: TimeInterval(0.1)), SKAction.scale(to: 1.0, duration: TimeInterval(0.1))])) &#125; else &#123; // 当不是与得分墙的碰撞的话,就是鸟与管道或者地面的相撞了 // collisionBitMask 设置成 worldCategory,是防止与管道再次发生相撞,让其直接掉到地上, // 若设置为0,因为标识符没有0的,就会发生一种情况, // 那就是小鸟直接往下掉,掉出屏幕！ bird.physicsBody?.collisionBitMask = worldCategory overStatus() bgFlash() &#125;&#125; 但是,这样设置还是出现了问题,问题就是,当鸟撞上了得分墙了以后,它就被堵在了那里不能动了,所以鸟的collisionBitMask和contactTestBitMask都要去除scoreCategory: 12bird.physicsBody?.collisionBitMask = worldCategory | pipeCategorybird.physicsBody?.contactTestBitMask = worldCategory | pipeCategory 但是去除后,就不会有和得分墙的碰撞,也就无法产生得分了。这时候就要在得分墙上动脑筋了: 1contactNode.physicsBody?.contactTestBitMask = birdCategory 对于鸟的碰撞,contactNode需要去通知汇报碰撞情况,而此时因为鸟是被动一方,所以继续畅通无阻地通过这堵得分墙。 对于这个问题,总结一点,就是鸟设置的碰撞排除掉空气墙,而空气墙设置的碰撞要针对鸟,这样就行了。 设置了contactTestBitMask,但没设置collisionBitMask,会发生什么?实际没有操作过,教程中称两者不会有碰撞反应,但两者相交的时候会告知。 contactTestBitMask &#x2F; collisionBitMask &#x2F; categoryBitMask 三个属性的建议定义格式SpriteKit希望我们使用UInt32格式来定义上面三个属性。 一般定义的用例: 1234567enum CollisionTypes: UInt32 &#123; case player = 1 case wall = 2 case star = 4 case vortex = 8 case finish = 16&#125; 定义了上述三个属性,如何使用?直接使用CollisionTypes.player来赋值可以吗?显然不行,因为它的值是player,而非SpriteKit要求的UInt32属性的值1。因此,需要用到CollisionTypes.player.rawValue。 1234567let node = SKSpriteNode(imageNamed: &quot;block&quot;)node.position = positionnode.physicsBody = SKPhysicsBody(rectangleOf: node.size)node.physicsBody?.categoryBitMask = CollisionTypes.wall.rawValuenode.physicsBody?.isDynamic = falseaddChild(node) func didBegin(_ contact: SKPhysicsContact) {这是SKPhysicsContactDelegate默认会有的一个方法。如果发生碰撞并上报事件了,就会调用该方法: 12345678910111213141516171819202122232425262728293031323334353637// 之前要给需要的SKSpriteNode节点取名字,比如// slotBase.name = &quot;good&quot;// slotBase.name = &quot;bad&quot;// ball.name = &quot;ball&quot;// 这里多说一句,可以给节点取名字,也可以给节点的physicsBody?.categoryBitMask添加值,这样更好,// 具体见 physicsBody?.categoryBitMask的讲解。func didBegin(_ contact: SKPhysicsContact) &#123; if contact.bodyA.node?.name == &quot;ball&quot; &#123; collisionBetween(ball: contact.bodyA.node!, object: contact.bodyB.node!) &#125; else if contact.bodyB.node?.name == &quot;ball&quot; &#123; collisionBetween(ball: contact.bodyB.node!, object: contact.bodyA.node!) &#125;&#125;func collisionBetween(ball: SKNode, object: SKNode) &#123; if object.name == &quot;good&quot; &#123; destroy(ball: ball) score += 1 &#125; else if object.name == &quot;bad&quot; &#123; destroy(ball: ball) score -= 1 &#125;&#125;func destroy(ball: SKNode) &#123; print(&quot;here&quot;) if let fireParticles = SKEmitterNode(fileNamed: &quot;FireParticles&quot;) &#123; fireParticles.position = ball.position addChild(fireParticles) &#125; let a = SKEmitterNode(fileNamed: &quot;FireParticles&quot;) // SKSpriteNode节点的移除一定要从Parent处移除 ball.removeFromParent()&#125; SKLabelNodeThe SKLabelNode class is somewhat similar to UILabel in that it has a text property, a font, a position, an alignment, and so on. 1234567// 创建一个SKLabelNode,字体使用&quot;粉笔灰&quot;scoreLabel = SKLabelNode(fontNamed: &quot;Chalkduster&quot;)// SKLabelNode的内容scoreLabel.text = &quot;Score: 0&quot;scoreLabel.horizontalAlignmentMode = .rightscoreLabel.position = CGPoint(x: 980, y: 700)addChild(scoreLabel) open func nodes(at p: CGPoint) -&gt; [SKNode]这方法是SKNode协议下的一个内置方法,作用是反馈在这个location的所有SKNode节点 1234567891011override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; if let touch = touches.first &#123; let location = touch.location(in: self) let objects = nodes(at: location) if objects.contains(editLabel) &#123; &#125; else &#123; &#125; 12345678910override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; guard let touch = touches.first else &#123; return &#125; var location = touch.location(in: self) for node in nodes(at: location) &#123; if node.name == &quot;player&quot; &#123; &#125; &#125;&#125; SKEmitterNode https://www.hackingwithswift.com/read/11/7/special-effects-skemitternode SpriteKit has a built-in particle editor to help you create effects like fire, snow, rain and smoke almost entirely through a graphical editor. The SKEmitterNode class is new and powerful: it’s designed to create high-performance particle effects in SpriteKit games, and all you need to do is provide it with the filename of the particles you designed and it will do the rest. SKEmitterNode(fileNamed:)的用例123456789func destroy(ball: SKNode) &#123; // 加载FireParticles.sks文件 if let fireParticles = SKEmitterNode(fileNamed: &quot;FireParticles&quot;) &#123; fireParticles.position = ball.position addChild(fireParticles) &#125; ball.removeFromParent()&#125; 就会有在ball被清除前,先出现一个爆炸的动画。在xCode中你可以点击该FireParticles.sks文件,就可以看见右侧面板上有标题叫”SpriteKit Particle Emitter”,可以在里面更改动画效果等。 SKEmitterNode的advanceSimulationTime(sec: TimeInterval)让SKEmitterNode提前多少秒渲染。 用例: 12starField = SKEmitterNode(fileNamed: &quot;starfield&quot;)!starField.position = CGPoint(x: 1024, y: 384) 效果是这样的:你会发现星空是从右边屏幕开始慢慢渲染的,但我们需要星空一开始就充满屏幕,这时候就需要用到SKEmitterNode的advanceSimulationTime(sec: TimeInterval)。 12// 提前渲染10秒的星空starField.advanceSimulationTime(10) 效果是这样的: .sks文件的制作还没涉及到.sks文件的制作,上例中,文件制作完预览是这样的: 文章中提了一笔如何创建该sks文件:Add a new file, but this time choose “Resource” under the iOS heading, then choose “SpriteKit Particle File” to see the list of options. 后续需要研究下怎么制作………………………. SKNodeSKNode doesn’t draw images like sprites or hold text like labels; it just sits in our scene at a position, holding other nodes as children.SKSpriteNode, SKLabelNode and SKEmitterNode, and they all come from SKNode. 1234567891011121314151617class WhackSlot: SKNode &#123; // 这里没有写init()方法,但可以有 // configure方法是自己写的,并不是本身固有的方法 func configure(at position: CGPoint) &#123; // 确定SKNode在什么位置 self.position = position // 确定这个SKNode显示什么图片 let sprite = SKSpriteNode(imageNamed: &quot;whackHole&quot;) addChild(sprite) // 还可以加入SKCropNode让这里有个遮罩之类 // 再给SKCropNode加入一个SKSpriteNode(imageNamed:)之类的 // 再实现其的动画效果 // 具体实现见https://www.hackingwithswift.com/read/14/2/getting-up-and-running-skcropnode &#125;&#125; SKNode.removeAllChildren()移除SKNode中的所有子节点。 123// var pipes: SKNode!pipes.removeAllChildren() SKNode.children – 获取所有节点children可以获取到所有的节点,它的定义是: [SKNode]。下面是获取到所有节点,并始终刷新,判断节点的x坐标在屏幕左侧-300的位置时,即将其删除的例子: 1234567override func update(_ currentTime: TimeInterval) &#123; for node in children &#123; if node.position.x &lt; -300 &#123; node.removeFromParent() &#125; &#125;&#125; isUserInteractionEnabled 属性 – 是否让用户点击交互一个SKNode,如果只是做背景之类不需要用户点击进行交互的话,就可以: 123// skNode: SKNodeskNode.isUserInteractionEnabled = false SKCropNodeSKCropNode is a special kind of SKNode subclass that uses an image as a cropping mask: anything in the colored part will be visible, anything in the transparent part will be invisible.SKCropNode是SKNode的子类。SKCropNode.maskNode得是个SKSpriteNode。SKCropNode.maskNode的作用就是:在SKCropNode.maskNode范围内,这是前提,SKCropNode这个node中的texture(素材),必须是要出现在maskNode范围内的才会显示。 示例: 123456789101112131415161718192021222324class WhackSlot: SKNode &#123; func configure(at position: CGPoint) &#123; self.position = position let sprite = SKSpriteNode(imageNamed: &quot;whackHole&quot;) addChild(sprite) let cropNode = SKCropNode() cropNode.position = CGPoint(x: 0, y: 15) // 把cropNode放在其他node之上 cropNode.zPosition = 1 // 若设置成cropNode.maskNode = nil 则charNode就会显示出来 cropNode.maskNode = SKSpriteNode(imageNamed: &quot;whackMask&quot;) charNode = SKSpriteNode(imageNamed: &quot;penguinGood&quot;) charNode.position = CGPoint(x: 0, y: -90) charNode.name = &quot;character&quot; cropNode.addChild(charNode) addChild(cropNode) &#125;&#125; 解释下代码:cropNode的位置在(0,15), cropNode.maskNode 是一张图片,可以理解成是cropNode的背景图,但实施其是一个人mask,在mask内的显示,不在的不显示。charNode的位置在(0,-90),它在 cropNode.maskNode 的下面,所以不显示这个charNode。后续会有代码让charNode往上升,就能看到了,不过这是后话。 I hope you noticed the important thing, which is that the character node is added to the crop node, and the crop node was added to the slot. This is because the crop node only crops nodes that are inside it, so we need to have a clear hierarchy: the slot has the hole and crop node as children, and the crop node has the character node as a child. AnchorPoint在SpriteKit的游戏开发中经常会使用到AnchorPoint锚点这一属性,这需要配合position属性一起使用。在SpriteKit中(0,0)这个点是在左下角,但UIKit中是左上角。锚点的类型是CGPoint类型数据,取值范围是(0,0)~(1,1)之间,如下图:。 我们以(0,0)为左上角来讲解:View的position为(50,50):1、 若AnchorPoint为(0.5,0.5), 就说明锚点取的是View的中心点, 则View的中心点位置是(50,50), 如下图:2、若AnchorPoint为(0,0),就说明锚点取的是View的左上角,则View的左上角位置是(50,50),如下图:3、若AnchorPoint为(1,1),就说明锚点取的是View的右下角,则View的右下角位置是(50,50),如下图: UIViewController 与 GameScene 的关系 https://www.hackingwithswift.com/read/29/3/mixing-uikit-and-spritekit-uislider-and-skview 默认建立game后,会有GameScene.swift和GameViewController.swift这两个文件,要解释一下的是,GameViewController.swift中的UIViewController,掌管着GameScene.swift中的GameScene。 我们一般采用的方式是,让两者互相通信,即可互相引用,但有一个强弱关系,GameViewController中的属性指向GameScene是一个强引用,而GameScene中的属性指向GameViewController的是一个弱引用,防止内存占用崩溃的情况。比如这样: 1234567891011121314151617181920212223242526272829303132// GameScene.swiftclass GameScene: SKScene &#123; weak var viewController: GameViewController!&#125;// GameViewController.swiftclass GameViewController: UIViewController &#123; var currentGame: GameScene! override func viewDidLoad() &#123; super.viewDidLoad() if let view = self.view as! SKView? &#123; if let scene = SKScene(fileNamed: &quot;GameScene&quot;) &#123; scene.scaleMode = .aspectFill view.presentScene(scene) // 注意:主要是下面这两行来进行引用 currentGame = scene as? GameScene currentGame.viewController = self &#125; view.ignoresSiblingOrder = true view.showsFPS = true view.showsNodeCount = true &#125; &#125;&#125; 这样设置后,两者就可以正常通信了。 UIViewController的默认方法override func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?) { } 检测设备的 晃动&#x2F;shake&#x2F;摇晃 效果motionBegan()只能在view controller中设置,而不能在game scenes中设置。下面是在GameViewController.swift的UIViewController中建立一个方法,来调用GameScene.swift中的explodeFireworks方法: 12345678910111213class GameViewController: UIViewController &#123; // 省略必须的代码 override func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; // 感觉这行代码是检测主体的view是否是一个SKView guard let skView = view as? SKView else &#123; return &#125; // 感觉这行代码是检测SKView的scene是否是GameScene guard let gameScene = skView.scene as? GameScene else &#123; return &#125; // 如果上面检测都成立,就运行GameScene.swift文件中的GameScene类中的explodeFireworks方法。 gameScene.explodeFireworks() &#125;&#125; 注:在模拟器中使用”ctrl”+”cmd”+”z”来模拟设备的晃动效果。 如何在游戏中新生成GameScene,以及在此过程中与GameViewController.swift之间的联系在游戏中,比如玩家输掉的情况下,需要重新生成GameScene的场景,如果去做呢?因为GameScene是由GameViewController来控制生成的,所以最终还是由后者来决定。结合上面讲到的GameScene与GameViewController互相之间强弱引用自见的关系,具体见UIViewController 与 GameScene 的关系。简单代码如下: 1234567891011121314// 以下代码在GameScene中运行// 先生成新的游戏场景let newGame = GameScene(size: self.size)// SKTransition.crossFade 可以让一个scene过渡到另一个scene,// 我的理解就是通过慢慢让一个scene消失,再让另一个scene出现.let transition = SKTransition.crossFade(withDuration: 2)// 例子中使用的是SKTransition.doorway(withDuration:)的方法,// 查了下说明,说是像一个打开的大门一样让scene消失掉.// 这时候需要使用到UIViewController了,其的view?.presentScene的作用就是,// 传递一个新的scene,并让这个过滤通过你定义的transition来展现。self.view?.presentScene(newGame, transition: transition) 在spriteKit中使用UIGraphicsImageRenderer生成图像的注意点先看例子: 1234567891011121314151617181920212223242526272829class GameScene: SKScene &#123; var spriteKitNode: SKSpriteNode! override func didMove(to view: SKView) &#123; let renderer = UIGraphicsImageRenderer(size: CGSize(width: 200, height: 200)) let img = renderer.image &#123; ctx in UIColor.red.setFill() let rect = CGRect(x: 0, y: 0, width: 200, height: 200) ctx.cgContext.addRect(rect) ctx.cgContext.drawPath(using: .fill) UIColor.systemBrown.setFill() let rect2 = CGRect(x: 0, y: 0, width: 100, height: 100) ctx.cgContext.addEllipse(in: rect2) ctx.cgContext.drawPath(using: .fill) UIColor.systemGreen.setFill() let rect3 = CGRect(x: 100, y: 100, width: 100, height: 100) ctx.cgContext.addRect(rect3) ctx.cgContext.drawPath(using: .fill) &#125; spriteKitNode = SKSpriteNode(texture: SKTexture(image: img)) spriteKitNode.position = CGPoint(x: 100, y: 100) addChild(spriteKitNode) &#125;&#125; 在手机中生成的图像是这样的: 总结: SpriteKit中的坐标是以左下角为(0,0),而UIGraphicsImageRenderer是以左上角为(0,0)的; SpriteKit中的图形的坐标都是以图形的中心点为准的,比如上面的整个图形的坐标是(100,100),所以整个图形是生成在屏幕的左下脚,而在UIGraphicsImageRenderer中制作图形时,图形的左上角才是(0,0),比如大红正方形的坐标是(0,0),圆形的坐标也是(0,0),绿色小正方形的坐标是(100,100)。 两者使用不同的图形原点,所以在制图时要考虑到你是在哪个里面,是还在UIGraphicsImageRenderer中作画呢,还是已经跳出到SpriteKit中开始生成图形了。 ctx.cgContent.setBlendMode() 方法 – 展现炸掉上层图像的效果基于上面一样的例子,这里背景色设定为白色,先看效果图: 1234567891011121314151617// 其他代码一样 UIColor.systemBrown.setFill() let rect2 = CGRect(x: 0, y: 0, width: 100, height: 100) ctx.cgContext.addEllipse(in: rect2) ctx.cgContext.setBlendMode(.clear) ctx.cgContext.drawPath(using: .fill) UIColor.systemGreen.setFill() let rect3 = CGRect(x: 100, y: 100, width: 100, height: 100) ctx.cgContext.addRect(rect3) ctx.cgContext.setBlendMode(.color) ctx.cgContext.drawPath(using: .fill)// 一旦设置了ctx.cgContext.setBlendMode(.clear),下面的图像生成都是这个模式,// 所以后面还要ctx.cgContext.setBlendMode(.color)再切回来。 SKTransitionSKTransition的定义是A transition style from one scene to another. SKTransition.crossFade 与 SKTransition.doorway都是让scene消失掉的过渡过程,例子具体见如何在游戏中新生成GameScene,以及在此过程中与GameViewController.swift之间的联系这一节。 NSCoding https://www.hackingwithswift.com/read/12/3/fixing-project-10-nscoding 一般都推荐使用Codable了,所以这里就不写关于NSCoding的笔记了。 UISlider如何取得滑动值123456// 在storyboard上建立一个slider@IBOutlet var intensity: UISlider!// 如何取得UISlider的滑动数值// 使用intensity.value即可intensity.value 如何跟踪滑动值的改变12345// 在storyboard上建立对应该Slider的action事件// 每次滑动Slider都会触发该方法@IBAction func intensityChanged(_ sender: Any) &#123;&#125; 还有跟踪值变化的方法,就是下面对valueChanged改变的响应事件的方法。 UISlider的基本属性12345678910111213141516// 最小值slider.minimumValue = 0.0// 最大值slider.maximumValue = 100.0// 设置默认值slider.setValue(sliderDefalutValue, animated: true)// 滑动条有值部分颜色slider.minimumTrackTintColor = .orange// 滑动条没有值部分颜色slider.maximumTrackTintColor = .black// 滑块滑动的值变化触发ValueChanged事件 如果设置为滑动停止才触发则设置为falseslider.isContinuous = true// 响应事件slider.addTarget(self, action: #selector(sliderValueChange), for: .valueChanged)// 修改控制器图片 -- 划动的图标改成自定义的图片slider.setThumbImage(UIImage(named: &quot;diamond&quot;), for: .normal) UISlider 与 animation 的配合使用具体见UIViewPropertyAnimator的fractionComplete属性 -- 配合UISlider的使用这一章节的笔记。 CoreImageCore Image is Apple’s high-speed image manipulation tookit. It does only one thing, which is to apply filters to images that manipulate them in various ways. 需要import1import CoreImage CIContextThe first is a Core Image context, which is the Core Image component that handles rendering. We create it here and use it throughout our app, because creating a context is computationally expensive so we don’t want to keep doing it and it’s best to re-use them where possible. 1234var context: CIContext!// viewDidLoad()context = CIContext() 具体的例子见下面的CIFilter的讲解。 CIFilter https://www.hackingwithswift.com/read/13/4/applying-filters-cicontext-cifilter(以上有多种filter的选择,对应值的转换,以及项目实际模拟出来的各种效果,如果需要的时候可以看一下)(也可以在用户导入照片的时候,提供必要的filter让其修改下照片效果等) The second is a Core Image filter, and will store whatever filter the user has activated. This filter will be given various input settings before we ask it to output a result for us to show in the image view. 1234567891011121314151617181920212223242526272829var currentFilter: CIFilter!// viewDidLoad()context = CIContext()// creates an example filter that will apply a sepia tone effect to images.currentFilter = CIFilter(name: &quot;CISepiaTone&quot;)// The CIImage data type is UIImage.let beginImage = CIImage(image: currentImage)// we send the result into the current Core Image Filter using the kCIInputImageKey. There are lots of Core Image key constants like this; at least this one is somewhat self-explanatory!currentFilter.setValue(beginImage, forKey: kCIInputImageKey)// The first line safely reads the output image from our current filter. guard let image = currentFilter.outputImage else &#123; return &#125;// The second line uses the value of our intensity slider to set the kCIInputIntensityKey value of our current Core Image filter. For sepia toning a value of 0 means &quot;no effect&quot; and 1 means &quot;fully sepia.&quot;// var intensity: UISlider!currentFilter.setValue(intensity.value, forKey: kCIInputIntensityKey)// 下面的 if 语句中的代码,我们也可以总结出:// 要想从CIImage -&gt; UIImage, 必须是:// CIImage -&gt; CGImage -&gt; UIImage.// -----------------------------------// it creates a new data type called CGImage from the output image of the current filter.if let cgimg = context.createCGImage(image, from: image.extent) &#123; // 转换成UIImageView需要的UIImage let processedImage = UIImage(cgImage: cgimg) // 放入UIImageView imageView.image = processedImage&#125; UIImageWriteToSavedPhotosAlbum()向用户的相册写入图片。 12345678910111213141516171819// 假设有一个UIButton的action是下面的func@IBAction func save(_ sender: Any) &#123; guard let image = imageView.image else &#123; return &#125; UIImageWriteToSavedPhotosAlbum(image, self, #selector(image(_:didFinishSavingWithError:contextInfo:)), nil)&#125;@objc func image(_ image: UIImage, didFinishSavingWithError error: Error?, contextInfo: UnsafeRawPointer) &#123; if let error = error &#123; // we got back an error! let ac = UIAlertController(title: &quot;Save error&quot;, message: error.localizedDescription, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) present(ac, animated: true) &#125; else &#123; let ac = UIAlertController(title: &quot;Saved!&quot;, message: &quot;Your altered image has been saved to your photos.&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) present(ac, animated: true) &#125;&#125; UIView.animate一般用法: 1UIView.animate(withDuration: &lt;#T##TimeInterval#&gt;, delay: &lt;#T##TimeInterval#&gt;, animations: &lt;#T##() -&gt; Void#&gt;) 更丝滑的用法:(使用到了usingSpringWithDamping &#x2F; initialSpringVelocity,是为了增加润滑度的) 1UIView.animate(withDuration: &lt;#T##TimeInterval#&gt;, delay: &lt;#T##TimeInterval#&gt;, usingSpringWithDamping: &lt;#T##CGFloat#&gt;, initialSpringVelocity: &lt;#T##CGFloat#&gt;, animations: &lt;#T##() -&gt; Void#&gt;) 案例: 123456789101112UIView.animate(withDuration: 1, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 5, options: [], animations: &#123; self.imageView.alpha = 0.1 self.imageView.backgroundColor = UIColor.green // 后续可以设置案件让其还原 // 比如 // self.imageView.alpha = 1.0 // self.imageView.backgroundColor = UIColor.clear // 这里补充一点 UIColor.clear 的定义 // open class var clear: UIColor &#123; get &#125; // 0.0 white, 0.0 alpha // 所以上面代码会让背景色变白并且透明度为0即不可见&#125; UIView.animate 的 completed 的trailing closure参数下面的代码可以在animate的动画结束之后再执行一段代码。 1234567891011UIView.animate(withDuration: 1, delay: 0, options: [], animations: &#123; switch self.currentAnimation &#123; case 0: break default: break &#125;&#125;) &#123; finished in sender.isHidden = false&#125; UIView.animate 的思考上面代码中,在UIView.animate中变化的是self.imageView.alpha。同样的情景,但换做是一个UIButton,”_ sender: UIButton”是其传来的参数,你使用sender.isHidden &#x3D; true, 是不会有过渡变化的,而你使用sender.alpha &#x3D; 0,就会带来过渡的变化。后者很好理解,因为alpha的取值是从0-1.0之前,但为什么sender.isHidden从false到true,也是让图像从有到无,为何就没有用呢? (还记得在SwfitUI中,withAnimation中好像是可以放入true或false的改变的,也会有动画效果的)教程中是这么讲的,”because isHidden is either true or false, it has no animatable values between.”上面代码还用到了backgroundColor,是不是颜色从一种到另一种,其中是带有值的过渡的,所以也是可行的。 使用需要是weak等去除强引用？没必要！For the animations closure we don’t need to use [weak self] because there’s no risk of strong reference cycles here – the closures passed to animate(withDuration:) method will be used once then thrown away. UIViewPropertyAnimator – 类似于withAnimation不同于UIView.animate,因为感觉它只能针对这个UIView,而UIViewPropertyAnimator使用方式类似于withAnimation。看一下例子: 1234567891011let redBox = UIView(frame: CGRect(x: -64, y: 0, width: 128, height: 128))redBox.translatesAutoresizingMaskIntoConstraints = falseredBox.backgroundColor = UIColor.redredBox.center.y = view.center.yview.addSubview(redBox)animator = UIViewPropertyAnimator(duration: 2, curve: .easeInOut) &#123; [unowned self, redBox] in redBox.center.x = self.view.frame.width&#125;animator.startAnimation() UIViewPropertyAnimator的addCompletion方法再增加点特效,存在过去和回来以及旋转的效果: 1234567891011121314151617181920let redBox = UIView(frame: CGRect(x: -64, y: 0, width: 128, height: 128))redBox.translatesAutoresizingMaskIntoConstraints = falseredBox.backgroundColor = UIColor.redredBox.center.y = view.center.yview.addSubview(redBox)animator = UIViewPropertyAnimator(duration: 2, curve: .easeInOut) &#123; [unowned self, redBox] in redBox.center.x = self.view.frame.width redBox.transform = CGAffineTransform(rotationAngle: CGFloat.pi).scaledBy(x: 0.001, y: 0.001)&#125;animator.addCompletion &#123; _ in let secondAnimator = UIViewPropertyAnimator(duration: 2, curve: .easeInOut) &#123; redBox.center.x = 0 redBox.transform = CGAffineTransform(rotationAngle: CGFloat.pi * 2).scaledBy(x: 1.0, y: 1.0) &#125; secondAnimator.startAnimation()&#125;animator.startAnimation() UIViewPropertyAnimator的fractionComplete属性 – 配合UISlider的使用UIViewPropertyAnimator的ffractionComplete属性是个CGFloat。我们来使用UISlider来决定该动画的完成度(个人理解): 1234567891011121314151617181920212223242526272829// 定义一个UISliderlet slider = UISlider()slider.translatesAutoresizingMaskIntoConstraints = falseview.addSubview(slider)slider.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -400).isActive = trueslider.widthAnchor.constraint(equalTo: view.widthAnchor).isActive = true// 定义该UISlider对应的划动事件slider.addTarget(self, action: #selector(sliderChanged), for: .valueChanged)// 定义一个boxlet redBox = UIView(frame: CGRect(x: -64, y: 0, width: 128, height: 128))redBox.translatesAutoresizingMaskIntoConstraints = falseredBox.backgroundColor = UIColor.redredBox.center.y = view.center.yview.addSubview(redBox)// 使用UIViewPropertyAnimator来定义动画animator = UIViewPropertyAnimator(duration: 2, curve: .easeInOut) &#123; [unowned self, redBox] in redBox.center.x = self.view.frame.width redBox.transform = CGAffineTransform(rotationAngle: CGFloat.pi).scaledBy(x: 0.001, y: 0.001)&#125;// 以及该对应划动事件的具体执行方法@objc func sliderChanged(_ sender: UISlider) &#123; animator.fractionComplete = CGFloat(sender.value)&#125; 当滑动UISlider的时候会出现的效果: UIViewPropertyAnimator的stopAnimation(withoutFinishing: Bool)方法即中止动画。 实例–点击卡牌后产生翻转动画的效果 12345678910111213141516171819202122232425262728293031class ViewController: UIViewController &#123; @IBOutlet var imageView: UIImageView! var flipAnimator: UIViewPropertyAnimator? override func viewDidLoad() &#123; super.viewDidLoad() imageView.image = UIImage(named: &quot;1Characters_back&quot;) view.addSubview((imageView)) let tapGesture = UITapGestureRecognizer(target: self, action: #selector(imageViewTap)) imageView.isUserInteractionEnabled = true // 允许用户交互 imageView.addGestureRecognizer(tapGesture) &#125; @objc func imageViewTap(_ sender: UITapGestureRecognizer) &#123; flipAnimator = UIViewPropertyAnimator(duration: 1, curve: .linear) &#123; [unowned self, imageView] in // 这里防止用户反复点击产生反效果,而取消用户交互的功能 self.imageView.isUserInteractionEnabled = false UIView.transition(with: self.imageView, duration: 1, options: [.transitionFlipFromRight]) &#123; self.imageView.image = UIImage(named: &quot;NinjaAdventure&quot;) &#125; // UIView 就是 with参数中设置的self.imageView,而不是view,这点非常重要! &#125; flipAnimator?.startAnimation() &#125;&#125; 这里使用到了UIView.transition功能,具体用法有: UIView.transition(with: UIView, duration: TimeInterval, options: UIView.AnimationOptions,animations: (() -&gt; Void)?)) UIView.transition(from: UIView, to: UIView, duration: Timeinterval) UIView.transition(from: UIView, to: UIView, duration: TimeInterval, options: UIView.AnimationOptions)三种使用的方法,稍有不同。第一种在上例中已经展现。后两种在一些情况下可以使用,因为不能像第一种一样设置with参数,所以不能特别指定是哪个view有动画,只能默认是整个view；如果在UICollectionView中的cell,cell中有一个占据整个篇幅的ImageView,那是可以使用后两种方法的。 CGAffineTransform任何的UIView都可以使用CGAffineTransform。 一般用法案例: 123456789101112UIView.animate(withDuration: 1, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 5, options: [], animations: &#123; switch self.currentAnimation &#123; case 0: self.imageView.transform = CGAffineTransform(scaleX: 2, y: 2) case 1: self.imageView.transform = .identity default: break &#125;&#125; 这里有两个知识点: UIView.transform 可更改外形、大小、角度等; UIView.transform &#x3D; .identity 即可恢复原状。 CGAffineTransform还有的用法: 123456// 位移self.imageView.transform = CGAffineTransform(translationX: -256, y: -256)// 旋转self.imageView.transform = CGAffineTransform(rotationAngle: CGFloat.pi * 3.0 / 2.0)// 但要记住,它比较懒,怎么能最快到终点,就会选这个捷径,实际这个只逆时针转了90度 CGAffineTransform.identityCGAffineTransform也有identity,作用是恢复到transform之前的状态。 MapKitMKMapView及其的delegate在一个UIView中建立了一个MKMapView后,需要让UIView作为这个MKMapView的delegate的话,需要在storyboard中ctrl-drag这个MKMapView到UIView上面,就会出现让你选择delegate的情况,选择好了以后就可以了。 原文是这样写的:Using the assistant editor, please create an outlet for your map view called mapView. You should also set your view controller to be the delegate of the map view by Ctrl-dragging from the map view to the orange and white view controller button just above the layout area. You will also need to add import MapKit to ViewController.swift so it understands what MKMapView is.Note: If you don’t set the map’s delegate, the rest of this project won’t work too well. MKMapView的用例:在storyboard上生成一个map kit view。 mapType 更改显示地图的样式1234// @IBOutlet var mapView: MKMapView!// 显示卫星地图,还有其他的一些选择mapView.mapType = .satellite MKAnnotation – protocol在地图上显示图钉。遵循MKAnnotation协议的必须是class,不能是struct！！！遵循MKAnnotation协议的情况下,必须要有一个coordinate: CLLocationCoordinate2D的声明,如下: 123456789101112class Capital: NSObject, MKAnnotation &#123; var title: String? // 需要实现一个CLLocationCoordinate2D var coordinate: CLLocationCoordinate2D var info: String init(title: String, coordinate: CLLocationCoordinate2D, info: String) &#123; self.title = title self.coordinate = coordinate self.info = info &#125;&#125; 在viewDidLoad()中可以生成这个annotation: 12let london = Capital(title: &quot;London&quot;, coordinate: CLLocationCoordinate2D(latitude: 51.507222, longitude: -0.1275), info: &quot;Home to the 2012 Summer Olympics.&quot;)let oslo = Capital(title: &quot;Oslo&quot;, coordinate: CLLocationCoordinate2D(latitude: 59.95, longitude: 10.75), info: &quot;Founded over a thousand years ago.&quot;) 随后在地图上显示这些annotation: 12345678910// @IBOutlet var mapView: MKMapView!// 一起添加:// mapView.addAnnotations(&lt;#T##annotations: [MKAnnotation]##[MKAnnotation]#&gt;)mapView.addAnnotations([london, oslo])// 或者一个一个添加:// mapView.addAnnotation(&lt;#T##annotation: MKAnnotation##MKAnnotation#&gt;)mapView.addAnnotation(london)mapView.addAnnotation(oslo) func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? { https://www.hackingwithswift.com/read/16/3/annotations-and-accessory-views-mkpinannotationview Every time the map needs to show an annotation, it calls a viewFor method on its delegate. We don’t implement that method right now, so the default red pin is used with nothing special. 但首先要让View遵循 MKPinAnnotationView protocol : 1class ViewController: UIViewController, MKMapViewDelegate &#123; 接下来就是完成func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? { 1234567891011121314151617181920212223242526func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? &#123; // 1.If the annotation isn&#x27;t from a capital city, it must return nil so iOS uses a default view. guard annotation is Capital else &#123; return nil &#125; // 2.Define a reuse identifier. This is a string that will be used to ensure we reuse annotation views as much as possible. let identifier = &quot;Capital&quot; // 3.Try to dequeue an annotation view from the map view&#x27;s pool of unused views. var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: identifier) if annotationView == nil &#123; // 4.If it isn&#x27;t able to find a reusable view, create a new one using (MKPinAnnotationView is deprecated) and sets its canShowCallout property to true. This triggers the popup with the city name. annotationView = MKMarkerAnnotationView(annotation: annotation, reuseIdentifier: identifier) annotationView?.canShowCallout = true // 5. Create a new UIButton using the built-in .detailDisclosure type. This is a small blue &quot;i&quot; symbol with a circle around it. // we don&#x27;t need to use addTarget() to add an action to the button, because you&#x27;ll automatically be told by the map view using a calloutAccessoryControlTapped method. let btn = UIButton(type: .detailDisclosure) annotationView?.rightCalloutAccessoryView = btn &#125; else &#123; // 6. If it can reuse a view, update that view to use a different annotation. annotationView?.annotation = annotation &#125; return annotationView&#125; 接下来就是每个annotation被点击后实现方法了: 12345678910// calloutAccessoryControlTapped method can make the tapped button know to call it.func mapView(_ mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) &#123; guard let capital = view.annotation as? Capital else &#123; return &#125; let placeName = capital.title let placeInfo = capital.info let ac = UIAlertController(title: placeName, message: placeInfo, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) present(ac, animated: true)&#125; 实现效果是这样的: TimerTimer.scheduledTimer(timeInterval: &lt;#T##TimeInterval#&gt;, target: &lt;#T##Any#&gt;, selector: &lt;#T##Selector#&gt;, userInfo: &lt;#T##Any?#&gt;, repeats: &lt;#T##Bool#&gt;)多少个时间单位内(timeInterval), 执行什么代码(selector), 是否重复执行(repeats)。After creating a Timer, it should be created using Timer.scheduledTimer() method to activate it. 1Timer.scheduledTimer(timeInterval: 0.35, target: self, selector: #selector(createEnemy), userInfo: nil, repeats: true) invalidate() – Timer.scheduledTimer的停止让一个计时器停止: 123456// var gameTimer: Timer?// gameTimer = Timer.scheduledTimer(timeInterval: 0.35, target: self, selector: #selector(createEnemy), userInfo: nil, repeats: true)gameTimer?.invalidate()gameTimer = nil debugprint12345678910print(&quot;I&#x27;m inside the viewDidLoad() method!&quot;)print(1, 2, 3, 4, 5)// &quot;1 2 3 4 5\\n&quot;print(1, 2, 3, 4, 5, separator: &quot;-&quot;)// &quot;1-2-3-4-5\\n&quot;print(&quot;Some message&quot;, terminator: &quot;&quot;)// &quot;Some message&quot; assert一般用法两个参数,前面的条件不满足或是false,则显示预设的错误信息,并让测试时的程序崩溃。 1assert(1 == 1, &quot;Maths failure!&quot;) breakpoints Fn+F6 – 到breakpoint处时,一行一行地执行 Ctrl+Cmd+Y – 执行到下一个breakpoint 给Breakpoint加上条件例如在循环中每十次进行一次breakpoint:对着设定的breakpoint右键,跳出菜单中选择”edit breakpoint”,再跳出的菜单:在Condition中输入”i % 10 &#x3D;&#x3D; 0”即可。 Exception BreakpointException Breakpoint will be automatically triggered when an exception is thrown. Exceptions are errors that aren’t handled, and will cause your code to crash. With breakpoints, you can say “pause execution as soon as an exception is thrown,” so that you can examine your program state and see what the problem is. Cmd+8 调出“Show the Breakpoint navigator”,左下角按”+”按钮,调出如下菜单,选择”Exception Breakpoint”:进行必要的设置:The next time your code hits a fatal problem, the exception breakpoint will trigger and you can take action. 下面的图就是当出现错误的情况时,会出现 NSException: lldb窗口LLDB is the default debugger in Xcode on macOS and supports debugging C, Objective-C and C++ on the desktop and iOS devices and simulator. 在运行project时,可以在菜单栏 View &gt; Debug Area &gt; Activate Console, 可以看到下面的lldb窗口: 命令行:p – 同print,比如要打印变量i,”p i”即可。 View Debugging在运行项目后,在代码页面, 菜单栏的 Debug -&gt; View Debugging -&gt; Capture View Hierarchy 。如下图: Here’s the clever part: if you click and drag inside the hierarchy display, you’ll see you’re actually viewing a 3D representation of your view, which means you can look behind the layers to see what else is there. The hierarchy automatically puts some depth between each of its views, so they appear to pop off the canvas as you rotate them. This debug mode is perfect for times when you know you’ve placed your view but for some reason can’t see it – often you’ll find the view is behind something else by accident. 还可以使用下图中打红圈的快捷键打开 View Debugging: CADisplayLink https://www.hackingwithswift.com/example-code/system/how-to-synchronize-code-to-drawing-using-cadisplaylinkhttps://www.jianshu.com/p/5e8d783d377a CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和 selector 在屏幕刷新的时候调用。CADisplayLink比NSTimer好的地方是,后者会有延迟,而CADisplayLink的好处是,我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。 123let displayLink = CADisplayLink(target: self, selector: #selector(createEnemy))displayLink.preferredFrameRateRange = CAFrameRateRange(minimum: 1, maximum: 2)displayLink.add(to: .current, forMode: .common) 代码在Project17上跑的通,但有些疑问,为什么CAFrameRateRange(minimum: 0.5, maximum: 0.5)的时候就会疯狂执行,而数值大于1以后,就会正常一些。 这个模块,以后要做动画游戏的时候需要好好研究一下。笔记待后续补充。 info.plistplist是property list的缩写,它包含了app、插件(extensions)的元数据(metadata),这些是关于:what language is it, what version number is it, and so on。 extensionsafari extensions https://www.hackingwithswift.com/100 Day67-69 p.s.(2023-1-28)这章节的内容实在是太乱了,新东西太多,后续还要再理一下,如果确实要写extension的话,最好结合上述网页上的实例再看。 safari extensions必须要在safari的action menu中才能启动,类似于:这个extension是植入到Safari中的,它需要safari才会有用,而不是像其他程序一样可以独立运行。 生成一个在原有项目下的extension:Go to the File menu and choose New &gt; Target. When you’re asked to choose a template, select iOS &gt; Application Extension &gt; Action Extension, then click Next. For the name just call it Extension(or other name whatever you want), make sure Action Type is set to “Presents User Interface”, then click Finish.这样就在一个project中建立了一个extension,而我们给其取名”Extension”,最后我们在sfari的action menu中可以看到一个Extension的可点击项,上面图像中可以看到。 safari中就可以运行extension,安全性在哪里？实际上,你的extension与safari是不会通信的,因为系统安全原因,而在这其中,iOS起到了一个中间桥梁的作用,iOS在其中安全地传递数据。 extensionContext:母程序(parent app)就比如说你在safari里做了一个插件,那么这个safari就是母程序,插件就是extension。当我们的插件被建立后,extensionContext是用来让我们控制与母程序交互的东西。 inputItems:extensionContext?.inputItems是一个存有数据的数组,该数据是母程序发送给插件使用的。我们一般只关心第一个item,所以会写成extensionContext?.inputItems.first。 NSItemProvider:母程序发送给我们的数据都被包装成了一个个NSItemProvider。我们的程序把所有的数组数据中的第一个取出,而这个被取出的数据应当是一个NSItemProvider。 1if let inputItem = extensionContext?.inputItems.first as? NSExtensionItem &#123; 接下来我们把inputItem中的所有attachments,只取出第一个attachment,代码就是： 1if let itemProvider = inputItem.attachments?.first &#123; 合起来的代码就是: 123456if let inputItem = extensionContext?.inputItems.first as? NSExtensionItem &#123; if let itemProvider = inputItem.attachments?.first &#123; &#125; &#125;&#125; loadItem(forTypeIdentifier: )loadItem(forTypeIdentifier: )是要求数据提供者真正地去提供这个item给我们。因为它使用到了一个trailing closure,所以执行的是异步程序，这个方法会持续执行,这是因为有时候这个item提供者可能忙于载入或者发送数据。在这个trailing closure中,我们需要使用到 [weak self]去避免强引用,此外,我们还需要接受两个参数,第一个是item提供者给我们的一个dictionary,另一个是发生的任何error。 123itemProvider.loadItem(forTypeIdentifier: kUTTypePropertyList as String) &#123;[weak self] (dict, error) in // do stuff!&#125; 先要说一下的是,在Action.js中的代码中有一段: 12345// run及其代码的意思是:// 告知iOS这个JavaScript已经预处理完毕,把这个dictionary(里面的key分别是&quot;URL&quot;和&quot;title&quot;以及对应的值)给extension吧run: function(parameters) &#123; parameters.completionFunction(&#123; &quot;URL&quot;: document.URL, &quot;title&quot;: document.title &#125;);&#125; loadItem的trailing closure接收到这个dictionary并进行处理,这也是其是异步方法的愿意。&#x2F;&#x2F; do stuff中的代码依次是: 1guard let itemDictionary = dict as? NSDictionary else &#123; return &#125; NSDictionary是一个对我们来说是新的数据类型,但它来自旧时代的iOS代码,就把它看作是一个Swift中的dictionary吧。现在更多使用的是modern Swift dictionaries,而非NSDictionary。但这里NSDictionary是与插件配合使用的。打印了一下上面的itemDictionary: 1guard let javaScriptValues = itemDictionary[NSExtensionJavaScriptPreprocessingResultsKey] as? NSDictionary else &#123; return &#125; 这行代码中的key为NSExtensionJavaScriptPreprocessingResultsKey,这是从JavaScript中传递过来的数据的key。 如果你打印上面javaScriptValues的值,你会看到类似: 1234&#123; URL = &quot;https://www.apple.com/retail/code/&quot;; title = &quot;Apple Retail Store - Hour of Code Workshop&quot;;&#125; 接下来就可以设置插件中的这两个后续我们要使用的属性了: 12self?.pageTitle = javaScriptValues[&quot;title&quot;] as? String ?? &quot;&quot;self?.pageURL = javaScriptValues[&quot;URL&quot;] as? String ?? &quot;&quot; 完成代码是: 123456789101112131415if let inputItem = extensionContext?.inputItems.first as? NSExtensionItem &#123; if let itemProvider = inputItem.attachments?.first &#123; itemProvider.loadItem(forTypeIdentifier: kUTTypePropertyList as String) &#123;[weak self] (dict, error) in guard let itemDictionary = dict as? NSDictionary else &#123; return &#125; guard let javaScriptValues = itemDictionary[NSExtensionJavaScriptPreprocessingResultsKey] as? NSDictionary else &#123; return &#125; self?.pageTitle = javaScriptValues[&quot;title&quot;] as? String ?? &quot;&quot; self?.pageURL = javaScriptValues[&quot;URL&quot;] as? String ?? &quot;&quot; DispatchQueue.main.async &#123; self?.title = self?.pageTitle &#125; &#125; &#125;&#125; &#x2F;&#x2F; do stuff中的代码是经过简单编写的,但建议自己去建立一个extension,看一下默认模版中是怎么遍历所有的items和providers,并最终找到第一张图片的。 info.plist内的设置:先看一下设置后的info.plist内部的构成:有一个Information Property List。因为我们这里是一个插件,所以该list里面有一个NSExtension。这个NSExtension里面一般有三样东西:NSExtensionAttributes, NSExtensionMainStoryboard and NSExtensionPointIdentifier.这里我们只关心会改变我们的插件行为的NSExtensionAttributes。我们设置的目的是:一是设置接收的是什么数据,二是设置后期要执行的语言类型及具体文件名。在NSExtensionAttributes下面有一个NSExtensionActivationRule,Type是”String”,值是”TRUEPREDICATE”,把它修改Type为Dictionary,在里面“+”一个item,名字为”NSExtensionActivationSupportsWebPageWithMaxCount”,Type为String,值设为1。把这个值加到新设的Dictionary里面,是因为我们只想要收到网页数据(web pages),而对images或其他数据类型不感兴趣。接下来选择NSExtensionAttributes,在里面添加名为”NSExtensionJavaScriptPreprocessingFile”,Type为”String”,值为”Action”。这样设置,就是当插件被called的时候,我们需要运行JavaScript的预处理文件,文件名为Action.js。这样需要注意,这里你设置的值是”Action”而不是”Action.js”,因为iOS会帮我们把.js加上去的。 既然在info.plist中已经设置了要执行的”Action.js”文件,那么我们就要创建它:Right-click on your extension’s Info.plist file and choose New File. When you’re asked what template you want, choose iOS &gt; Other &gt; Empty, then name it Action.js, and put this text into it: 123456789101112131415161718var Action = function() &#123;&#125;;Action.prototype = &#123;// run及其代码的意思是:// 告知iOS这个JavaScript已经预处理完毕,把这个dictionary(里面的key分别是&quot;URL&quot;和&quot;title&quot;以及对应的值)给extension吧run: function(parameters) &#123; parameters.completionFunction(&#123; &quot;URL&quot;: document.URL, &quot;title&quot;: document.title &#125;);&#125;,finalize: function(parameters) &#123; var customJavaScript = parameters[&quot;customJavaScript&quot;]; eval(customJavaScript);&#125;&#125;;var ExtensionPreprocessingJS = new Action There are two functions: run() and finalize(). The first is called before your extension is run, and the other is called after.Apple expects the code to be exactly like this, so you shouldn’t change it other than to fill in the run() and finalize() functions. 设置到这里,我们在Project Navigator中可以看到的extenison是这样的:此外,在Build Phases的Compile Sources和Copy Bundle Resources中,应该是如上图这样,Action.js是在Copy Bundle Resources中,而不是在Compile Sources中。 最终的Action.js是这样的: 12345678910111213141516171819var Action = function() &#123;&#125;Action.prototype = &#123; run: function(parameters) &#123; // tell iOS the JavaScript has finished preprocessing, and give this data dictionary to the extension. // The data that is being sent has the keys &quot;URL&quot; and &quot;title&quot;, with the values being the page URL and page title. parameters.completionFunction(&#123; &quot;URL&quot;: document.URL, &quot;title&quot;: document.title &#125;);&#125;, finalize: function(parameters) &#123; var customJavaScript = parameters[&quot;customJavaScript&quot;]; eval(customJavaScript);&#125; &#125;;var ExtensionPreprocessingJS = new Action 在MainInterface.storyboard上建立一个UITextNode,让其auto layout,随后ctrl+drag让其在ActionViewController上对应属性: 1@IBOutlet var script: UITextView! 在extension界面的右上角加一个执行的按钮:(注意extension界面只有在被调用到插件功能的时候才会启用) 1navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .done, target: self, action: #selector(done)) 此时写下要执行的objc的方法: 123456789101112@objc func done() &#123; let item = NSExtensionItem() // 注意看在Action.js的finalize方法中定义到了 // var customJavaScript = parameters[&quot;customJavaScript&quot;]; let argument: NSDictionary = [&quot;customJavaScript&quot;: script.text] let webDictionary: NSDictionary = [NSExtensionJavaScriptFinalizeArgumentKey: argument] let customJavaScript = NSItemProvider(item: webDictionary, typeIdentifier: kUTTypePropertyList as String) item.attachments = [customJavaScript] // completeRequest(returningItems:)的调用会造成插件被关闭,并返回母程序,而且可以传回母程序任何我们定义的items。 extensionContext?.completeRequest(returningItems: [item])&#125; 可以观察一下:1、之前我们从safari接收到的是一个含有NSExtensionItem元素的列表,而这里extensionContext?.completeRequest(returningItems: [item]),最终传回safari的也是一个含有NSExtensionItem元素的列表。2、我们朝NSDictionary传递的key是NSExtensionJavaScriptFinalizeArgumentKey,对应的是Action.js的finalize方法,而之前我们一开始从safari取得的key是NSExtensionJavaScriptPreprocessingResultsKey,对应的是Action.js的run方法。这样就能说得通了。I realize that seems like far more effort than it ought to be, but it’s really just the reverse of what we are doing inside viewDidLoad(). NotificationCenter在我们的scenes背后,当有”键盘事件”、”应用进入后台”以及一些其他的事件,iOS会持续地向我们发出notification。我们可以对一些特定的notification加入observer进行回应,也可以进行数据的传递。 Fixing the keyboard https://www.hackingwithswift.com/read/19/7/fixing-the-keyboard-notificationcenter iOS上会有一个keyboard的问题:比如我们现在有一个可以输入多行的UITextView:我们可以看出这个UITextView占据屏幕的大小。如果我们执行,并调出键盘来一行行的打字,当打的字即将超过键盘所在的位置的时候,会发生什么事情呢？为什么会发生这样的事情?因为当你调出keyboard的时候,这个textView的可使用面积没有自动去调整,仍旧那么大,就会出现打的字出现下键盘下方并被遮盖的情况。 keyboardWillHideNotification &#x2F; keyboardWillChangeFrameNotification当键盘隐藏不用的时候,系统会发出keyboardWillHideNotification。当键盘隐藏不用、键盘状态发生改变(比如出现,或者屏幕从portrait专程landscape等等),系统都会发出keyboardWillChangeFrameNotification。看上去keyboardWillChangeFrameNotification已经涵盖了keyboardWillHideNotification,但有时候一些奇怪的场景还是需要用到keyboardWillHideNotification的(现在还没有碰到过)。 添加对这两个键盘事件的观察: 123let notificationCenter = NotificationCenter.defaultnotificationCenter.addObserver(self, selector: #selector(adjustForKeyboard), name: UIResponder.keyboardWillHideNotification, object: nil)notificationCenter.addObserver(self, selector: #selector(adjustForKeyboard), name: UIResponder.keyboardWillChangeFrameNotification, object: nil) 对应的adjustForKeyboard方法: 1234567891011121314151617181920// @IBOutlet var textView: UITextView!@objc func adjustForKeyboard(notificaiton: Notification) &#123; guard let keyboardValue = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue else &#123; return &#125; let keyboardScreenEndFrame = keyboardValue.cgRectValue let keyboardViewEndFrame = view.convert(keyboardScreenEndFrame, from: view.window) // 假如keyboard隐藏了,则textView的contentInset正常,即四周不做任何调整 if notification.name == UIResponder.keyboardWillHideNotification &#123; // textView.contentInset可以理解为是textView的padding,感觉不是margin textView.contentInset = .zero &#125; else &#123; // 此时一定是keyboard在使用的情况 textView.contentInset = UIEdgeInsets(top: 0, left: 0, bottom: keyboardViewEndFrame.height - view.safeAreaInsets.bottom, right: 0) // 这里bottom为何是keyboardViewEndFrame.height - view.safeAreaInsets？ // 因为经答应两个数值可以知道,keyboardViewEndFrame.height是从屏幕最下方开始的,包括了view.safeAreaInsets.bottom, // 而我们的textView开始设置的时候是不包含safeArea的,所以要减掉safeArea的范围。 &#125;&#125; 再对scroll indicator进行设置: 123456789101112@objc func adjustForKeyboard() &#123; // 省略上面的代码 /* 下面这三行代码是教程中加上去的,但操作下来感觉没什么用啊 */ // Scroll indicator insets control how big the scroll bars are relative to their view. textView.scrollIndicatorInsets = textView.contentInset // textView.selectedRange应该理解为是可选择或可使用的范围 let selectedRange = textView.selectedRange // 设置textView可滚动的范围 textView.scrollRangeToVisible(selectedRange) NotificationCenter的post的传输自制的提醒12let notificationCenter = NotificationCenter.defaultnotificationCenter.post(name: Notification.Name(&quot;UserLoggedIn&quot;), object: nil) If no other part of your app has subscribed to receive that notification, nothing will happen. But you can make any other objects subscribe to that notification – it could be one thing, or ten things, it doesn’t matter. This is the essence of loose coupling: you’re transmitting the event to everyone, with no direct knowledge of who your receivers are. NotificationCenter的UIApplication.willResignActiveNotification事件当整个程序不再是active状态(即将进入background)之前会发生的事件。 12let notificationCenter = NotificationCenter.defaultnotificationCenter.addObserver(self, selector: #selector(saveSecretMessage), name: UIApplication.willResignActiveNotification, object: nil) UserNotifications – UN看下来,UserNotifications就是在程序中设置好,取得用户授权后,在固定时间点或此后的一段时间后,给用户的手机系统发送提醒信息的一个模块。 If you want to use the UserNotifications framework, you should import it: 1import UserNotifications UNUserNotificationCenter.requestAuthorization – 获取用户授权给用户发送提醒信息的权限,需要用户授权: 1234567891011let center = UNUserNotificationCenter.current()// options表示同意授权的权限包含: 提醒/app上标/声音 这三项// granted是一个Booleancenter.requestAuthorization(options: [.alert, .badge, .sound]) &#123; (granted, error) in if granted &#123; &#125; else &#123; &#125;&#125; 跳出来的是: UNNotificationRequest(identifier:, content:, trigger:)下面的代码设置的是TimeInterval的通知方式(UNTimeIntervalNotificationTrigger),5秒钟后,给系统发送通知信息,告知content中的内容: 12345678910111213141516171819let center = UNUserNotificationCenter.current()// UNNotificationRequest的content部分let content = UNMutableNotificationContent()content.title = &quot;Late wake up call&quot;content.body = &quot;The early bird catches the worm, but the second mouse gets the cheese.&quot;// -- to attach custom actionscontent.categoryIdentifier = &quot;alarm&quot;// -- to attach custom data to the notificationcontent.userInfo = [&quot;customData&quot;: &quot;fizzbuzz&quot;]// -- to specify a soundcontent.sound = UNNotificationSound.default// UNNotificationRequest的trigger部分let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)center.add(request) 也可以设置成Calendar的通知方式,每天10:30发送: (UNCalendarNotificationTrigger) 1234567891011121314151617181920212223242526let center = UNUserNotificationCenter.current()// cancel future scheduled notifications, to start over// 若再次启动的话,需要删除之前悬停着的提醒设定center.removeAllPendingNotificationRequests()let content = UNMutableNotificationContent()content.title = &quot;Late wake up call&quot;content.body = &quot;The early bird catches the worm, but the second mouse gets the cheese.&quot;// content.categoryIdentifier指你可以在notification中加入自定义的action,// 下面会用到的UNNotificationCategory(identifier:, actions: [], intentIdentifiers: [])的identifier必须对应指定是&quot;alarm&quot;content.categoryIdentifier = &quot;alarm&quot;// content.userInfo指你可以在notification中加入自定义的数据,content.userInfo = [&quot;customData&quot;: &quot;fizzbuzz&quot;]content.sound = UNNotificationSound.defaultvar dateComponents = DateComponents()dateComponents.hour = 10dateComponents.minute = 30let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)// 这里的identifier的指定(虽然在这个例子中可有可无),但它可以让你在之后 更新(update) 或 移除(remove) 提醒。// 你也可以通过 center.removeAllPendingNotificationRequests() 来移除 等待的(pending) 的提醒。let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)center.add(request) 你也可以设置一个 地理围栏(geofence),它可以基于你的地理位置来发动(trigger)通知提醒。 五秒钟后发送是这样的: Acting on responses – 根据用户点击选项来采取行动 https://www.hackingwithswift.com/read/21/3/acting-on-responses UNNotificationAction UNNotificationCategory使用UNNotificationAction和UNNotificationCategory,你可以针对跳出的提醒及用户的反应做出进一步的回应。UNNotificationCategory对应的是上面我们设置的content.categoryIdentifier &#x3D; “alarm”。UNNotificationAction设置的是用户选择点击后作出的回应。 123456789101112131415161718192021222324252627282930313233let center = UNUserNotificationCenter.current()// center.delegate = self 就必须让这个self符合UNUserNotificationCenterDelegate协议center.delegate = self// An identifier, which is a unique text string that gets sent to you when the button is tapped.// A title, which is what user’s see in the interface.// Options, which describe any special options that relate to the action. You can choose from .authenticationRequired, .destructive, and .foreground.// .foreground -- The action causes the app to launch in the foreground.// .destructive -- The action causes a destructive task.let show = UNNotificationAction(identifier: &quot;show&quot;, title: &quot;Tell me more...&quot;, options: .foreground)let show2 = UNNotificationAction(identifier: &quot;show2&quot;, title: &quot;Tell me another...&quot;, options: .authenticationRequired)// 此处就必须要对应上面讲到的 content.categoryIdentifier = &quot;alarm&quot;// 此处的intentIdentifiers--this is used to connect your notifications to intents, if you have created any.let category = UNNotificationCategory(identifier: &quot;alarm&quot;, actions: [show, show2], intentIdentifiers: [])center.setNotificationCategories([category])// 下面的代码是上面例子的重复,但要生成notification是必须的,所以就重复写了一遍let content = UNMutableNotificationContent()content.title = &quot;Late wake up call&quot;content.body = &quot;The early bird catches the worm, but the second mouse gets the cheese.&quot;content.categoryIdentifier = &quot;alarm&quot;content.userInfo = [&quot;customData&quot;: &quot;fizzbuzz&quot;]content.sound = UNNotificationSound.defaultvar dateComponents = DateComponents()dateComponents.hour = 10dateComponents.minute = 30let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)center.add(request) 效果是这样的: UNUserNotificationCenter的getNotificationSettings – 查看是否已获得用户的允许发送提醒感觉下面这样写比较好,查看是否获得用户授权发提醒,若未获授权,则请求授权;若已授权,则进一步设置提醒的内容和方式: 1234567891011121314151617181920212223242526272829303132333435363738func manageNotifications() &#123; let notificationCenter = UNUserNotificationCenter.current() notificationCenter.getNotificationSettings &#123; [weak self] (settings) in // user has not made a choice yet regarding accepting notifications if settings.authorizationStatus == .notDetermined &#123; // use this opportunity to explain why it could be useful let ac = UIAlertController(title: &quot;Daily reminder&quot;, message: &quot;Allow notifications to be reminded daily of playing Guess the Flag&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;Next&quot;, style: .default) &#123; _ in self?.requestNotificationsAuthorization() &#125;) self?.present(ac, animated: true) return &#125; // user already has accepted notifications if settings.authorizationStatus == .authorized &#123; self?.scheduleNotifications() &#125; &#125;&#125;func requestNotificationsAuthorization() &#123; let notificationCenter = UNUserNotificationCenter.current() notificationCenter.requestAuthorization(options: [.alert, .badge, .sound]) &#123; [weak self] granted, error in if granted &#123; self?.scheduleNotifications() &#125; else &#123; // explain how notifications can be activated let ac = UIAlertController(title: &quot;Notifications&quot;, message: &quot;Your choice has been saved.\\nShould you change your mind, head to \\&quot;Settings -&gt; Project21-Challenge3 -&gt; Notifications\\&quot; to update your preferences.&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) self?.present(ac, animated: true) &#125; &#125;&#125; didReceive – 处理上面设置的content.userInfo &#x3D; [“customData”: “fizzbuzz”]等传输数据UNUserNotificationCenterDelegate协议定义了userNotificationCenter方法,可以接收一个@escaping,来等待并处理传输的数据:(这不是必须要定义的方法,只是在需要处理传输的数据的时候才有必要) 1userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler 我们可以这样定义该方法: 123456789101112131415161718192021func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) &#123; let userInfo = response.notification.request.content.userInfo if let customData = userInfo[&quot;customData&quot;] as? String &#123; print(&quot;Custom data received: \\(customData)&quot;) switch response.actionIdentifier &#123; case UNNotificationDefaultActionIdentifier: // the user swiped to unlock print(&quot;Default identifier&quot;) case &quot;show&quot;: // 针对我们之前的三行代码: // let show = UNNotificationAction(identifier: &quot;show&quot;, title: &quot;Tell me more...&quot;, options: .foreground) // let category = UNNotificationCategory(identifier: &quot;alarm&quot;, actions: [show], intentIdentifiers: []) // center.setNotificationCategories([category]) print(&quot;Show more information...&quot;) // 你也可以再执行一遍scheduleNotifications()来设置新的提醒 default: break &#125; &#125; 很有趣的是,它只响应center.setNotificationCategories,就是你只有点了”Tell me more…”或者”Tell me another…”按钮才会执行该方法,很奇怪,难道它只针对UNNotificationCategory,为啥？center.setNotificationCategories的参数是[category],而category指向的actions是[show, show2, …],所以它只针对action来回应。 使用AVFoudation模块的AVPlayer播放声音文件在使用SpriteKit模块使用中,为何不使用其本身就有的SKAction.playSoundFileNamed()？而是要去使用AVAudioPlayer(contentsOf: URL)?教材中称是,AVAudioPlayer可以在你需要的时候,随时停止声音的播放。 基本使用方法: 123456if let path = Bundle.main.url(forResource: &quot;sliceBombFuse&quot;, withExtension: &quot;caf&quot;) &#123; if let sound = try? AVAudioPlayer(contentsOf: path) &#123; bombSoundEffect = sound sound.play() &#125;&#125; 你可以使用sound.stop()来停止播放。 NSAttributedStringAttributed strings are made up of two parts: a plain Swift string, plus a dictionary containing a series of attributes that describe how various segments of the string are formatted. NSAttributedString可以针对一串字符串,片段化地设置其的属性,而Label却只能整个设置。我们在使用UILabel, UITextField, UITextView, UIButton, UINavigationBar等等支持text属性的情况下,更建议使用attributedText。 12NSAttributedString(string: String, attributes: [NSAttributedString.Key: Any]?) The examples are in codes below. NSAttributedString.Key – 一般用法NSAttributedString.Key is the attributes that you can apply to text in an attributed string. 1234567891011import UIKitvar string = &quot;This is a test string.&quot;let attributes: [NSAttributedString.Key: Any] = [ .foregroundColor: UIColor.white, .backgroundColor: UIColor.red, .font: UIFont.boldSystemFont(ofSize: 36)]let attributedString = NSAttributedString(string: string, attributes: attributes) 效果是这样的:虽然我们可以在Label中设置字符串的属性,但你不能对该字符串的不同部分设置不同的属性,而NSAttributedString可以做到。 NSMutableAttributedString(string: String)可更改属性的NSString,即使你使用let来定义,如下: 12345678let string = &quot;This is a test string&quot;let attributedString = NSMutableAttributedString(string: string)attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 8), range: NSRange(location: 0, length: 4))attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 16), range: NSRange(location: 5, length: 2))attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 24), range: NSRange(location: 8, length: 1))attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 32), range: NSRange(location: 10, length: 4))attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 40), range: NSRange(location: 15, length: 6)) NSAttributedString.Key – 的其他属性There are lots of formatting options for attributed strings, including: Set .underlineStyle to a value from NSUnderlineStyle to strike out characters. Set .strikethroughStyle to a value from NSUnderlineStyle (no, that’s not a typo) to strike out characters. Set .paragraphStyle to an instance of NSMutableParagraphStyle to control text alignment and spacing. Set .link to be a URL to make clickable links in your strings. 1attributedString.addAttribute(.link, value: &quot;https://www.google.com&quot;, range: NSRange(location: 0, length: attributedString.length)) switch@unknown defaultThere’s one final case in there to handle any unknown cases that crop up in the future. While we could have made one of the other cases handle that using a regular default case, in this project none of them really make sense for whatever might occur in the future so I’ve added a dedicated @unknown default case to handle future cases. Multipeer ConnectivityAirDrop功能强大,但它与app的整合不够紧密。幸运的是,从iOS7开始引入了一个新的框架,就是Multipeer Connectivity。Multipeer Connectivity是建立在与AirDrop相同技术上的一个框架。它传输范围比蓝牙广,不依赖网络,但需要打开wifi或蓝牙。 具体的初步实现还是挺简单的,可以参考: https://www.hackingwithswift.com/100/83https://www.hackingwithswift.com/100/84 #if #else #endif https://www.hackingwithswift.com/read/26/3/tilt-to-move-cmmotionmanager上文有提到这些用法 示例代码: 12345678910111213override func update(_ currentTime: TimeInterval) &#123;// Called before each frame is rendered#if targetEnvironment(simulator) if let currentTouch = lastTouchPosition &#123; let diff = CGPoint(x: currentTouch.x - player.position.x, y: currentTouch.y - player.position.y) physicsWorld.gravity = CGVector(dx: diff.x / 100, dy: diff.y / 100) &#125;#else if let accelerometreData = motionManager.accelerometerData &#123; physicsWorld.gravity = CGVector(dx: accelerometreData.acceleration.y * -50, dy: accelerometreData.acceleration.x * 50) // ?? 这里x和y是倒的 &#125;#endif&#125; 上面的例子,自己总结下来,就是:在模拟器上的时候,就只编译#if这部分代码,但如果是在真机的时候,就只编译#else部分的代码。 CoreMotionAll motion detection is done with an Apple framework called Core Motion. CMMotionManagerMost of the work about motion detection is done by a class called CMMotionManager.Using it here won’t require any special user permissions, so all we need to do is create an instance of the class and ask it to start collecting information.We can then read from that information whenever and wherever we need to, and in this project the best place is update().设备的移动等动作的检测,不需要得到用户的授权,无论何时何地我们都可以取得数据.范例中,取得该数据的代码,最好的就是放在update()中: 12345var motionManager: CMMotionManager!// 一般放在didMove(to:)motionManager = CMMotionManager()motionManager.startAccelerometerUpdates() 123456789101112override func update(_ currentTime: TimeInterval) &#123;#if targetEnvironment(simulator) if let currentTouch = lastTouchPosition &#123; let diff = CGPoint(x: currentTouch.x - player.position.x, y: currentTouch.y - player.position.y) physicsWorld.gravity = CGVector(dx: diff.x / 100, dy: diff.y / 100) &#125;#else if let accelerometreData = motionManager.accelerometerData &#123; physicsWorld.gravity = CGVector(dx: accelerometreData.acceleration.y * -50, dy: accelerometreData.acceleration.x * 50) // ?? 这里x和y是倒的 &#125;#endif&#125; CMMotionManager 的 startAccelerometerUpdates如上面代码有写到。U sing the startAccelerometerUpdates() method, which instructs Core Motion to start collecting accelerometer information we can read later. CMMotionManager 的 accelerometerData如上面代码有写到。就是取得设备移动等动作的数据。 Core GraphicsCore Graphics can work on a background thread – something that UIKit can’t do – which means you can do complicated drawing without locking up your user interface. Remember: SpriteKit’s positions things from the center and Core Graphics from the bottom left! UIGraphicsImageRenderer – classThat class name starts with “UI”, so what makes it anything to do with Core Graphics? Well, it isn’t a Core Graphics class; it’s a UIKit class, but it acts as a gateway to and from Core Graphics for UIKit-based apps like ours. You create a renderer object and start a rendering context, but everything between will be Core Graphics functions or UIKit methods that are designed to work with Core Graphics contexts. UIGraphicsImageRenderer的image – function123456789101112131415let renderer = UIGraphicsImageRenderer(size: CGSize(width: 512, height: 512))let img = renderer.image &#123; ctx in let rectangle = CGRect(x: 0, y: 0, width: 512, height: 512) ctx.cgContext.setFillColor(UIColor.red.cgColor) ctx.cgContext.setStrokeColor(UIColor.black.cgColor) ctx.cgContext.setLineWidth(10) ctx.cgContext.addRect(rectangle) ctx.cgContext.drawPath(using: .fillStroke)&#125;// 之前有设置@IBOutlet var imageView: UIImageView!imageView.image = img 上面例子中出现的 ctx.cgContext.setFillColor ctx.cgContext.setStrokeColor ctx.cgContext.setLineWidth ctx.cgContext.addRect ctx.cgContext.drawPath： setFillColor() sets the fill color of our context, which is the color used on the insides of the rectangle we’ll draw. setStrokeColor() sets the stroke color of our context, which is the color used on the line around the edge of the rectangle we’ll draw. setLineWidth() adjusts the line width that will be used to stroke our rectangle. Note that the line is drawn centered on the edge of the rectangle, so a value of 10 will draw 5 points inside the rectangle and five points outside. addRect() adds a CGRect rectangle to the context’s current path to be drawn. drawPath() draws the context’s current path using the state you have configured. 此外,再加一个fill(): fill() fill() skips the add path &#x2F; draw path work and just fills the rectangle given as its parameter using whatever the current fill color is. 比如下面的代码: 123456789101112131415let renderer = UIGraphicsImageRenderer(size: CGSize(width: 512, height: 512))let img = renderer.image &#123; ctx in ctx.cgContext.setFillColor(UIColor.black.cgColor) for row in 0 ..&lt; 8 &#123; for col in 0 ..&lt; 8 &#123; if (row + col) % 2 == 0 &#123; ctx.cgContext.fill(CGRect(x: col * 64, y: row * 64, width: 64, height: 64)) &#125; &#125; &#125;&#125;imageView.image = img 可以看到,使用ctx.cgContext.fill方法的时候,不需要像再上面的例子一样add path&#x2F;draw path。 还有translateBy rotate(by:) strokePath： translateBy() translates (moves) the current transformation matrix. – The default behavior of rotating the CTM is to rotate from the top-left corner of our canvas.If you want to rotate from a different position you should add a translation first. – CTM is the current transformation matrix. rotate(by:) rotates the current transformation matrix. strokePath() strokes the path with your specified line width, which is 1 if you don’t set it explicitly. 可以画出的效果为: 代码是: 123456789101112131415161718let renderer = UIGraphicsImageRenderer(size: CGSize(width: 512, height: 512))let img = renderer.image &#123; ctx in ctx.cgContext.translateBy(x: 256, y: 256) let rotations = 16 let amount = Double.pi / Double(rotations) for _ in 0 ..&lt; rotations &#123; ctx.cgContext.rotate(by: amount) ctx.cgContext.addRect(CGRect(x: -128, y: -128, width: 256, height: 256)) &#125; ctx.cgContext.setStrokeColor(UIColor.black.cgColor) ctx.cgContext.strokePath()&#125;imageView.image = img 还有move(to:) addLine(to:)可以呈现的效果是: 代码是: 1234567891011121314151617181920212223242526let renderer = UIGraphicsImageRenderer(size: CGSize(width: 512, height: 512))let img = renderer.image &#123; ctx in ctx.cgContext.translateBy(x: 256, y: 256) var first = true var length: CGFloat = 256 for _ in 0 ..&lt; 512 &#123; ctx.cgContext.rotate(by: .pi / 2) if first &#123; ctx.cgContext.move(to: CGPoint(x: length, y: 50)) first = false &#125; else &#123; ctx.cgContext.addLine(to: CGPoint(x: length, y: 50)) &#125; length *= 0.99 &#125; ctx.cgContext.setStrokeColor(UIColor.black.cgColor) ctx.cgContext.strokePath()&#125;imageView.image = img 使用NSAttributedString 以及 UIImage: 12345678910111213141516171819202122232425262728// 1let renderer = UIGraphicsImageRenderer(size: CGSize(width: 512, height: 512))let img = renderer.image &#123; ctx in // 2 let paragraphStyle = NSMutableParagraphStyle() paragraphStyle.alignment = .center // 3 let attrs: [NSAttributedString.Key: Any] = [ .font: UIFont.systemFont(ofSize: 36), .paragraphStyle: paragraphStyle ] // 4 let string = &quot;The best-laid schemes o&#x27;\\nmice an&#x27; men gang aft agley&quot; let attributedString = NSAttributedString(string: string, attributes: attrs) // 5 attributedString.draw(with: CGRect(x: 32, y: 32, width: 448, height: 448), options: .usesLineFragmentOrigin, context: nil) // 6 let mouse = UIImage(named: &quot;mouse&quot;) mouse?.draw(at: CGPoint(x: 300, y: 150))&#125;// 6imageView.image = img 解释一下上述6个步骤: Create a renderer at the correct size. Define a paragraph style that aligns text to the center. – Paragraph style also has options for line height, indenting, and more. Create an attributes dictionary containing that paragraph style, and also a font. Wrap that attributes dictionary and a string into an instance of NSAttributedString. Load an image from the project and draw it to the context. Update the image view with the finished result. 如何画出这个圆形的图形？(里面的字母忽略)需要使用都clip()来修剪,不然就是一个长方形。 12345678910111213let original = UIImage(contentsOfFile: path)!let renderer = UIGraphicsImageRenderer(size: original.size)let rounded = renderer.image &#123; ctx in ctx.cgContext.addEllipse(in: CGRect(origin: CGPoint.zero, size: original.size)) ctx.cgContext.clip() // 把original在rounded中画出来,也是显示出来的意思 original.draw(at: CGPoint.zero)&#125;cell.imageView?.image = rounded KeychainWrapper – class – 外部文件加载我们一般使用UserDefaults在设备内存储普通信息,但有时需要存储相对敏感或是偏向私人的信息,在程序外一样可以读取到该UserDefaults的数据，所以为了不让他人从我们的手机数据中简单读取到,这时候就不建议使用UserDefaults了,而是使用KeychainWrapper这个外来的类。但单单用KeychainWrapper来存储数据也不安全,最好是配合LA框架的TouchID和FaceID解锁程序更好。要使用KeychainWrapper,先要在项目中放入两个文件,分别是:KeychainItemAccessibility.swift 和 KeychainWrapper.swift。这两个文件已放在extraFiles文件夹中。 KeychainWrapper.standard.set(_ value:String, forKey key:String ) – 存储数据1KeychainWrapper.standard.set(secret.text, forKey: &quot;SecretMessage&quot;) KeychainWrapper.standard.string(forKey: String) – 读取数据1let text = KeychainWrapper.standard.string(forKey: &quot;SecretMessage&quot;) ?? &quot;&quot; KeychainWrapper.standard.hasValue(forKey: String) – 判断是否有值KeychainWrapper.standard.hasValue(forKey: passwordKey) 返回一个Bool LocalAuthentication – framework 即 LA framework https://www.hackingwithswift.com/read/28/4/touch-to-activate-touch-id-face-id-and-localauthentication import1import LocalAuthentication Touch ID 和 Face ID获得 Touch ID 和 Face ID 的用户授权以及去验证是否取得授权的大致步骤: 检查设备是否支持Touch ID 和 Face ID, 或者说用户有没有在系统中设置过Touch ID 和 Face ID; 如果有,请求Touch ID 和 Face ID的授权。 当我们请求的时候,给用户一串我们为何要请求的原因的符串。当请求Touch ID的时候,我们把原因写在代码中就可以了,但请求Face ID的时候,把原因的字符串写在Info.plist文件里面–加一个key -&gt; “Privacy - Face ID Usage Description.” 当我们请求成功的时候,我们就可以做我们想做的事情了,比如解锁这个app;不然,我们就要展示错误信息了。 注意:系统使用TouchID或FaceID,并不是两者都需要,只是挑一种,有一种就可以通过了。 LAContext的canEvaluatePolicy()和evaluatePolicy()方法 &#x2F; .deviceOwnerAuthenticationWithBiometrics – 请求的安全条款类型12345678910111213141516171819202122232425262728293031@IBAction func authenticateTapped(_ sender: Any) &#123; let context = LAContext() var error: NSError? // 1. if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) &#123; let reason = &quot;Identify yourself!&quot; // 2. context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) &#123; [weak self] success, authenticationError in DispatchQueue.main.async &#123; if success &#123; self?.unlockSecretMessage() &#125; else &#123; // 3. // error let ac = UIAlertController(title: &quot;Authentication failed&quot;, message: &quot;You could not be verified; please try again.&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) self?.present(ac, animated: true) &#125; &#125; &#125; &#125; else &#123; // 3. // no biometry let ac = UIAlertController(title: &quot;Biometry unavailable&quot;, message: &quot;Your device is not configured for biometric authentication.&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) self.present(ac, animated: true) &#125;&#125; Instruments – part of XCodeXCode中的Instruments,可以用来查看你的app的各种运行数据的工具。 Instruments的启动Cmd + I Time Profiler是图形化测试app中每个耗时的组件。 https://www.hackingwithswift.com/read/30/3/what-can-instruments-tell-us 在Debug菜单下面,可选择两个比较有用的选项:Color Blended Layers和Color Offscreen-Rendered。 Color Blended Layers shows views that are opaque in green and translucent in red. If there are multiple transparent views inside each other, you’ll see more and more red. Color Offscreen-Rendered shows views that require an extra drawing pass in yellow. Some special drawing work must be drawn individually off screen then drawn again onto the screen, which means a lot more work. Broadly speaking, you want “Color Blended Layers” to show as little red as possible, and “Color Offscreen-Rendered Yellow” to show no yellow. AllocationsThe allocations instrument will tell you how many of these objects are persistent (created and still exist) and how many are transient (created and since destroyed).图表里persistent代表建立后仍旧存在的数量,transient代表建立后销毁的数量。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://giantslayer1980.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"http://giantslayer1980.github.io/categories/iOS/Swift/"}],"tags":[]},{"title":"SwiftUI","slug":"SwiftUI","date":"2022-12-31T16:00:00.000Z","updated":"2023-02-27T15:11:59.166Z","comments":true,"path":"SwiftUI/","link":"","permalink":"http://giantslayer1980.github.io/SwiftUI/","excerpt":"Stringcomponents(seperatedBy:)1234let input = &quot;a b c&quot;let letters = input.components(separatedBy: &quot; &quot;)print(letters)// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] trimmingCharacters(in:)we can ask Swift to trim all whitespace at the start and end of a string like this: 1let trimmed = someString.trimmingCharacters(in: .whitespacesAndNewlines) 读取txt文件中的内容,并转化成String1234567891011// 例如读取项目中的start.txt文本文件中的内容,// 此外,该文本每行一个单词,随机读取一个单词:if let contentOfTxt = Bundle.main.url(forResource: &quot;start&quot;, withExtension: &quot;txt&quot;) &#123; if let contentOfString = try? String(contentsOf: contentOfTxt) &#123; let allWords = contentOfString.components(separatedBy: &quot;\\n&quot;) var randomWord = allWords.randomElement() ?? &quot;&quot; // 如果在func中,需要空return,并在下面if之外fatalError() // return &#125;&#125;// fatalError() NSRange &amp;&amp; rangeOfMisspelledWord &amp;&amp; NSNotFound1234567// rangeOfMisspelledWord:// Initiates a search of a range of a string for a misspelled word.func rangeOfMisspelledWord(in stringToCheck: String, range: NSRange, startingAt startingOffset: Int, wrap wrapFlag: Bool, language: String) -&gt; NSRange","text":"Stringcomponents(seperatedBy:)1234let input = &quot;a b c&quot;let letters = input.components(separatedBy: &quot; &quot;)print(letters)// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] trimmingCharacters(in:)we can ask Swift to trim all whitespace at the start and end of a string like this: 1let trimmed = someString.trimmingCharacters(in: .whitespacesAndNewlines) 读取txt文件中的内容,并转化成String1234567891011// 例如读取项目中的start.txt文本文件中的内容,// 此外,该文本每行一个单词,随机读取一个单词:if let contentOfTxt = Bundle.main.url(forResource: &quot;start&quot;, withExtension: &quot;txt&quot;) &#123; if let contentOfString = try? String(contentsOf: contentOfTxt) &#123; let allWords = contentOfString.components(separatedBy: &quot;\\n&quot;) var randomWord = allWords.randomElement() ?? &quot;&quot; // 如果在func中,需要空return,并在下面if之外fatalError() // return &#125;&#125;// fatalError() NSRange &amp;&amp; rangeOfMisspelledWord &amp;&amp; NSNotFound1234567// rangeOfMisspelledWord:// Initiates a search of a range of a string for a misspelled word.func rangeOfMisspelledWord(in stringToCheck: String, range: NSRange, startingAt startingOffset: Int, wrap wrapFlag: Bool, language: String) -&gt; NSRange 案例目的: 查询一串string是否存在拼写错误12345678910func isReal(word: String) -&gt; Bool &#123; let checker = UITextChecker() let range = NSRange(location: 0, length: word.utf16.count) let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: &quot;en&quot;) return misspelledRange.location == NSNotFound&#125;/*This method will make an instance of UITextChecker, which is responsible for scanning strings for misspelled words. We’ll then create an NSRange to scan the entire length of our string, then call rangeOfMisspelledWord() on our text checker so that it looks for wrong words. When that finishes we’ll get back another NSRange telling us where the misspelled word was found, but if the word was OK the location for that range will be the special value NSNotFound.*/ 读取JSon文件里的内容并形成一个Struct实例这里是一个泛型函数(GenericFunction)，传入的参数T要求遵守Decodable协议为什么T要符合Decodable协议?因为要从JSon文件中取得数据,就存在将结果解码decode的过程,所以这里要返回的是一个遵循Decodable协议的T类型。 1234567891011121314151617181920212223242526272829extension Bundle &#123; func decode&lt;T: Decodable&gt;(_ filename: String) -&gt; T &#123; // 关于Bundle: // 当Xcode构建iOS app时,即创建了一种叫Bundle的东西,它可以存在app中所有的文件. // 当要读取main app bundle里的一个文件时,就用到了Bundle.main.url(), // Bundle.main.url()得到的是一个optional,所以需要解包. guard let url = Bundle.main.url(forResource: filename, withExtension: nil) else &#123; fatalError(&quot;Failed to locate \\(filename) in bundle.&quot;) &#125; guard let data: Data = try? Data(contentsOf: url) else &#123; fatalError(&quot;Failed to load \\(filename) from bundle.&quot;) &#125; let decoder = JSONDecoder() // 对日期类字符串的显示格式的转换 // 前提是转换目标的struct中某个property的格式是Date的情况下会自动套用 let formatter = DateFormatter() formatter.dateFormat = &quot;y-mm-dd&quot; decoder.dateDecodingStrategy = .formatted(formatter) guard let loaded = try? decoder.decode(T.self, from: data) else &#123; fatalError(&quot;Failed to decode \\(filename) from bundle.&quot;) &#125; return loaded &#125;&#125; 此时,如何调用是个问题: 12// 这个代码会出错！！！let astronauts = Bundle.main.decode(&quot;astronauts.json&quot;) 以上代码会出现“Generic parameter ‘T’ could not be inferred！那么如何去说明这个generics泛型呢？ 123// 这是正确调用的代码！！！// astronauts要说明类型！！！let astronauts: [String: Astronaut] = Bundle.main.decode(&quot;astronauts.json&quot;) 对于JSon数据中存在变量名是snake case的情况,如何转换成struct的属性名是camel case? – keyDecodingStrategy一般我们的struct的属性名都是CamelCase的,比如firstName,但我们会遇到某些JSon数据中存在变量名是snake_case的情况,比如first_name,那么如何decode呢？下面的例子: 12345678910111213141516171819202122232425262728// User结构struct User: Codable &#123; var firstName: String var lastName: String&#125;// 存在sname case结构的字符串存有json数据let str = &quot;&quot;&quot;&#123; &quot;first_name&quot;: &quot;Andrew&quot;, &quot;last_name&quot;: &quot;Glouberman&quot;&#125;&quot;&quot;&quot;// 下面的步骤:let data = Data(str.utf8)do &#123; let decoder = JSONDecoder() // 下面这行是关键 decoder.keyDecodingStrategy = .convertFromSnakeCase let user = try decoder.decode(User.self, from: data) print(&quot;Hi, I&#x27;m \\(user.firstName) \\(user.lastName)&quot;)&#125; catch &#123; print(&quot;Whoops: \\(error.localizedDescription)&quot;)&#125; 对于struct属性名是firstName,而JSon数据中却只是first的属性名,如何解决并最终正确decode？1234567891011121314// User结构struct User: Codable &#123; var firstName: String var lastName: String&#125;// JSon字符串变成了这样let str = &quot;&quot;&quot;&#123; &quot;first&quot;: &quot;Andrew&quot;, &quot;last&quot;: &quot;Glouberman&quot;&#125;&quot;&quot;&quot;// 这时候对User结构进行如何改变: 123456789struct User: Codable &#123; enum CodingKeys: String, CodingKey &#123; case firstName = &quot;first&quot; case lastName = &quot;last&quot; &#125; var firstName: String var lastName: String&#125; 这样就可以进行decode操作了吗？具体还未操作过,以后遇到了再来补充这个笔记。 Codable协议Codable协议的一个简单实例Codable protocol is composed of Encodable and Decodable.Codable &#x3D; Encodable &amp; Decodable 12345678910111213141516171819202122232425262728293031import Foundation// JSon是类似于&#123;&quot;id&quot;:&quot;1001&quot;,&quot;name&quot;:&quot;Shaddy&quot;,&quot;grade&quot;:11&#125;这样的数据格式,// 而Codable协议,可编码为在网络上最广泛使用的JSon数据格式,// 后续进行JSONEncoder().encode()编码时,放入的参数必须遵循该协议struct Student: Codable &#123; var id: String var name: String var grade: Int&#125;let student = Student(id: &quot;1001&quot;,name: &quot;Shaddy&quot;, grade: 11)do &#123; // 将遵循Codable协议的结构,转换为JSon数据 let jsonEncoder = JSONEncoder() // jsonEncoder.encode(_ value: Encodable) let jsonData = try jsonEncoder.encode(student) // 这里为了方便显示,将jsonData转换为字符串形式,实际项目中直接将jsonData传出即可 let jsonString = String(decoding: jsonData, as: UTF8.self) print(&quot;result: \\(jsonString)&quot;) // result: &#123;&quot;id&quot;:&quot;1001&quot;,&quot;name&quot;:&quot;Shaddy&quot;,&quot;grade&quot;:11&#125; // 这里将json数据解码decode回来 let jsonDecoder = JSONDecoder() // jsonDecoder.decode(type: Decodable.Protocol, from: Data) let jsonDecoderData = try jsonDecoder.decode(Student.self, from: jsonData) print(&quot;result: \\(jsonDecoderData)&quot;) // result: Student(id: &quot;1001&quot;, name: &quot;Shaddy&quot;, grade: 11)&#125; https://www.jianshu.com/p/f39994e045d2 此外,这是一个Codable协议的具体实例,可以用来处理具体从外部拿到的json数据:视频地址: https://www.bilibili.com/video/BV1pb4y1X7ZH?p=22 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import SwiftUI//struct CustomerModel: Identifiable, Decodable, Encodable &#123;struct CustomerModel: Identifiable, Codable &#123; let id: String let name: String let points: Int let isPremium: Bool // 因为CustomerModel遵循Codable协议, // 所以下面的init(from decoder: Decoder) // 和enum CodingKeys: String, CodingKey // 和func encode(to encoder: Encoder)都不需要去定义了// enum CodingKeys: String, CodingKey &#123;// case id// case name// case points// case isPremium// &#125;//// init(id: String, name: String, points: Int, isPremium: Bool) &#123;// self.id = id// self.name = name// self.points = points// self.isPremium = isPremium// &#125;//// init(from decoder: Decoder) throws &#123;// let container = try decoder.container(keyedBy: CodingKeys.self)// self.id = try container.decode(String.self, forKey: .id)// self.name = try container.decode(String.self, forKey: .name)// self.points = try container.decode(Int.self, forKey: .points)// self.isPremium = try container.decode(Bool.self, forKey: .isPremium)// &#125;//// func encode(to encoder: Encoder) throws &#123;// var container = encoder.container(keyedBy: CodingKeys.self)// try container.encode(id, forKey: .id)// try container.encode(name, forKey: .name)// try container.encode(points, forKey: .points)// try container.encode(isPremium, forKey: .isPremium)// &#125;&#125;class CodableViewModel: ObservableObject &#123; @Published var customer: CustomerModel? = nil init() &#123; getData() &#125; func getData() &#123; guard let data = getJSONData() else &#123; return &#125; // if// let localData = try? JSONSerialization.jsonObject(with: data, options: []),// let dictionary = localData as? [String: Any],// let id = dictionary[&quot;id&quot;] as? String,// let name = dictionary[&quot;name&quot;] as? String,// let points = dictionary[&quot;points&quot;] as? Int,// let isPremium = dictionary[&quot;isPremium&quot;] as? Bool &#123;//// let newCustomer = CustomerModel(id: id, name: name, points: points, isPremium: isPremium)// customer = newCustomer//// &#125; // do &#123;// self.customer = try JSONDecoder().decode(CustomerModel.self, from: data)// &#125; catch let error &#123;// print(&quot;Error Decoding. \\(error)&quot;)// &#125; // 因为CustomerModel遵循Decodable协议,所以可以使用JSONEncoder().decode self.customer = try? JSONDecoder().decode(CustomerModel.self, from: data) &#125; // getJSONData方法是从网站等取得数据的,所以返回的Data是一个Optional,因为有可能失败 // Data格式理解为是类似Json格式类的数据 func getJSONData() -&gt; Data? &#123; // 如果拿到的是一个符合CustomerModel的struct,如何转换成jsonData的数据:// let customer = CustomerModel(id: &quot;123&quot;, name: &quot;Vi&quot;, points: 100, isPremium: true)// // 因为CustomerModel遵循Encodable协议,所以可以使用JSONEncoder().encode// let jsonData = try? JSONEncoder().encode(customer) // 下面是fake了一些json数据 let dictionary: [String: Any] = [ &quot;id&quot;: &quot;12345&quot;, &quot;name&quot;: &quot;Joe&quot;, &quot;points&quot;: 5, &quot;isPremium&quot;: true ] // 使用JSONSerialization.data方法将JSONObject转换成JSONData let jsonData = try? JSONSerialization.data(withJSONObject: dictionary, options: []) return jsonData &#125;&#125;struct CodableBootcamp: View &#123; @StateObject var vm = CodableViewModel() var body: some View &#123; VStack(spacing: 20) &#123; if let customer = vm.customer &#123; Text(customer.id) Text(customer.name) Text(&quot;\\(customer.points)&quot;) Text(customer.isPremium.description) &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940//从特定网页取数据import UIKitstruct User: Decodable &#123; var id: Int var name: String var username: String var email: String var phone: String var website: String var company: Company var address: Address&#125;let url2 = URL(string: “https://jsonplaceholder.typicode.com/users&quot;)!let session = URLSession.sharedsession.dataTask(with: url2) &#123; (data, response, error) in guard let data = data, error == nil, let response = response as? HTTPURLResponse, rsponse.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else &#123; print(&quot;Error downloading data.&quot;) return &#125; do&#123; //原始解析方法// let json = try JSONSerialization.jsonObject(with: data, options: .mutableLeaves)// print(json) let users = try JSONDecoder().decode([User].self, from: data)// print(users) for user in users&#123; print(user.address.geo.lat) &#125; &#125;catch&#123; print(error) &#125;&#125;.resume() @Binding页面如何初始化preview因为某些页面有初始化@Binding的变量,那么该页面需要preview的话,如何生成预览呢？一个是自己生成一些测试数据,另一个就是使用.constant函数: 123456struct RFSearchListView_Previews: PreviewProvider &#123; static var previews: some View &#123; RFSearchListView(items: .constant([&quot;a&quot;,&quot;b&quot;,&quot;C&quot;])) &#125;&#125; 在Picturepreview项目中的PicturePreview.swift文件中,使用的是: 1PicturePreview(pictures: pictures, selectedPicture: .constant(nil)) Substring 与 StringSubstring并不是String的子类，这是两个不同的类型，但是它们都继承了StringProtocol协议，因此存在一些共性；在开发中Substring并不常用(目前只在分割String见到)，所以往往要转成String。字符串使用split()分割的时候,得到的是[Sbustring],所以要得到[String]的话,还需要再转换。比如： 1234var a:[String] = “”“AB“””.split(separator: “\\n”).map&#123;String($0)&#125; 必须要把Substring转换成String才行。 Identifiable的使用我们知道,当遍历一个结构的时候,比如 12struct SomeItem &#123; let id = UUID() &#125;ForEach(someItems, id:\\.id) 或者上述结构没有定义id时,则需要用到： 1ForEach(someItems, id:\\.self), 因此需要带有id:.id或者id:.self。但Identifiable就比较方便了： 1struct SomeItem: Identifiable &#123; let id = UUID() &#125; 这时候就可以这样简便的： 123ForEach(someItems) &#123; item in // ……&#125; ForEach中\\.self使用的注意事项看了文章,发现ForEach中若使用到id:\\.self,则该struct之类的必须实现Hashable,实质上就是把每个item实现hashable,以便能够识别出来。下面对象遵循了Identifiable协议,也是变相地遵循Hashable以便能够识别。 如果一个对象遵循Identifiable协议,比如: 123456struct Student: Identifiable &#123; let id: UUID = UUID() var name: String var strings: [String] var colors: [Color]&#125; 那么可以在ForEach中这样使用： 12345678var students: [Student] = [ Student(name: &quot;A&quot;, strings: [&quot;a&quot;], colors: [Color(.green)]), Student(name: &quot;B&quot;, strings: [&quot;b&quot;], colors: [Color(.green)]), Student(name: &quot;C&quot;, strings: [&quot;c&quot;], colors: [Color(.red)])]ForEach(students) &#123; student in print(student.name)&#125; 显示结果为： A B C 当Student遵循Identifiable协议时,ForEach中就不必使用id:\\.self。如果不遵循Identifiable协议时,就需要我们指定唯一属性的key path,（Student下面的name&#x2F;strings&#x2F;colors属性都可以作为key path来使用,因为都可以计算哈希值）但如果连key path也没有的话,我们可以用\\.self。当使用\\.self时,就是将整个结构对象的组合(如students)中的每个元素来一一迭代的话,就需要被迭代的每个元素结构遵循Hashable协议，例如： 12345struct Student: Hashable &#123; var name: String var strings: [String] var colors: [Color]&#125; 此时,ForEach内可以使用id的是:\\.self | \\.name | \\.strings | \\.colors而如果Student既不遵循Identifiable,也不遵循Hashable: 12345struct Student &#123; var name: String var strings: [String] var colors: [Color]&#125; 那么ForEach内可以使用id的是:\\.name | \\.strings | \\.colors也就是说\\.self不能使用。 实际上,ForEach是在检索每个被迭代元素的哈希值,所以对于一个结构来说，一定要经过遵循并计算哈希值后,才可以被迭代。 如果哈希值相同的情况,会出现什么问题呢？ 1234ForEach(students, id:\\.colors) &#123; student in print(student.name)&#125; 因为Students中前两个元素的colors属性完全相同,那么初始计算的时候,这两个元素的索引哈希值也相同,所以显示结果是： A A C 这是平时使用当中需要注意的问题。 ForEach既取得Array的元素,又取得Array的index,还能让Array中的元素调换次序但不会造成程序错误的方式例如有一个Array,里面的元素都是一个Card结构的,即cards 是 [Card],如何迭代这个cards,既能取得每个元素,还能取得每个元素的index,同时我删减、改变位置等等都不会让这次迭代出问题.之前都是这么迭代的: 123ForEach(0..&lt;cards.count, id:\\.self) &#123; index in // 内容省略&#125; 你要是做类似次序改变什么的操作,会出问题,所以我们应该这么做:前提是,该Array中元素必须符合Identifiable和Hashable协议,就是每个元素都有独有的识别特征,保持数据的唯一性,接下来的代码应该是: 1234ForEach(Array(cards.enumerated()), id:\\.element) &#123; item in // 此时item.element代表元素本身 // 同时item.offset代表元素的index&#125; Alamofire模块的导入及使用注:Alamofire是使用Swift写的用来实现网络请求的模块。 Alamofire模块的导入 从github下载, https://gitcode.net/mirrors/Alamofire/ ,并解压 打开需要使用Alamofire的项目,菜单栏中:File-&gt;Add Files to “项目名称” 在弹出选择界面勾选“Copy items if needed”,找到下载解压好的Alamofire位置,选择Alamofire.xcodeproj 但有时以上做完,还是无法import Alamofire,这时要在xcode的项目目录，选择最外层这个项目名称，基本的General设置里的Frameworks,Libraries,and Embedded Content里将Alamofire添加到项目的静态库中 接下来项目就可以import Alamofire了。 Alamofire模块的使用貌似还没法用,下次有机会再试一下关于使用方法在：https://www.jianshu.com/p/07b1ec36a689里面讲到了使用Alamofire进行GET&#x2F;post及使用的细则。 ProgressView 进度条用法: 1ProgressView(value: 5, total: 15) 或者: 1ProgressView(value: 0.5) 如果不设置范围,比如: 1ProgressView(&quot;Downloading…&quot;) 效果图: .progressViewStyle为了让progress进度条更好看一些,创建一个SwiftUI文件,比如ScrumProgressViewStyle.swift: 12345678910111213141516171819202122232425262728293031import SwiftUIstruct ScrumProgressViewStyle: ProgressViewStyle &#123; var color1: Color var color2: Color func makeBody(configuration: Configuration) -&gt; some View &#123; ZStack &#123; RoundedRectangle(cornerRadius: 10.0) .fill(color1) .frame(height: 20.0) if #available(iOS 15.0, *) &#123; ProgressView(configuration) .tint(color2) .frame(height: 12.0) .padding(.horizontal) &#125; else &#123; ProgressView(configuration) .frame(height: 12.0) .padding(.horizontal) &#125; &#125; &#125;&#125;struct ScrumProgressViewStyle_Previews: PreviewProvider &#123; static var previews: some View &#123; ProgressView(value: 0.4) .progressViewStyle(ScrumProgressViewStyle(color1: .blue, color2: .green)) .previewLayout(.sizeThatFits) &#125;&#125; 效果图: 为Label的.labelStyle这一modifier,创建新的样式即.trailingIcon,并遵循LabelStyle协议例如： 12Label(&quot;10&quot;, systemImage: &quot;clock) .labelStyle(.xxx) 其中.xxx可以选择 .iconOnly &#x2F; .titleAndIcon &#x2F; .titleOnly等等来使用(只显示icon &#x2F; 按照 icon + title 的次序显示 &#x2F; 只显示title)。而此处为其添加新的选项,即 .trailingIcon,看字面意思就是和.titleAndIcon相反的,即把Icon放最后,而title放前面的意思。具体实现： 1234567891011121314import SwiftUIstruct TrailingIconLabelStyle: LabelStyle &#123; func makeBody(configuration: Configuration) -&gt; some View &#123; HStack &#123; configuration.title configuration.icon &#125; &#125;&#125;extension LabelStyle where Self == TrailingIconLabelStyle &#123; static var trailingIcon: Self &#123; Self() &#125;&#125; 如何使用： 123Label(&quot;10&quot;, systemImage: &quot;clock&quot;) .labelStyle(.trailingIcon) .onDelete – ForEach所独有的删除内部元素的功能 注意: List没有.onDelete这个midifier,但一般都是List里面嵌套ForEach,在ForEach上添加.onDelete。 在Section内使用Foreach来依次显示列表内的内容时,在ForEach内可以使用.onDelete来划动删除特定项。当划动特定项时,会出现划动后的红色“删除”字样： 12345678Section(header: Text(&quot;Attendees&quot;)) &#123; ForEach(data.attendees) &#123; attendee in Text(attendee.name) &#125; .onDelete &#123; indices in data.attendees.remove(atOffsets: indices) &#125;&#125; .swipeAction(edge:allowsFullSwipe:content:) 好于.onDelete功能1234567891011121314151617181920// 例子中是放在List里面,而非Section中Section(header: Text(&quot;Attendees&quot;)) &#123; ForEach(data.attendees) &#123; attendee in Text(attendee.name) &#125; .swipeActions(edge: .trailing, allowsFullSwipe: false) &#123; Button(&quot;Archive&quot;) &#123;&#125; .tint(.green) Button(&quot;Save&quot;) &#123;&#125; .tint(.blue) Button(&quot;Junk&quot;) &#123;&#125; .tint(.black) &#125; .swipeActions(edge: .leading, allowsFullSwipe: true) &#123; Button(&quot;Share&quot;) &#123;&#125; .tint(.yellow) &#125; &#125; 里面,对每个字元素右滑动,会出现三个选项:”Archive”&#x2F;“Save”&#x2F;“Junk”,而左滑动会出现一个选项:”Share”.allowsFullSwipe表示是否从头滑到尾。一般一个按钮的时候可以,多个按钮的时候不建议。 Button停用Button – .disabled12Button(action:&#123;&#125;) &#123;&#125; .disabled(someBoolVariableIsEmpty) 当变量someBoolVariableIsEmpty为true时,该Button将会被停用。 .buttonStyle(.xxx) &#x2F; .controlSize(.large) &#x2F; .buttonBorderShape(.xxx)Button的修饰符.buttonStyle(.xxx)以及.controlSize(.xxx) &#x2F; .buttonBorderShape(.xxx)可以在使用的时候自己调试下,一些系统默认给的样式。 sheet modifier on List 的使用1234List() .sheet(isPresented: $isPresented) &#123; ... &#125; 参数isPresented需要传入的是一个Binding。可以这样理解,因为该sheet会被下拉而退出,但若下拉后该isPresented参数不被变更为false,则sheet仍会被展现,这明显是错误的,所以需要进行绑定参数,而非仅仅传一个值给sheet。 sheet加载的View页面的dismiss使用@Environment(.presentationMode)不显示该View在sheet加载的View中设定一个变量: 1@Environment(\\.presentationMode) var presentationMode 当要不显示该View时,执行代码: 1presentationMode.wrappedValue.dismiss() 即可。 sheet页面的大小控制 presentationDetents() – modifier可控制sheet页面的大小,一般都是large,占据整个页面,可以设置成medium,或者按照百分比,或具体高度等。 https://www.hackingwithswift.com/quick-start/swiftui/how-to-display-a-bottom-sheet 使用@Environment(.dismiss)在sheet加载的View中设定一个变量: 1@Environment(\\.dismiss) var dismiss 当要不显示该View时,执行代码: 1dismiss() 即可。 .interactiveDismissDisabled() – modifier 禁止下划释放页面使用.sheet()等可以放出页面,这时可以通过下划来释放该页面。但使用.interactiveDismissDisabled()可以禁止该行为。.interactiveDismissDisabled()默认没有参数,也可以放入true,即不允许下划释放页面,当放入false,即允许下划释放页面。 123456789101112131415161718192021222324252627282930struct ExampleSheet: View &#123; @Environment(\\.presentationMode) var presentationMode @State private var termsAccepted = false var body: some View &#123; VStack &#123; Text(&quot;Terms and conditions&quot;) .font(.title) Text(&quot;Lots of legalese here.&quot;) Toggle(&quot;Accept&quot;, isOn: $termsAccepted) &#125; .padding() .interactiveDismissDisabled(!termsAccepted) &#125; func close() &#123; presentationMode.wrappedValue.dismiss() &#125;&#125;struct ContentView: View &#123; @State private var showingSheet = false var body: some View &#123; Button(&quot;Show Sheet&quot;) &#123; showingSheet.toggle() &#125; .sheet(isPresented: $showingSheet, content: ExampleSheet.init) &#125;&#125; .fullScreenCover – modifier类似于.sheet(),参数也是一样的,但是可以全屏显示的View .fullScreenCover(isPresented: content:) 123456Button() &#123;&#125;.fullScreenCover(isPresented:$variable, content: &#123; OtherView()&#125;) 但是.sheet()加载的弹出页面可以下拉操作,.fullScreenzCover()不可以,所以还是推荐前者。 toolbar 此modifier 的使用在List的右上角显示工具栏显示一个”edit”的button按钮： 123456List() .toolbar &#123; Button(&quot;edit&quot;) &#123; ... &#125; &#125; 在一个View上面显示”Cancel”和”Done”按钮： 1234567891011121314View() .toolbar &#123; ToolbarItem(placement: .cancellationAction) &#123; Button(&quot;Cancel&quot;) &#123; isPresentingEditView = false &#125; &#125; ToolbarItem(placement: .confirmationAction) &#123; Button(&quot;Done&quot;) &#123; isPresentingEditView = false scrum.update(from: data) &#125; &#125; &#125; 两个按钮是平行排列的，感觉当中还夹着一个Spacer()。或者不用两个ToolbarItem的话,可以只使用一个ToolbarItemGroup来实现,里面直接放两个Button。 1234567891011121314151617NavigationView &#123; Text(&quot;Hello, World!&quot;).padding() .navigationTitle(&quot;SwiftUI&quot;) .toolbar &#123; ToolbarItemGroup(placement: .bottomBar) &#123; Button(&quot;First&quot;) &#123; print(&quot;Pressed&quot;) &#125; Spacer() Button(&quot;Second&quot;) &#123; print(&quot;Pressed&quot;) &#125; &#125; &#125;&#125; toolbar 之 默认方法EditButton()的使用 – 也是针对ForEach而使用1234567891011List&#123; ForEach(...) &#123; ...... &#125;&#125;.toolbar &#123; // 会让展示列表的各个选项前出现类似删除的标志 EditButton() // 但点击后一点反应也没有,它是如何运作的呢？ // 看下面的比较全面的案例！&#125; 12345678910111213141516171819202122232425262728293031323334353637383940import SwiftUIstruct Item: Identifiable &#123; let id = UUID() let title: String&#125;struct ContentView: View &#123; @State var editMode = EditMode.inactive @State private var items: [Item] = (0..&lt;5).map &#123; Item(title: &quot;Item #\\($0)&quot;) &#125; @State private var count = 0 var body: some View &#123; NavigationView&#123; List&#123; ForEach(items)&#123;item in Text(item.title) &#125; .onDelete(perform: &#123;offsets in items.remove(atOffsets: offsets) &#125;) .onMove(perform: &#123; source, destination in items.move(fromOffsets: source, toOffset: destination) &#125;) &#125; .onAppear()&#123; count = items.count &#125; .navigationBarTitle(&quot;List&quot;) .navigationBarItems(leading: EditButton(), trailing: Button(&quot;Add&quot;, action: &#123; items.append(Item(title: &quot;Item #\\(count)&quot;)) count += 1 &#125;)) .environment(\\.editMode, $editMode) &#125; &#125;&#125; 你会发现:1.点击EditButton的Edit按钮,会显示ForEach后面修饰的.onDelete和.onMove修饰符,说明写在List上的EditButton,其实是激活了List里面ForEach修饰的各种方法,其中就包括上面写好的.onDelete和.onMove;2.这里有一个@State var editMode &#x3D; EditMode.inactive和.environment(.editMode, $editMode),这里还有一个案例,可以使用到这个EditMode:(就是根据EditMode状态的不同,而显示不同的按钮) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct Item: Identifiable &#123; let id = UUID() let title: String static var i = 0 init() &#123; self.title = &quot;\\(Item.i)&quot; Item.i += 1 &#125;&#125;struct ContentView2: View &#123; @State var isEditMode: EditMode = .inactive @State var selection = Set&lt;UUID&gt;() var items = [Item(), Item(), Item(), Item(), Item()] var body: some View &#123; NavigationView &#123; List(selection: $selection) &#123; ForEach(items) &#123; item in Text(item.title) &#125; &#125; .navigationBarTitle(Text(&quot;Demo&quot;)) .navigationBarItems( leading: EditButton(), trailing: addDelButton ) .environment(\\.editMode, self.$isEditMode) &#125; &#125; // 根据isEditMode的状态来改变显示不同的按钮: private var addDelButton: some View &#123; if isEditMode == .inactive &#123; return Button(action: reset) &#123; Image(systemName: &quot;plus&quot;) &#125; &#125; else &#123; return Button(action: reset) &#123; Image(systemName: &quot;trash&quot;) &#125; &#125; &#125; private func reset() &#123; selection = Set&lt;UUID&gt;() &#125;&#125; 3.以上案例还用到了List(selection:) toolbar 之 EditButton()的单选或多选元素的操作下面例子是多选元素: 1234567891011121314151617181920212223struct ContentView: View &#123; @State private var selection = Set&lt;String&gt;() // 单选的话改成 @State private var selection: String? let names = [ &quot;Cyril&quot;, &quot;Lana&quot;, &quot;Mallory&quot;, &quot;Sterling&quot; ] var body: some View &#123; NavigationView &#123; List(names, id: \\.self, selection: $selection) &#123; name in Text(name) &#125; .navigationTitle(&quot;List Selection&quot;) .toolbar &#123; EditButton() &#125; &#125; &#125;&#125; List 之 refreshable() modifier – 下拉更新通过下滑出现更新操作。代码如下: 123456789101112131415161718192021222324252627282930313233343536struct NewsItem: Decodable, Identifiable &#123; let id: Int let title: String let strap: String&#125;struct ContentView: View &#123; @State private var news = [ NewsItem(id: 0, title: &quot;Want the latest news?&quot;, strap: &quot;Pull to refresh!&quot;) ] var body: some View &#123; NavigationView &#123; List(news) &#123; item in VStack(alignment: .leading) &#123; Text(item.title) .font(.headline) Text(item.strap) .foregroundColor(.secondary) &#125; &#125; .refreshable &#123; do &#123; // Fetch and decode JSON into news items let url = URL(string: &quot;https://www.hackingwithswift.com/samples/news-1.json&quot;)! let (data, _) = try await URLSession.shared.data(from: url) news = try JSONDecoder().decode([NewsItem].self, from: data) &#125; catch &#123; // Something went wrong; clear the news news = [] &#125; &#125; &#125; &#125;&#125; @State 与 @StateObject &#x2F; @ObservedObject &#x2F; @EnvironmentObject 的区别？the @State property wrapper works only for value types, such as structures and enumerations.@ObservedObject, @StateObject, and @EnvironmentObject declare a reference type as a source of truth. To use these property wrappers with your class, you need to make your class observable.总结下来:1.@State 仅用于Struct 和 Enum 等 值类型，存储在View内部；而@StateObject、@ObservedObject和@EnvironmentObject用于引用类型,即class对象，存储在View外部（但可以在View内部命名）。2.若要使用@ObservedObject、@StateObject和@EnvironmentObject的话，要使得对应的class实现ObservableObject协议。 @StateObject &#x2F; @ObservedObject 两者如何区别使用?看下来的心得：定义@ObservedObject的View,如果是作为subView的话,那么当parentView中的视图存在更新的情况下,这个subView中的@ObservedObject属性就会再次创建。因此,subView只做展示,该subView自身不会主动做数据更新(若要自身主动更新,则使用@StateObject,但注意性能消耗问题）。但另一种情况,parentView是通过@StateObject来创建对象,subView中是使用了@ObservedObject来接收对象,则不会让页面的数据产生错乱。例如下面的例子: 1234567891011121314151617181920212223242526class UserProgress: ObservableObject &#123; @Published var score = 0&#125;struct InnerView: View &#123; // subView使用@ObservedObject来接收对象！！！ @ObservedObject var progress: UserProgress var body: some View &#123; Button(&quot;Increase Score&quot;) &#123; progress.score += 1 &#125; &#125;&#125;struct ContentView: View &#123; // parentView使用@StateObject来创建对象！！！ @StateObject var progress = UserProgress() var body: some View &#123; VStack &#123; Text(&quot;Your score is \\(progress.score)&quot;) InnerView(progress: progress) &#125; &#125;&#125; 以上,因为InnerView是来接收这个progress引用变量的,所以可以改变它,相应会反馈到parent view中。记住: 不要使用@ObservedObject来创建实例,假如你真的要这么做,使用@StateObject. 下面的内容是从其他地方总结下来的,暂且放一下吧,领会上面的就够了,而且验证下来上面是对的。 https://blog.csdn.net/fzhlee/article/details/114269326若是在某个View中使用@ObservedObject来创建一个实例,当这个View页面刷新时,这个@ObservedObject创建的实例会再次创建,这会给大多数场景带来意外(比如你已经改变过该实例的属性的值了,突然它又重新创建了一遍,那改变的值又还原了)。所以,此时使用@StateObject来创建实例比较好,因为它有储存属性,而不像@ObservedObject,具有@ObservedObject的视图,但没有保留ObservableObject，则每次该视图重绘其主体时都会创建一个新实例。 但是,这不意味着要将所有@ObservedObject属性均标记为@StateObject。若每次重新绘制视图时,都要重新创建@StateObject实例的话,则会消耗性能。此外,如果本意就是要创建一个新的实例的情况下,那么新实例就会被忽略,从而引起一个隐藏的错误。 简单来说,对于在使用它的视图中初始化的所有可观察属性，都应使用@StateObject。如果ObservableObject实例是在外部创建的，并传递给使用它的视图，请使用@ObservedObject标记您的属性。 @StateObject – Use this on certain &#x2F; init@ObservedObject – use this for subviews 我们也可以说,@EnvironmentObject与@StateObject一样,都有存储属性。 此外,从外部文章中找到的 @StateObject &#x2F; @ObservedObject 两者如何区别使用的解答:When you want to use a class instance elsewhere – when you’ve created it in view A using @StateObject and want to use that same object in view B – you use a slightly different property wrapper called @ObservedObject. That’s the only difference: when creating the shared data use @StateObject, but when you’re just using it in a different view you should use @ObservedObject instead. 如何让 @Published 遵循Codable协议我们定义一个名为User的class,并遵循Codable协议,再定义一个@Published属性name: 123class User: ObservableObject, Codable &#123; @Published var name = &quot;Paul Hudson&quot;&#125; 报错信息为：Type ‘User’ does not conform to protocol ‘Encodable’.如何解决这个问题: https://www.hackingwithswift.com/books/ios-swiftui/adding-codable-conformance-for-published-properties 1234567891011121314151617class User: ObservableObject, Codable &#123; @Published var name = &quot;Paul Hudson&quot; enum CodingKeys: CodingKey &#123; case name &#125; required init(from decoder: Decoder) throws &#123; let container = try decoder.container(keyedBy: CodingKeys.self) name = try container.decode(String.self, forKey: .name) &#125; func encode(to encoder: Encoder) throws &#123; var container = encoder.container(keyedBy: CodingKeys.self) try container.encode(name, forKey: .name) &#125;&#125; 总结：1.设置遵循CodingKey的enum;2.设置required init(from decoder: Decoder) throws,里面包含到需要decode的@Published元素;3.设置encode方法,并设置需要encode的@Published元素;4.只要设置了以上,发现@Published元素即使有很多,只要设置你需要encode和decode的@Published元素即可,并不是每个都要去设置encode和decode的。 @EnvironmentObject 传值的简单示例这是需要共享的基本数据： 1234class User: ObservableObject &#123; // 因为需要传递这个对象给其他View,所以定义private会让意图混淆,虽然可能你写了private也不大会出错 @Published var name = &quot;Taylor Swift&quot;&#125; 接下来是两个用来接收上述数据的结构类型： 1234567891011121314struct EditView: View &#123; @EnvironmentObject var user: User var body: some View &#123; TextField(&quot;Name&quot;, text: $user.name) &#125;&#125;struct DisplayView: View &#123; @EnvironmentObject var user: User var body: some View &#123; Text(user.name) &#125;&#125; 那么,在ContentView中,如何向EditView()和DisplayView传递一个User对象？ 12345678910struct ContentView: View &#123; let user = User() var body: some View &#123; VStack &#123; EditView().environmentObject(user) DisplayView().environmentObject(user) &#125; &#125;&#125; 也可以把ContentView改成这样： 12345VStack &#123; EditView() DisplayView()&#125;.environmentObject(user) 上例把 user 放到 ContentView 的环境中，但是因为 EditView 和 DisplayView 都是 ContentView 的子视图，所以它们自动继承了 ContentView 的环境。 .environmentObject(user) 和 @EnvironmentObject var user: User 之间是如何建立联系的？你会发现,.environmentObject(user)中只有一个user,而不是(user:user),那@EnvironmentObject var user: User是如何正确识别并接收的呢？查了资料,有称是通过字典的类型存键和类型存值来进行的。比如键存的是数据类型,就是User,而值就是User()。真的是这样吗？那如果我同时传递两个相同类型的对象,接收方如何区分？看到一片解释是:That @EnvironmentObject property wrapper will automatically look for a User instance in the environment, and place whatever it finds into the user property. If it can’t find a User in the environment your code will just crash.但貌似也没解释问题所在。 .badge() 的使用一般用于 List &#x2F; TabView 上.List的Text上使用: 123456// 会在第一个Text后面多一个5的标识,某些场景应该用的到List &#123; Text(&quot;Hello, world&quot;) .badge(5) Text(&quot;Hello!&quot;)&#125; 若没有List,你光在Text下加badge是没有用的. 在TabView上使用： 1234567891011121314TabView &#123; Color.red .tabItem &#123; Image(systemName: &quot;heart.fill&quot;) Text(&quot;Hello&quot;) &#125; .badge(&quot;New&quot;) // 在Image上角上有一个标识,可以代表有新内容 // .badge(2) 可以表示有2个更新 Color.green.opacity(0.5) .tabItem &#123; Image(systemName: &quot;heart.fill&quot;) Text(&quot;Hello&quot;) &#125;&#125; 以上在tabItem中使用Image和Text的组合,不如可以使用Label,比如: 12345678// 其他代码省略TabView &#123;Color.red .tabItem &#123; Label(&quot;Hello&quot;, systemImage: &quot;star&quot;) &#125; .badge(&quot;New&quot;) // 以下代码略... Badge在List上使用,会自动在list的右侧使用secondary颜色来显示: 1234567List &#123; Text(&quot;Wi-Fi&quot;) .badge(&quot;LAN Solo&quot;) Text(&quot;Bluetooth&quot;) .badge(&quot;On&quot;)&#125; @FocusState 的使用 (让TextField受到focused)12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct FocusStateBootcamp: View &#123; // @FocusState不需要赋值,下面的TextField的.focused会自动改变值 @FocusState private var usernameInFocus: Bool @State private var username: String = &quot;&quot; @FocusState private var passwordInFocus: Bool @State private var password: String = &quot;&quot; var body: some View &#123; VStack(spacing: 30) &#123; TextField(&quot;Add your name here ...&quot;, text: $username) .focused($usernameInFocus) .padding(.leading) .frame(height: 55) .frame(maxWidth: .infinity) .background(Color.gray.brightness(0.3)) .cornerRadius(10) SecureField(&quot;Add your password here ...&quot;, text: $password) .focused($passwordInFocus) .padding(.leading) .frame(height: 55) .frame(maxWidth: .infinity) .background(Color.gray.brightness(0.3)) .cornerRadius(10) Button(&quot;Sign Up 🚀&quot;) &#123; let usernameIsValid = !username.isEmpty let passwordIsValid = !password.isEmpty if usernameIsValid &amp;&amp; passwordIsValid &#123; print(&quot;Sign Up&quot;) &#125; else if usernameIsValid &#123; usernameInFocus = false passwordInFocus = true &#125; else &#123; usernameInFocus = true passwordInFocus = false &#125; &#125; &#125; .padding() .onAppear &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) &#123; self.usernameInFocus = true &#125; &#125; &#125;&#125; 上面的代码设置太多@FocusState,所以用enum来简洁代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct FocusStateBootcamp: View &#123; // 新增 // 为什么要符合Hashable,因为下面.focused的参数binding要求 enum OnboardingFields: Hashable &#123; case username, password &#125; // @FocusState private var usernameInFocus: Bool @State private var username: String = &quot;&quot; //@FocusState private var passwordInFocus: Bool @State private var password: String = &quot;&quot; // 新增 @FocusState private var fieldInFocus: OnboardingFields? var body: some View &#123; VStack(spacing: 30) &#123; TextField(&quot;Add your name here ...&quot;, text: $username) // .focused($usernameInFocus) // .focused(&lt;#T##binding: FocusState&lt;Hashable&gt;.Binding##FocusState&lt;Hashable&gt;.Binding#&gt;, equals: &lt;#T##Hashable#&gt;) .focused($fieldInFocus, equals: .username) .padding(.leading) .frame(height: 55) .frame(maxWidth: .infinity) .background(Color.gray.brightness(0.3)) .cornerRadius(10) SecureField(&quot;Add your password here ...&quot;, text: $password) // .focused($passwordInFocus) .focused($fieldInFocus, equals: .password) .padding(.leading) .frame(height: 55) .frame(maxWidth: .infinity) .background(Color.gray.brightness(0.3)) .cornerRadius(10) Button(&quot;Sign Up 🚀&quot;) &#123; let usernameIsValid = !username.isEmpty let passwordIsValid = !password.isEmpty if usernameIsValid &amp;&amp; passwordIsValid &#123; print(&quot;Sign Up&quot;) &#125; else if usernameIsValid &#123; // usernameInFocus = false // passwordInFocus = true fieldInFocus = .password &#125; else &#123; // usernameInFocus = true // passwordInFocus = false fieldInFocus = .username &#125; &#125; &#125; .padding() .onAppear &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) &#123; // self.usernameInFocus = true self.fieldInFocus = .username &#125; &#125; &#125;&#125; .onSubmit &#x2F; .submitLabel 给TextField的修饰符使用TextField并focused时候,跳出的键盘右下角就会出现对应的search&#x2F;next&#x2F;route字样:（还有很多其他的可以显示） 1234567891011121314VStack &#123; TextField(&quot;Placeholder...&quot;, text: $text1) // 手机上跳出的键盘的右下角显示&quot;路线&quot; .submitLabel(.route) .onSubmit &#123; print(&quot;Something to the console!&quot;) &#125; TextField(&quot;Placeholder...&quot;, text: $text1) // 手机上跳出的键盘的右下角显示&quot;下一项&quot; .submitLabel(.next) .onSubmit &#123; print(&quot;Something to the console!&quot;) &#125; TextField(&quot;Placeholder...&quot;, text: $text1) // 手机上跳出的键盘的右下角显示&quot;搜索&quot; .submitLabel(.search) .onSubmit &#123; print(&quot;Something to the console!&quot;) &#125;&#125; 这里出现的.submitLabel(),可以将之前默认的”return”显示成”search”,还可以是”continue”&#x2F;“done”&#x2F;“go”&#x2F;“join”&#x2F;“next”&#x2F;“return”&#x2F;“route”&#x2F;“search”&#x2F;“send”. textField &amp; .focused &amp; .submitLabel – 让表单输入更顺畅三个textField,键盘上按Next的时候,会自动跳到下一个,看一下实现的原理:使用到了.focus(item::…).submitLabel(.next)和.submitLabel(.join)貌似没有用处啊。 1234567891011121314151617181920212223242526272829303132333435363738394041struct ContentView: View &#123; enum Field &#123; case firstName case lastName case emailAddress &#125; @State private var firstName = &quot;&quot; @State private var lastName = &quot;&quot; @State private var emailAddress = &quot;&quot; @FocusState private var focusedField: Field? var body: some View &#123; VStack &#123; TextField(&quot;Enter your first name&quot;, text: $firstName) .focused($focusedField, equals: .firstName) .textContentType(.givenName) .submitLabel(.next) TextField(&quot;Enter your last name&quot;, text: $lastName) .focused($focusedField, equals: .lastName) .textContentType(.familyName) .submitLabel(.next) TextField(&quot;Enter your email address&quot;, text: $emailAddress) .focused($focusedField, equals: .emailAddress) .textContentType(.emailAddress) .submitLabel(.join) &#125; .onSubmit &#123; switch focusedField &#123; case .firstName: focusedField = .lastName case .lastName: focusedField = .emailAddress default: print(&quot;Creating account…&quot;) &#125; &#125; &#125;&#125; 使用AVFoudation模块的AVPlayer播放声音文件 具体使用示例在官方教程中：https://developer.apple.com/tutorials/app-dev-training/managing-state-and-life-cycle 1234567891011121314151617import AVFoundation// 假设声音文件是ding.wavlet url = Bundle.main.url(forResource: &quot;ding&quot;, withExtension: &quot;wav&quot;)// 定义player变量var player: AVPlayer &#123; AVPlayer(url: url) &#125;// 在View中使用player// 比如在一个ZStack中ZStack &#123;&#125; // 在ZStack出现时 .onAppear &#123; // 设置从头开始播放 player.seek(to: .zero) // 开始播放 player.play() &#125; as 的使用as是个操作符作用：将派生类转换为基类。 1234// 这里将int类型的number转换成了Float类型// 但不能将 number: Int 事先定义类型,会报错var number = 1 as Floatprint(number) 1.0 FileManager 的使用 https://blog.csdn.net/u011146511/article/details/79362028 获取用户文档目录路径FileManager.default.urls(for:in:)其中for是一个enum,可以查看下,有专门给movie、books、pictures等等很多进行储存的目录等。此外in也是一个enum,最多用到的就是.userDomainMask 12345678import Foundationlet manager = FileManager.defaultlet urlForDocument = manager.urls(for: .documentDirectory, in:.userDomainMask)print(urlForDocument)let url = urlForDocument[0] as URLprint(url)print(url.path) [file:&#x2F;&#x2F;&#x2F;Users&#x2F;vito&#x2F;Library&#x2F;Developer&#x2F;XCPGDevices&#x2F;xxxxxxxxxxxxxxxxx&#x2F;yyyyyyyyyyyyyyyy&#x2F;Documents&#x2F;]file:&#x2F;&#x2F;&#x2F;Users&#x2F;vito&#x2F;Library&#x2F;Developer&#x2F;XCPGDevices&#x2F;xxxxxxxxxxxxxxxxx&#x2F;yyyyyyyyyyyyyyyy&#x2F;Documents&#x2F;&#x2F;Users&#x2F;vito&#x2F;Library&#x2F;Developer&#x2F;XCPGDevices&#x2F;xxxxxxxxxxxxxxxxx&#x2F;yyyyyyyyyyyyyyyy&#x2F;Documents&#x2F; 对指定路径执行浅搜索，返回指定目录路径下的文件、子目录及符号链接的列表123// 代码接着上面的let contentsOfPath = try? manager.contentsOfDirectory(atPath: url.path)print(&quot;contentsOfPath: \\(contentsOfPath)&quot;) contentsOfPath: Optional([]) 结果是个Optional的空列表，说明该目录内为空，没有文件、目录等。 深度遍历,递归遍历子文件夹123let enumeratorAtPath = manager.enumerator(atPath: url.path)// let enumeratorAtURL = manager.enumerator(at: url, includingPropertiesForKeys: nil,options: .skipsHiddenFiles, errorHandler:nil)print(&quot;enumeratorAtPath: \\(enumeratorAtPath?.allObjects)&quot;) enumeratorAtPath: Optional([]) 深度遍历，会递归遍历子文件夹（包括符号链接，所以要求性能的话用enumeratorAtPath）12let subPaths = manager.subpaths(atPath: url.path)print(&quot;subPaths: \\(subPaths)&quot;) 通过FileManager在本地建立文件夹并存储文件,以及对应的删除文件夹和文件下面的例子类似于放入缓存中的NSCache,只是这里是存入用户的文件系统中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222import SwiftUIclass LocalFileManager &#123; static let instance = LocalFileManager() let folderName: String = &quot;MyApp_Images&quot; init() &#123; createFolderIfNeeded() &#125; func createFolderIfNeeded() &#123; guard let path = FileManager .default .urls(for: .cachesDirectory, in: .userDomainMask) .first? .appendingPathComponent(folderName) .path else &#123; return &#125; if !FileManager.default.fileExists(atPath: path) &#123; do &#123; try FileManager.default.createDirectory(atPath: URL(string:path)!, withIntermediateDirectories: true, attributes: nil) print(&quot;Successfully creating folder.&quot;) &#125; catch let error &#123; print(&quot;Error creating folder. \\(error)&quot;) &#125; &#125; &#125; func deleteFolder() &#123; guard let path = FileManager .default .urls(for: .cachesDirectory, in: .userDomainMask) .first? .appendingPathComponent(folderName) .path else &#123; return &#125; do &#123; try FileManager.default.removeItem(atPath: path) print(&quot;Successfully deletinging folder.&quot;) &#125; catch let error &#123; print(&quot;Error deleting folder. \\(error)&quot;) &#125; &#125; func saveImage(image: UIImage, savedFileName: String) -&gt; String &#123; // 储存图片,总结下来就是: // 1.UIImageWriteToSavedPhotosAlbum()存到用户的图片库 // 2.存到程序的磁盘空间内: // a.将UIImage图像转换成Data // b.调用jpegData() // 具体如下: /* if let jpegData = yourUIImage.jpegData(compressionQuality: 0.8) &#123; try? jpegData.write(to: yourURL, options: [.atomic, .completeFileProtection]) &#125; */ guard // image.pngData也是有的 // compressionQuality是压缩比例 let data = image.jpegData(compressionQuality: 1.0), let path = getPathForImage(name: savedFileName) else &#123; return &quot;Error Getting Data.&quot; &#125; // 存储数据 // data.write(to: URL) do &#123; try data.write(to: path) return &quot;Successful saving.&quot; &#125; catch let error &#123; return &quot;Error saving. \\(error)&quot; &#125; &#125; func getImage(name: String) -&gt; UIImage? &#123; guard let path = getPathForImage(name: name)?.path, FileManager.default.fileExists(atPath: path) else &#123; return nil &#125; return UIImage(contentsOfFile: path) &#125; func getPathForImage(name: String) -&gt; URL? &#123; // let directory = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first // let path = directory?.appendingPathComponent(&quot;\\(savedFileName).jpg&quot;) guard let path = FileManager .default .urls(for: .cachesDirectory, in: .userDomainMask) .first? .appendingPathComponent(folderName) .appendingPathComponent(&quot;\\(name).jpg&quot;) else &#123; print(&quot;Error getting path.&quot;) return nil &#125; return path &#125; func deleteImage(name: String) -&gt; String &#123; guard let path = getPathForImage(name: name), FileManager.default.fileExists(atPath: path.path) else &#123; return &quot;Error getting path.&quot; &#125; do &#123; try FileManager.default.removeItem(at: path) return &quot;Successfully deleted.&quot; &#125; catch let error &#123; return &quot;Error deleting image. \\(error)&quot; &#125; &#125; &#125;class FileManagerViewModel: ObservableObject &#123; // 需要在各个class或struct中移动的时候, // Image的数据移动起来相对比较麻烦, // 而UIImage相对容易, // 所以推荐UIImage作为背景等时,当要作为数据处理的情况. @Published var image: UIImage? = nil let imageName: String = &quot;threemonths&quot; let manager = LocalFileManager.instance @Published var infoMessage: String = &quot;&quot; init() &#123; getImageFromAssetsFolder() getImageFromFileManager() &#125; func getImageFromAssetsFolder() &#123; image = UIImage(named: imageName) &#125; func getImageFromFileManager() &#123; image = manager.getImage(name: imageName) &#125; func saveImage() &#123; guard let image = image else &#123; return &#125; infoMessage = manager.saveImage(image: image, savedFileName: imageName) &#125; func deleteImage() &#123; infoMessage = manager.deleteImage(name: imageName) manager.deleteFolder() &#125; &#125;struct FileManagerBootcamp: View &#123; @StateObject var vm = FileManagerViewModel() var body: some View &#123; NavigationView &#123; VStack &#123; if let image = vm.image &#123; Image(uiImage: image) .resizable() .scaledToFill() .frame(width: 350, height: 500) .clipped() .cornerRadius(10) &#125; HStack &#123; Button &#123; vm.saveImage() &#125; label: &#123; Text(&quot;Save to FileManager&quot;) .foregroundColor(.white) .font(.headline) .padding() .padding(.horizontal) .background(Color.blue) .cornerRadius(10) &#125; Button &#123; vm.deleteImage() &#125; label: &#123; Text(&quot;Delete from FileManager&quot;) .foregroundColor(.white) .font(.headline) .padding() .padding(.horizontal) .background(Color.red.opacity(0.7)) .cornerRadius(10) &#125; &#125; Text(vm.infoMessage) .font(.largeTitle) .fontWeight(.semibold) .foregroundColor(.purple) Spacer() &#125; .navigationTitle(&quot;File Manager&quot;) &#125; &#125;&#125; UIImageWriteToSavedPhotosAlbum()存到用户的图片库12345678910111213141516171819import UIKitclass ImageSaver: NSObject &#123; var successHandler: (() -&gt; Void)? var errorHandler: ((Error) -&gt; Void)? func writeToPhotoAlbum(image: UIImage) &#123; UIImageWriteToSavedPhotosAlbum(image, self, #selector(saveCompleted), nil) &#125; // @objc 是使用到object-c的代码,为了正常被swift编译而需要加的 @objc func saveCompleted(_ image: UIImage, didFinishSavingWithError error: Error?, contextInfo: UnsafeRawPointer) &#123; if let error = error &#123; errorHandler?(error) &#125; else &#123; successHandler?() &#125; &#125;&#125; 记得需要用户授权:在 Targets 的 Info 中添加“Privacy - Photo Library Additions Usage Description”,值可以写做”We want to save the filtered photo.” write(to:atomically:encoding) 写入文件write(to:atomically:encoding) 有三个参数: A url to write to Whether to make the write atomic, which means “all at once”.原子写入,若文件较大,一般都会选择true。 What character encoding to use. 123456789101112131415161718192021func getDocumentsDirectory() -&gt; URL &#123; // find all possible documents directories for this user let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask) // just send back the first one, which ought to be the only one return paths[0]&#125;Text(&quot;Hello World&quot;) .onTapGesture &#123; let str = &quot;Test Message&quot; let url = getDocumentsDirectory().appendingPathComponent(&quot;message.txt&quot;) do &#123; try str.write(to: url, atomically: true, encoding: .utf8) let input = try String(contentsOf: url) print(input) &#125; catch &#123; print(error.localizedDescription) &#125; &#125; Atomic Writing:Atomic writing causes the system to write our full file to a temporary filename (not the one we asked for), and when that’s finished it does a simple rename to our target filename. This means either the whole file is there or nothing is.就是原子写入的时候,是完全写入一个临时文件,然后改名成目标文件。需要注意的一点是,要么文件在,要么文件不存在。这就能保证文件不会出错了,就不会被其他人写入了。 write(to: &lt;#T##URL#&gt;, options: &lt;#T##Data.WritingOptions#&gt;)123456789101112131415// init()do &#123; let data = try Data(contentsOf: savePath) locations = try JSONDecoder().decode([Location].self, from: data)&#125; catch &#123; locations = []&#125;// func save()do &#123; let data = try JSONEncoder().encode(locations) try data.write(to: savePath, options: [.atomic, .completeFileProtection])&#125; catch &#123; print(&quot;Unable to save data.&quot;)&#125; 感觉用Data的write来写入结构化后的文件，可能更好一点。Yes, all it takes to ensure that the file is stored with strong encryption is to add .completeFileProtection to the data writing options.Using this approach we can write any amount of data in any number of files – it’s much more flexible than UserDefaults, and also allows us to load and save data as needed rather than immediately when the app launches as with UserDefaults. NSCache – 缓存存储很多时候,取得的数据不需要存入手机,而只是需要放入缓存中。 下面的例子,类似于FileManager存储image的结构类型,只是存入缓存中: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import SwiftUIclass CacheManager &#123; static let instance = CacheManager() private init() &#123;&#125; // var imageCache: NSCache&lt;AnyObject, AnyObject&gt; // 把NSCache想像成key/value的结构, // key一般是String,但这里得是个Object,String是一个Struct, // 而NSString是一个class类,故此处不能单单使用String. // 至于转换, &quot;Hello&quot; as NSString 即完成了将String转换成NSString. var imageCache: NSCache&lt;NSString, UIImage&gt; = &#123; let cache = NSCache&lt;NSString, UIImage&gt;() // cache.countLimit 是指NSCache中Object的最多数量 cache.countLimit = 100 // cache.totalCostLimit 是指NSCache的容量限制 cache.totalCostLimit = 1024 * 1024 * 100 // 100Mb return cache &#125;() // 添加 func add(image: UIImage, name: String) -&gt; String &#123; // name根据imageCache设定的必须是NSString,而不是String imageCache.setObject(image, forKey: name as NSString) return &quot;Add to Cache&quot; &#125; func remove(name: String) -&gt; String&#123; imageCache.removeObject(forKey: name as NSString) return &quot;Remove from Cache&quot; &#125; func get(name: String) -&gt; UIImage? &#123; return imageCache.object(forKey: name as NSString) &#125; &#125;class CacheViewModel: ObservableObject &#123; @Published var startImage: UIImage? = nil @Published var cachedImage: UIImage? = nil @Published var infoMessage: String = &quot;&quot; let imageName: String = &quot;threemonths&quot; let manager = CacheManager.instance init() &#123; getImagesFromAssetsFolder() &#125; func getImagesFromAssetsFolder() &#123; startImage = UIImage(named: imageName) &#125; func saveToCache() &#123; guard let startImage = startImage else &#123; return &#125; infoMessage = manager.add(image: startImage, name: imageName) &#125; func removeFromCache() &#123; infoMessage = manager.remove(name: imageName) &#125; func getFromCache() &#123; if let returnedImage = manager.get(name: imageName) &#123; cachedImage = returnedImage infoMessage = &quot;Got image from Cache&quot; &#125; else &#123; infoMessage = &quot;Image not found from Cache&quot; &#125; &#125; &#125;struct CacheBootcamp: View &#123; @StateObject var vm = CacheViewModel() var body: some View &#123; NavigationView &#123; VStack &#123; if let image = vm.startImage &#123; Image(uiImage: image) .resizable() .scaledToFill() .frame(width: 200, height: 250) .clipped() .cornerRadius(10) &#125; Text(vm.infoMessage) .font(.headline) .foregroundColor(.purple) .frame(height:30) HStack &#123; Button &#123; vm.saveToCache() &#125; label: &#123; Text(&quot;Save to Cache&quot;) .font(.headline) .foregroundColor(.white) .padding() .background(Color.blue) .cornerRadius(10) &#125; Button &#123; vm.removeFromCache() &#125; label: &#123; Text(&quot;Delete from Cache&quot;) .font(.headline) .foregroundColor(.white) .padding() .background(Color.red) .cornerRadius(10) &#125; &#125; Button &#123; vm.getFromCache() &#125; label: &#123; Text(&quot;get from Cache&quot;) .font(.headline) .foregroundColor(.white) .padding() .background(Color.green) .cornerRadius(10) &#125; if let image = vm.cachedImage &#123; Image(uiImage: image) .resizable() .scaledToFill() .frame(width: 200, height: 250) .clipped() .cornerRadius(10) &#125; Spacer() &#125; .navigationTitle(&quot;Cache&quot;) &#125; &#125;&#125; 自定义View的Modifier,并进行调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546import SwiftUI// 自定义modifier 需要遵循 ViewModifier协议// 并且在func body(content: Content) -&gt; some View 中定义具体的修饰struct DefaultButtonViewModifier: ViewModifier &#123; let backgroundColor: Color func body(content: Content) -&gt; some View &#123; content .foregroundColor(.white) .frame(height: 55) .frame(maxWidth: .infinity) .background(backgroundColor) .cornerRadius(10) .shadow(radius: 10) &#125;&#125;// 这是调用上述DefalutButtonViewModifier结构的方法的View的扩展// 实际是为了让View方便调用才写的extension View &#123; func withDefaultButtonFormatting(backgroundColor: Color = .blue) -&gt; some View &#123; // 此处省略了 // self. modifier(DefaultButtonViewModifier(backgroundColor: backgroundColor)) &#125;&#125;struct ContentView: View &#123; var body: some View &#123; VStack(spacing: 10) &#123; // 下面两种不同的调用自定义modifier的方式 Text(&quot;Hello, my world!&quot;) .font(.headline) .withDefaultButtonFormatting() Text(&quot;Hello, my world!&quot;) .font(.subheadline) .modifier(DefaultButtonViewModifier(backgroundColor: .green)) Text(&quot;Hello, my world!&quot;) .font(.title) .withDefaultButtonFormatting(backgroundColor: .yellow) &#125; .padding() &#125;&#125; 为Button自定义样式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import SwiftUIstruct PressableButtonStyle: ButtonStyle &#123; let scaledAmount: CGFloat init(scaledAmount: CGFloat) &#123; self.scaledAmount = scaledAmount &#125; func makeBody(configuration: Configuration) -&gt; some View &#123; // configuration可以使用到 // configuration.isPressed 代表button被按下 // configuration.label是用来调整button的label的 configuration.label .scaleEffect(configuration.isPressed ? scaledAmount : 1.0) .opacity(configuration.isPressed ? 0.9 : 1.0) .brightness(configuration.isPressed ? 0.5 : 0) &#125;&#125;extension View &#123; func withPressableStyle(scaledAmount: CGFloat = 0.9) -&gt; some View &#123; self.buttonStyle(PressableButtonStyle(scaledAmount:scaledAmount)) &#125; &#125;struct Test0004: View &#123; var body: some View &#123; Button(action: &#123; &#125;,label: &#123; Text(&quot;Click Me&quot;) .font(.headline) .foregroundColor(.white) .frame(height: 55) .frame(maxWidth: .infinity) .background(Color.blue) .cornerRadius(10) .shadow(color: Color.blue.opacity(0.3), radius: 10, x: 0.0, y: 10) &#125;) // 以下样式都是自带的 // .buttonStyle(PlainButtonStyle()) // .buttonStyle(DefaultButtonStyle()) //使用自定义样式 // .buttonStyle(PressableButtonStyle(scaledAmount: 0.9)) // 建议这样调用,因为上面写了调用的方法 .withPressableStyle(scaledAmount: 1.2) .padding(40) &#125;&#125; transition一般用法:.transition(.scale)即让尺寸大小的变化有一个过渡。 一般案例 – 需要配合withAnimation等进行实现123456789101112131415161718192021222324252627struct ContentView: View &#123; @State private var showDetails = false var body: some View &#123; VStack &#123; Button(&quot;Press to show details&quot;) &#123; withAnimation &#123; showDetails.toggle() &#125; &#125; if showDetails &#123; // Moves in from the bottom Text(&quot;Details go here.&quot;) .transition(.move(edge: .bottom)) // Moves in from leading out, out to trailing edge. Text(&quot;Details go here.&quot;) .transition(.slide) // Starts small and grows to full size. Text(&quot;Details go here.&quot;) .transition(.scale) &#125; &#125; &#125;&#125; 记得,withAnimation是确定有动画会出现,而每个view定义的transition这个midifier是确定以什么样的动画实现。 combined(with:) – method - combine transitions呈现连续的动画的功能: 12345678910111213141516171819struct ContentView: View &#123; @State private var showDetails = false var body: some View &#123; VStack &#123; Button(&quot;Press to show details&quot;) &#123; withAnimation &#123; showDetails.toggle() &#125; &#125; if showDetails &#123; Text(&quot;Details go here.&quot;) .transition(AnyTransition.opacity.combined(with: .slide)) &#125; &#125; &#125;&#125; 也可以事先写好modifier,以后批量使用: 123456789101112131415161718192021222324extension AnyTransition &#123; static var moveAndScale: AnyTransition &#123; AnyTransition.move(edge: .bottom).combined(with: .scale) &#125;&#125;struct ContentView: View &#123; @State private var showDetails = false var body: some View &#123; VStack &#123; Button(&quot;Press to show details&quot;) &#123; withAnimation &#123; showDetails.toggle() &#125; &#125; if showDetails &#123; Text(&quot;Details go here.&quot;) .transition(.moveAndScale) &#125; &#125; &#125;&#125; .asymmetric.asymmetric lets us use one transition when the view is being shown and another when it’s disappearing. 1.transition(.asymmetric(insertion: .scale, removal: .opacity)) 即在进入的时候以尺寸变化为过渡,而在不显示的时候通过显示透明度消失的方式。例子: 123456789101112131415161718struct ContentView: View &#123; @State private var showDetails = false var body: some View &#123; VStack &#123; Button(&quot;Press to show details&quot;) &#123; withAnimation &#123; showDetails.toggle() &#125; &#125; if showDetails &#123; Text(&quot;Details go here.&quot;) .transition(.asymmetric(insertion: .move(edge: .leading), removal: .move(edge: .bottom))) &#125; &#125; &#125;&#125; 建立自定义Transition具体定义是: 123456extension AnyTransition &#123; /// Returns a transition defined between an active modifier and an identity /// modifier. public static func modifier&lt;E&gt;(active: E, identity: E) -&gt; AnyTransition where E : ViewModifier&#125; 具体实例一: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import SwiftUIstruct CornerRotateModifier: ViewModifier &#123; let amount: Double let anchor: UnitPoint func body(content: Content) -&gt; some View &#123; content .rotationEffect(.degrees(amount), anchor: anchor) // .clipped()是以防绕出整体范围的时候进行一个切割 .clipped() &#125;&#125;extension AnyTransition &#123; static var pivot: AnyTransition &#123; // 初始状态是绕着支点逆时针旋转90度,最后状态是顺时针旋转90度绕回原点 .modifier(active: CornerRotateModifier(amount: -90, anchor: .topLeading), identity: CornerRotateModifier(amount: 0, anchor: .topLeading)) &#125;&#125;struct Transitions: View &#123; @State private var isShowingRed = false var body: some View &#123; ZStack &#123; // 蓝色在红色的下方,但红色因为逆时针旋转出区域又经过.clipped()切割,所以一开始看不到, // isShowingRed转变为true时,红色区域顺时针旋转回来时,能看到红色区域旋转并覆盖蓝色区域。 Rectangle() .fill(.blue) .frame(width: 200, height: 200) if isShowingRed &#123; Rectangle() .fill(.red) .frame(width: 200, height: 200) .transition(.pivot) &#125; &#125; .onTapGesture &#123; withAnimation &#123; isShowingRed.toggle() &#125; &#125; &#125;&#125; 具体实例二: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100struct RotateViewModifier: ViewModifier &#123; let rotation: Double func body(content: Content) -&gt; some View &#123; content .rotationEffect(Angle(degrees: rotation)) // 当showRectangle变为true的时候,content出现, // 则content的位移offset就是(x:0,y:0); // 当showRectangle变为false的时候,content离开画面, // 而且content的位移offset就是(x:屏幕宽度,y:屏幕高度); // 若下面设置成UIScreen.main.bounds.width/5的时候， // 你就会发现content在x和y上位移了一点点,随后全部消失 .offset( x: rotation != 0 ? UIScreen.main.bounds.width : 0, y: rotation != 0 ? UIScreen.main.bounds.height : 0 ) &#125;&#125;extension AnyTransition &#123; // 虽然都是rotating,但调用的时候提示是V,代表是Variable static var rotating: AnyTransition &#123; // .modifier(active:开始, identity:结束) // 当content出现的时候, // 是从RotateViewModifier(rotation: 1080) [即&lt;-content旋转1080度], // 变化到RotateViewModifier(rotation: 0)[即&lt;-content旋转0度]的。 // 另外观察下来, // 当content离开的时候, // 是从RotateViewModifier(rotation: 0) // 变化到RotateViewModifier(rotation: 90), // 理解下来就是逆向的一个动画过程。 return AnyTransition.modifier( active: RotateViewModifier(rotation: 1080), identity: RotateViewModifier(rotation: 0) ) &#125; // 虽然都是rotating,但调用的时候提示下面是M,代表是Method static func rotating(rotation: Double) -&gt; AnyTransition &#123; return AnyTransition.modifier( active: RotateViewModifier(rotation: 1080), identity: RotateViewModifier(rotation: 0)) &#125; // 你会发现,content是从右下角出现的,因为设置的offset, // (教程演示是这样,但实际却是直接出现,神奇，哪里的问题？) // 但离开并不按照offset设置的向右下角消失, // 而是向.leading方向消失的。 // 注:asymmetric是不对称的意思。 static var rotateOn: AnyTransition &#123; return AnyTransition.asymmetric( insertion: .rotating, removal: .move(edge: .leading)) &#125; &#125;struct Test0005: View &#123; @State private var showRectangle: Bool = false var body: some View &#123; VStack &#123; Spacer() if showRectangle &#123; RoundedRectangle(cornerRadius: 25) .frame(width: 250, height:350) // 为什么.frame(maxWidth:maxHeight:)会把下面的按钮往下推？ .frame(maxWidth: .infinity, maxHeight: .infinity) // .modifier(RotateViewModifier(rotation: 45)) .transition(AnyTransition.rotating.animation(.easeInOut(duration: 5.0))) // 调用上面写的rotating方法,好处是还可以传参 // .transition(AnyTransition.rotating(rotation: 1080).animation(.easeInOut(duration: 5.0))) // 调用上面写的rotateOn属性 // .transition(AnyTransition.rotateOn) &#125;else&#123; RoundedRectangle(cornerRadius: 25) .frame(width: 250, height:350) .opacity(0.2) .transition(AnyTransition.rotating.animation(.easeInOut(duration: 5.0))) &#125; Text(&quot;Click Me&quot;) .withDefaultButtonFormatting(backgroundColor: .gray) .padding(.horizontal, 40) .onTapGesture &#123; withAnimation(.easeInOut(duration: 5.0)) &#123; showRectangle.toggle() &#125; &#125; Spacer() &#125; &#125;&#125; gesture – modifierSwiftUI提供了一系列的手势支持，比如 TapGesture, DragGesture, RotationGesture, MagnificationGesture, LongPressGesture等。 onTapGesture() &amp;&amp; count设定点击次数才会执行的情况: 1234Text(&quot;Hello, World!&quot;) .onTapGesture(count: 2) &#123; print(&quot;Double tapped!&quot;) &#125; allowsHitTesting() modifier.让View等捕获不到任何taps 适用场景:比如一个计时回答竞赛的软件,计时器归零后,用户再点击是不会给任何反应的,这时候就可以给这个使用这个allowsHitTesting(false)。 12345678910111213141516ZStack &#123; Rectangle() .fill(.blue) .frame(width: 300, height: 300) .onTapGesture &#123; print(&quot;Rectangle tapped!&quot;) &#125; Circle() .fill(.red) .frame(width: 300, height: 300) .onTapGesture &#123; print(&quot;Circle tapped!&quot;) &#125; .allowsHitTesting(false)&#125; 没有.allowsHitTesting(false)的时候,之前点在圆上面,就显示圆被点击了,而点击在圆以外正方形上面,就显示正方形被点击了。若有.allowsHitTesting(false)的时候,点击在圆上面还是正方形上面,都显示正方形被点击了。 DragGesture – 拖动的手势12345678910111213141516// 效果: 可拖动,但拖动完,仍会回到原始位置。@State private var dragAmount: CGSize = CGSize.zeroLinearGradient(gradient: Gradient(colors: [.yellow, .red]), startPoint: .topLeading, endPoint: .bottomTrailing) .frame(width:300, height: 200) .clipShape(RoundedRectangle(cornerRadius: 10)) .offset(dragAmount) .gesture( DragGesture() .onChanged(&#123; dragAmount = $0.translation &#125;) .onEnded(&#123;_ in dragAmount = .zero &#125;) ) .onLongPressGesture.onTapGesture 按下即执行,而.onLongPressGesture是对按下有时间和偏移量均有一定的要求: .onLongPressGesture(minimumDuration: &lt;#T##Double#&gt;, maximumDistance: &lt;#T##CGFloat#&gt;, perform: &lt;#T##() -&gt; Void#&gt;, onPressingChanged: &lt;#T##((Bool) -&gt; Void)?##((Bool) -&gt; Void)?##(Bool) -&gt; Void#&gt;) minimumDuration 指至少按住多少时间才生效maximumDistance 指最多位移多少范围才有效,不然认为是撤销操作onPressingChanged 指一旦按下即会进行的操作(给了个判断是否按下的Bool参数)perform 指超过minimumDuration,且未超过maximumDistance，的情况下,会进行的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct LongPressGestureBootcamp: View &#123; @State var isComplete: Bool = false @State var isSuccess: Bool = false var body: some View &#123; VStack &#123; Rectangle() .fill(isSuccess ? Color.green : Color.blue) .frame(maxWidth: isComplete ? .infinity : 0) .frame(height: 55) .frame(maxWidth: .infinity, alignment: .leading) .background(Color.gray) HStack &#123; Text(&quot;Click Here&quot;) .foregroundColor(.white) .padding() .background(Color.black) .cornerRadius(10) .onLongPressGesture(minimumDuration: 1.0, maximumDistance: 50) &#123; withAnimation(.easeInOut) &#123; isSuccess = true &#125; &#125; onPressingChanged: &#123; isPressing in // 注意onPressingChanged提供的参数, // 这里取名为isPressing, // 当按下时为true, // 当松开时为false if isPressing &#123; withAnimation(.easeInOut(duration: 1.0)) &#123; isComplete = true &#125; &#125; else &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) &#123; if !isSuccess &#123; withAnimation(.easeInOut) &#123; isComplete = false &#125; &#125; &#125; &#125; &#125; Text(&quot;Reset&quot;) .foregroundColor(.white) .padding() .background(Color.black) .cornerRadius(10) .onTapGesture &#123; isSuccess = false isComplete = false &#125; &#125; &#125; &#125;&#125; 效果是:按下即会有反应,有类似进度条的显示,若超过一秒,且偏移量未超过50,则生效,否则,会回到初始状态。 MagnificationGesture将目标放大的手势: 12345678910111213141516171819struct ContentView: View &#123; @State private var currentAmount = 0.0 @State private var finalAmount = 1.0 var body: some View &#123; Text(&quot;Hello, World!&quot;) .scaleEffect(finalAmount + currentAmount) .gesture( MagnificationGesture() .onChanged &#123; amount in currentAmount = amount - 1 &#125; .onEnded &#123; amount in finalAmount += currentAmount currentAmount = 0 &#125; ) &#125;&#125; RotationGesture将目标旋转的手势: 12345678910111213141516171819struct ContentView: View &#123; @State private var currentAmount = Angle.zero @State private var finalAmount = Angle.zero var body: some View &#123; Text(&quot;Hello, World!&quot;) .rotationEffect(currentAmount + finalAmount) .gesture( RotationGesture() .onChanged &#123; angle in currentAmount = angle &#125; .onEnded &#123; angle in finalAmount += currentAmount currentAmount = .zero &#125; ) &#125;&#125; highPriorityGesture()将某个手势设置为有更改优先权 以下代码只会打印”Text tapped”,而不打印”VStack tapped”,这是因为the child’s gesture priority。 12345678910111213struct ContentView: View &#123; var body: some View &#123; VStack &#123; Text(&quot;Hello, World!&quot;) .onTapGesture &#123; print(&quot;Text tapped&quot;) &#125; &#125; .onTapGesture &#123; print(&quot;VStack tapped&quot;) &#125; &#125;&#125; 如何改变这种情况,只打印”VStack tapped”？就要使用到highPriorityGesture(): 12345678910111213141516struct ContentView: View &#123; var body: some View &#123; VStack &#123; Text(&quot;Hello, World!&quot;) .onTapGesture &#123; print(&quot;Text tapped&quot;) &#125; &#125; .highPriorityGesture( TapGesture() .onEnded &#123; _ in print(&quot;VStack tapped&quot;) &#125; ) &#125;&#125; simultaneousGesture()同时响应的手势: 12345678910111213141516struct ContentView: View &#123; var body: some View &#123; VStack &#123; Text(&quot;Hello, World!&quot;) .onTapGesture &#123; print(&quot;Text tapped&quot;) &#125; &#125; .simultaneousGesture( TapGesture() .onEnded &#123; _ in print(&quot;VStack tapped&quot;) &#125; ) &#125;&#125; 同时打印”VStack tapped”和”Text tapped”,但有先后次序。 组合手势这下面的手势是先长按才能拖动的手势: 1234567891011121314151617181920212223242526272829303132333435363738struct ContentView: View &#123; // how far the circle has been dragged @State private var offset = CGSize.zero // whether it is currently being dragged or not @State private var isDragging = false var body: some View &#123; // a drag gesture that updates offset and isDragging as it moves around let dragGesture = DragGesture() .onChanged &#123; value in offset = value.translation &#125; .onEnded &#123; _ in withAnimation &#123; offset = .zero isDragging = false &#125; &#125; // a long press gesture that enables isDragging let pressGesture = LongPressGesture() .onEnded &#123; value in withAnimation &#123; isDragging = true &#125; &#125; // a combined gesture that forces the user to long press then drag let combined = pressGesture.sequenced(before: dragGesture) // a 64x64 circle that scales up when it&#x27;s dragged, sets its offset to whatever we had back from the drag gesture, and uses our combined gesture Circle() .fill(.red) .frame(width: 64, height: 64) .scaleEffect(isDragging ? 1.5 : 1) .offset(offset) .gesture(combined) &#125;&#125; 以上,觉得比较奇怪的地方是:View内竟然有些关于Gesture的代码,而不是写在View的外面.这里比较重要的代码是:let combined &#x3D; pressGesture.sequenced(before: dragGesture)让pressGesture生成的次序在dragGesture之前,就是只能先长按,才能再拖动。 matchedGeometryEffectIf you have the same view appearing in two different parts of your view hierarchy and want to animate between them – for example, going from a list view to a zoomed detail view – then you should use SwiftUI’s matchedGeometryEffect() modifier, which is a bit like Magic Move in Keynote.看例子就可以了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394struct MatchedGeometryEffectExamples: View &#123; @State private var isClicked: Bool = false @Namespace private var namespace1 @State private var selected2: String = &quot;&quot; @Namespace private var namespace2 @State private var selected3: String = &quot;&quot; @Namespace private var namespace3 let categories: [String] = [&quot;Home&quot;,&quot;Popular&quot;,&quot;Saved&quot;] var body: some View &#123; VStack &#123; if !isClicked &#123; Circle() .matchedGeometryEffect(id: &quot;rectangle&quot;, in: namespace1) .frame(width: 100, height: 100) .foregroundColor(.green) &#125; else &#123; Spacer().frame(height: 100) &#125; Spacer() HStack &#123; ForEach(categories, id: \\.self) &#123; category in ZStack &#123; if selected2 == category &#123; RoundedRectangle(cornerRadius: 10) .fill(Color.red.opacity(0.3)) .matchedGeometryEffect(id: &quot;category_background2&quot;, in: namespace2) &#125; Text(category) &#125; .frame(maxWidth: .infinity) .frame(height: 55) .onTapGesture &#123; withAnimation(.easeInOut) &#123; selected2 = category &#125; &#125; &#125; &#125; Spacer() HStack &#123; ForEach(categories, id: \\.self) &#123; category in ZStack &#123; if selected3 == category &#123; RoundedRectangle(cornerRadius: 10) .fill(Color.red.opacity(0.7)) .matchedGeometryEffect(id: &quot;category_background3&quot;, in: namespace3) .frame(width: 65, height: 2) .offset(y: 10.0) &#125; Text(category) .foregroundColor(selected3 == category ? .red : .black) &#125; .frame(maxWidth: .infinity) .frame(height: 55) .onTapGesture &#123; withAnimation(.easeInOut) &#123; selected3 = category &#125; &#125; &#125; &#125; Spacer() if isClicked &#123; RoundedRectangle(cornerRadius: 25.0) .matchedGeometryEffect(id: &quot;rectangle&quot;, in: namespace1) .frame(width: 100, height: 100) .foregroundColor(.blue) &#125; else &#123; Spacer().frame(height: 100) &#125; &#125; .frame(maxWidth: .infinity, maxHeight: .infinity) .onTapGesture &#123; withAnimation(.easeInOut) &#123; isClicked.toggle() &#125; &#125; &#125;&#125; PathThe outline of a 2D shape 直接使用Path画一个三角形12345678910struct Drawing: View &#123; var body: some View &#123; Path &#123; path in path.move(to: CGPoint(x: 200, y: 100)) path.addLine(to: CGPoint(x: 100, y: 300)) path.addLine(to: CGPoint(x: 300, y: 300)) path.addLine(to: CGPoint(x: 200, y: 100)) &#125; &#125;&#125; 给图形填充色 .fill12Shape .fill(.blue) // -- 填充蓝色 描边框 .stroke12Shape .stroke(.blue, lineWidth: 1) // -- 蓝色边框,粗细为1 .stroke 和 .strokeBorder 的区别当设置.stroke(lineWidth: 50)的时候,最外侧的边会向外扩散25,并向内收拢25;而当设置.strokeBorder(lineWidth: 50)的时候,它只向内收拢50。 strokeBorder用来描线来看下这个箭头是怎么出来的？看以下代码:(如何画这个箭头) 12345678910111213141516171819202122232425262728struct Arrow2: InsettableShape &#123; // 因为这是自建图形,想用用到strokeBorder,就需要遵循InsettableShape协议 // 为了实现InsettableShape协议而写的属性和方法 var insetAmount = 0.0 func inset(by amount: CGFloat) -&gt; some InsettableShape &#123; var arrow = self arrow.insetAmount += amount return arrow &#125; // 这是为了实现animation效果的 var animatableData: Double &#123; get &#123; insetAmount &#125; set &#123; insetAmount = newValue&#125; &#125; func path(in rect: CGRect) -&gt; Path &#123; var path = Path() path.move(to: CGPoint(x: rect.midX, y: rect.height - insetAmount)) path.addLine(to: CGPoint(x: rect.midX, y: insetAmount)) path.addLine(to: CGPoint(x: insetAmount, y: rect.height * 0.33)) path.move(to: CGPoint(x: rect.midX, y: insetAmount)) path.addLine(to: CGPoint(x: rect.width - insetAmount, y: rect.height * 0.33)) return path &#125;&#125; 但是却是这样的图形:为什么是这样的一个图形？因为该图形只会在封闭区域加入颜色！因为我们在自建图形里遵循了InsettableShape协议,所以下面我们可以使用.strokeBorder: 1234@State private var lineWidth = 1.0 // 后面应该有个Slider()来调整这个值Arrow2() .strokeBorder(.blue, style: StrokeStyle(lineWidth: lineWidth, lineCap: .round, lineJoin: .round)) 这时候.strokeBorder的作用只是描边,而不会在封闭区域加入颜色！就会有图一箭头的效果。 strokeBorder &amp; StrokeStyle 实现动画效果示例:create a marching ants border effect创建一个蚂蚁们行军的效果。 1234567891011121314struct ContentView: View &#123; @State private var phase = 0.0 var body: some View &#123; Rectangle() .strokeBorder(style: StrokeStyle(lineWidth: 4, dash: [10], dashPhase: phase)) .frame(width: 200, height: 200) .onAppear &#123; withAnimation(.linear.repeatForever(autoreverses: false)) &#123; phase -= 20 &#125; &#125; &#125;&#125; 实际效果的话,是连贯的一直沿着顺时针走的虚线。若phase -&#x3D; 20,则是逆时针。为何会一直连贯着走？就是因为dash: [10], dashPhase: -20,所以就会看上去连贯,若改成其他数字,就会发现不是连贯,而是一直重复的感觉了。 解决某些自建Shape不支持.strokeBorder的情况原因:Circle和某些自建图形都遵循Shape协议,但Circle遵循第二个名为InsettableShape的协议,而自建图形并不遵循。解决办法:1.遵循InsettableShape协议;2.增加一个inset(by:)方法,并返回一个新的insettable shape; 具体实现的解释在这里:(貌似里面的代码与这里写的有一点区别,应该是实现了一些其他的东西) https://www.hackingwithswift.com/books/ios-swiftui/adding-strokeborder-support-with-insettableshape 所以,以下面建立的Arc结构体来改编,代码为: 123456789101112131415161718192021222324struct Arc: InsettableShape &#123; // 以上遵循InsettableShape协议 // InsettableShape是建立在Shape协议之上的,所以不用再遵循Shape协议 var startAngle: Angle var endAngle: Angle var clockwise: Bool // 增加insetAmount变量 var insetAmount = 0.0 // 增加inset(by:)方法 func inset(by amount: CGFloat) -&gt; some InsettableShape &#123; var arc = self arc.insetAmount += amount return arc &#125; func path(in rect: CGRect) -&gt; Path &#123; var path = Path() path.addArc(center: CGPoint(x: rect.midX, y: rect.midY), radius: rect.size.width/2, startAngle: startAngle, endAngle: endAngle, clockwise: clockwise) return path &#125;&#125; 调用: 12Arc(startAngle: .degrees(0), endAngle: .degrees(110), clockwise: true) .strokeBorder(lineWidth: 10) path.closeSubpath() – 解决渲染.stroke后,图形存在缺口的情况以下三角形增加了stroke修饰符后,当linewidth设置后,该三角形的上角会有缺口,这是因为从起点到终点不断重复,而没有从终点到起点的过程，导致的这个缺口: 1234567Path &#123; path in path.move(to: CGPoint(x: 200, y: 100)) path.addLine(to: CGPoint(x: 100, y: 300)) path.addLine(to: CGPoint(x: 300, y: 300)) path.addLine(to: CGPoint(x: 200, y: 100))&#125;.stroke(.blue, lineWidth: 10) 如何解决这个难看的缺口:使用path.closeSubpath() 12345678Path &#123; path in path.move(to: CGPoint(x: 200, y: 100)) path.addLine(to: CGPoint(x: 100, y: 300)) path.addLine(to: CGPoint(x: 300, y: 300)) path.addLine(to: CGPoint(x: 200, y: 100)) path.closeSubpath()&#125;.stroke(.blue, lineWidth: 10) StrokeStyle – 另一个解决.stroke后图形存在缺口的情况12345678Path &#123; path in path.move(to: CGPoint(x: 200, y: 100)) path.addLine(to: CGPoint(x: 100, y: 300)) path.addLine(to: CGPoint(x: 300, y: 300)) path.addLine(to: CGPoint(x: 200, y: 100)) // path.closeSubpath()&#125;.stroke(.red, style:StrokeStyle(lineWidth: 10, lineCap: .round, lineJoin: .round)) 如果是style:StrokeStyle(lineWidth: 30, lineJoin: .round) 则只是在线与线连接过程中是round的,而没有设置结束点与开始点处的连接，仍旧是断的。 linejoin有三个可选属性,还有.miter是默认的样式,此外.bevel是斜角的连接， linecap有三个可选属性,.square是长方形的连接,.butt是烟蒂的连接（默认选项),.round是圆形的连接。所以上面的lineCap和lineJoin都是.round连接,这图形还是相当圆润的。 clockwise作图为何都是opposite direction？顺时针画出来的却是逆时针？看了一篇文章，觉得很有道理：The “default coordinate system” really means the standard Cartesian coordinate system, in which the y axis increases toward the top of the canvas. But both SwiftUI and UIKit always set up the coordinate system with the y axis “flipped” so that y values increase toward the bottom of the canvas.clockwise is accurate only in the standard Cartesian coordinate system. What it really means is “the direction of rotation that goes from the positive y axis toward the positive x axis”. So when you’re working in a flipped coordinate system, clockwise means the opposite direction! ShapeTriangleShape中没有内建的Triangle的Shape结构,所以需要我们自定义该遵循Shape结构的Triangle,自建的过程,也是我们熟悉其他自建图形的过程: 1234567891011struct Triangle: Shape &#123; // 任何自建图形均需有path方法 func path(in rect: CGRect) -&gt; Path &#123; Path &#123; path in path.move(to: CGPoint(x: rect.midX, y: rect.minY)) path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY)) path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY)) path.addLine(to: CGPoint(x: rect.midX, y: rect.minY)) &#125; &#125;&#125; 等同于: 1234567891011struct Triangle: Shape &#123; // 任何自建图形均需有path方法 func path(in rect: CGRect) -&gt; Path &#123; var path = Path() path.move(to: CGPoint(x: rect.midX, y: rect.minY)) path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY)) path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY)) path.addLine(to: CGPoint(x: rect.midX, y: rect.minY)) return path &#125;&#125; 经实际操作,这两者是完全一样的。可以看到,实际是使用到了rect: CGRect 的参数来画图形。因此,我们写一个画扇形的struct: 123456789101112struct Arc: Shape &#123; var startAngle: Angle var endAngle: Angle var clockwise: Bool func path(in rect: CGRect) -&gt; Path &#123; var path = Path() path.addArc(center: CGPoint(x: rect.midX, y: rect.midY), radius: rect.size.width/2, startAngle: startAngle, endAngle: endAngle, clockwise: clockwise) return path &#125;&#125; 调用该Arc,并实现画一个圆环,就可以: 123Arc(startAngle: .degrees(0), endAngle: .degrees(110), clockwise: true) .stroke(.blue, lineWidth: 10) .frame(width: 300, height: 300) 使用animatableData自定义图形动画图形中存在一个变量的情形制作一个吃豆人嘴巴始终一张一闭的动画 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import SwiftUIstruct Pacman: Shape &#123; var offsetAmount: Double // 为什么要定义animatableData变量？ // 因为下面的path方法返回的只是一个Path, // 而该Path并没有属性包装器, // 所以该Path不知道视图改变了, // 因此需要使用到animatableData的get/set属性来定义 // 注：必须是animatableData变量名称！ var animatableData: CGFloat &#123; get &#123; offsetAmount &#125; set &#123; offsetAmount = newValue &#125; &#125; func path(in rect: CGRect) -&gt; Path &#123; Path &#123; path in path.move(to: CGPoint(x: rect.midX, y: rect.midY)) path.addArc(center: CGPoint(x: rect.midX, y: rect.midY), radius: rect.height / 2, startAngle: Angle(degrees: offsetAmount), endAngle: Angle(degrees: 360 - offsetAmount), clockwise: false) &#125; &#125;&#125;struct Test0006: View &#123; @State private var animate: Bool = false var body: some View &#123; ZStack &#123; Pacman(offsetAmount: animate ? 20.0 : 0.0) .frame(width: 200, height: 200) &#125; .onAppear &#123; // 因为有了.repeatForever()才导致吃豆人的嘴巴一直一张一合 withAnimation(Animation.linear(duration: 1.0).repeatForever()) &#123; animate.toggle() &#125; &#125; &#125;&#125; AnimatablePair – 针对animatableData只能设置一个property的不足,类似一个补丁之前用到的animatableData只能捕捉一个变量的变化,因此引入到了AnimatablePair。AnimatablePair读取多个变量使用.first和.second。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Checkerboard: Shape &#123; var rows: Int var columns: Int var animatableData: AnimatablePair&lt;Double, Double&gt; &#123; // 如果是 AnimatablePair&lt;Int, Int&gt; // 则会跳出Type &#x27;Int&#x27; does not conform to protocol &#x27;VectorArithmetic&#x27; // 所以只能用Double类型 get &#123; AnimatablePair(Double(rows), Double(columns)) &#125; set &#123; rows = Int(newValue.first) columns = Int(newValue.second) &#125; &#125; func path(in rect: CGRect) -&gt; Path &#123; var path = Path() let rowSize = rect.height / Double(rows) let columnSize = rect.width / Double(columns) for row in 0..&lt;rows &#123; for column in 0..&lt;columns &#123; if (row + column).isMultiple(of: 2) &#123; let startX = columnSize * Double(column) let startY = rowSize * Double(row) let rect = CGRect(x: startX, y: startY, width: columnSize, height: rowSize) path.addRect(rect) &#125; &#125; &#125; return path &#125;&#125;struct Drawing: View &#123; @State private var rows = 4 @State private var columns = 4 var body: some View &#123; Checkerboard(rows: rows, columns: columns) &#125;&#125; AnimatablePair – 如何设置三个以上变量使用到: 1AnimatablePair&lt;CGFloat, AnimatablePair&lt;CGFloat, AnimatablePair&lt;CGFloat, CGFloat&gt;&gt;&gt; 所以,如何调用第四个变量: 1newValue.second.second.second.second 使用花瓣的图形图形如图:代码如下: 1234567891011121314151617181920212223242526struct Flower: Shape &#123; // 每片叶片偏移原点的量 var petalOffset: Double = -20 // 每片叶片的宽度 var petalWidth: Double = 100 func path(in rect: CGRect) -&gt; Path &#123; var path = Path() // 一个pi为180度,故从0度开始旋转360度,为一整圈回原点 // 每个步伐为22.5度,共18个步伐,所以有18片叶片 for number in stride(from: 0, to: Double.pi * 2, by: Double.pi / 8) &#123; // 定义每个叶片旋转的角度 // CGAffineTransform(rotationAngle: CGFloat) let rotation = CGAffineTransform(rotationAngle: number) // 定义每个叶片的起点 let position = rotation.concatenating(CGAffineTransform(translationX: rect.width / 2, y: rect.height / 2)) // 定义椭圆相对起点的位置以及自身的大小 let originalPetal = Path(ellipseIn: CGRect(x: petalOffset, y: 0, width: petalWidth, height: rect.width / 2)) // 将定义的椭圆加入之前定义的旋转角度和起点位置 let rotatedPetal = originalPetal.applying(position) path.addPath(rotatedPetal) &#125; return path &#125;&#125; 调用: 12Flower() .fill(.green.opacity(0.5)) .fill 的 style: FillStyle(eoFill: &lt;#T##Bool#&gt;, antialiased: &lt;#T##Bool#&gt;)达到如下图的效果:代码: 12Flower() .fill(.green.opacity(0.5), style: FillStyle(eoFill: true)) eoFill的eo是什么意思？即”even-odd”。 .inset.inset(by: CGFloat) 仅适用于形状。是指从形状的边缘向内插入的空间或距离。看下面的例子: 12345Circle() .inset(by: 20) .frame(width: 200, height: 200) .foregroundColor(.green) .border(Color.green) 本来圆形是能撑住整个边框的,现在因为插入了20的距离,所以缩小了。那么如果by的值是负数的情况呢？ 12345Circle() .inset(by: -20) .frame(width: 200, height: 200) .foregroundColor(.green) .border(Color.green) 就会超出边框。 drawingGroup()当一个view要计算大量图形时,会让系统变慢，如何解决或者优化这样的问题呢？使用drawingGroup()这个修饰器。 12345ZStack &#123; // 大量的图形计算及堆叠,例如 // to render 100 gradients as part of 100 separate views.&#125;.drawingGroup() 原理是:This tells SwiftUI it should render the contents of the view into an off-screen image before putting it back onto the screen as a single rendered output, which is significantly faster. Behind the scenes this is powered by Metal, which is Apple’s framework for working directly with the GPU for extremely fast graphics.但尽量少用drawingGroup(),虽然它能解决大量图形运算的性能问题,但后台的图像生成还是会减慢简单绘图的速度,所以只在解决现实问题的时候再使用。 blending mode – 混合模式将不同图层的颜色进行混合 someShape.blendMode(.multiply) 1234567891011ZStack &#123; Image(&quot;threemonths&quot;) .resizable() .scaledToFit() Rectangle() .fill(.red) .blendMode(.multiply)&#125;.frame(width: 400, height: 500).clipped() 以上是混合图像和上层的红色矩形,让图片像底片一样的红色。颜色混合模式中:multiply的原理是:每个像素都有一个RGBA,范围从0到1,其中越黑的像素越靠近0,而颜色越亮丽的像素越靠近1,multiply会让该值乘以本身,所以结果就是黑的越黑,亮的越黯淡,不可能超过原始颜色。CGAffineTransform同效果的还有如下的 someShape.colorMultiply(Color) someShape.colorMultiply(Color)1234Image(&quot;threemonths&quot;) .resizable() .scaledToFit() .colorMultiply(.red) 效果同 someShape.blendMode(.multiply) 是一样的，但这个更方便，直接在图像上使用，而不用使用ZStack()了。 .blendMode(.screen)1234567891011121314151617181920ZStack &#123; Circle() .fill(.red) .frame(width: 200) .offset(x: -50, y: -80) .blendMode(.screen) Circle() .fill(.green) .frame(width: 200) .offset(x: 50, y: -80) .blendMode(.screen) Circle() .fill(.blue) .frame(width: 200) .blendMode(.screen)&#125;.frame(width: 300, height: 400).background(.white) 此时屏幕上什么都没有,而把background中颜色换成.black，就会是这样:自己粗糙的理解,白色为1,黑色为0,白色的再混合还是白色,黑色混合什么颜色就是什么颜色。 saturation 和 blur 测试123456789101112@State var amount: Double = 0.0VStack &#123; Image(&quot;threemonths&quot;) .resizable() .scaledToFit() .frame(width: 300) .saturation(amount) .blur(radius: (1-amount)*20) Slider(value: $amount)&#125; With that code, having the slider at 0 means the image is blurred and colorless, but as you move the slider to the right it gains color and becomes sharp – all rendered at lightning-fast speed. trim(from::to::) 1234567891011121314Rectangle() .trim(from: 0, to: completionAmount) .stroke(.red, lineWidth: 20) .frame(width: 200, height: 200) .rotationEffect(.degrees(-90)) .onReceive(timer) &#123; _ in withAnimation &#123; if completionAmount == 1 &#123; completionAmount = 0 &#125; else &#123; completionAmount += 0.2 &#125; &#125; &#125; from和to的数值都是从0到1的范围。 ContainerRelativeShape向容器内嵌入shape,看代码就能理解了。 1234567891011ZStack &#123; ContainerRelativeShape() .inset(by: 4) .fill(.blue) Text(&quot;Hello, World!&quot;) .font(.title)&#125;.frame(width: 300, height: 200).background(.red).clipShape(RoundedRectangle(cornerRadius: 30)) 可以看到ContainerRelativeShape().inset(by: 4)是从边界向内4个像素开始生成图形,而红色背景只能看到最外侧的4个像素。 从网页取得数据向网页POST数据12345678910111213141516171819202122232425262728293031import UIKitstruct Post: Encodable, Decodable &#123; var body: String? var title: String? var id: Int var userId: Int&#125;// 向特定网页POST数据let url = URL(string: &quot;https://jsonplaceholder.typicode.com/posts&quot;)!var request = URLRequest(url: url)request.httpMethod = &quot;POST&quot;request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)let post = Post(body: &quot;给我滚出去&quot;, title: &quot;你好啊，小明&quot;, id: 787, userId: 87)do &#123; let jsonBody = try JSONEncoder().encode(post) request.httpBody = jsonBody&#125; catch &#123;&#125;let session = URLSession.sharedsession.dataTask(with: request) &#123; (data, response, error) in guard let data = data else &#123; return &#125; do&#123; let json = try JSONDecoder().decode(Post.self, from: data) print(json) &#125;catch&#123; print(error) &#125;&#125;.resume() (使用到async&#x2F;await) 12345678910111213141516171819202122func placeOrder() async &#123; guard let encoded = try? JSONEncoder().encode(order) else &#123; print(&quot;Failed to encode order&quot;) return &#125; let url = URL(string: &quot;https://reqres.in/api/cupcakes&quot;)! var request = URLRequest(url: url) request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;) request.httpMethod = &quot;POST&quot; do &#123; let (data, _) = try await URLSession.shared.upload(for: request, from: encoded) let decodedOrder = try JSONDecoder().decode(Order.self, from: data) confirmationMessage = &quot;Your order for \\(decodedOrder.quantity)x \\(Order.types[decodedOrder.type].lowercased()) cupcakes is on its way!&quot; showingConfirmation = true &#125; catch &#123; // 报错的flag和信息,如无法连接网络等 networkingFailure = true networkFailureMessage = &quot;Lost internet connetction&quot; &#125;&#125; URLSession.shared.dataTask的使用例如网页返回的数据是这样的： 123456&#123; &quot;resultCount&quot;:50, &quot;results&quot;: [ &#123;&quot;artistId&quot;: 159260351&#125;,&#123;&quot;artistId&quot;: 159260352&#125;,&#123;&quot;artistId&quot;: 159260353&#125; ]&#125; 那么,要取得resultCount的数据50,就要建立一个result1结构: 123struct result1: Codable &#123; var resultCount: Int&#125; 也要取得results这个列表,就需要建立另一个result2结构: 12345678struct result2: Codable &#123; var artistId: Int&#125;以及取得result2集合的result3结构:``` Swiftstruct result3: Codable &#123; var results: [result2]&#125; 接下来contentView结构中就是这样的:(一般用法,未使用到async&#x2F;await) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct ContentView: View &#123; @State private var results: [Result] = [] @State private var count: Int = 0 func loadData() &#123; guard let url = URL(string: &quot;https://itunes.apple.com/search?term=taylor+swift&amp;entity=song&quot;) else &#123; print(&quot;Invalid URL&quot;) return &#125; // 如果定义了下面被注释的request,后面的URLSession.shared.dataTask(with: request)返回的结果是一样的 // 那么定义常量request又有什么用呢？ // 看了URLSession.shared.dataTask的defination: // func dataTask(with request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask // func dataTask(with url: URL, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask // 确实两者都可以用,但看一些文章称,URLRequest是我们添加不同的自定义项以控制URL加载的地方。 let request = URLRequest(url: url) // URLSession是负责管理网络请求的iOS类。 // shared是共享会话,除非需要某些特定的行为,不然使用shared就可以了。 // URLSession.shared.dataTask方法从之前的URLRequest对象中创建一个网络任务, // 并在任务完成时运行一个闭包（下面是拖尾闭包语法） // 该闭包负责对数据或错误进行处理。 // 闭包会在后台运行,所以网络请求在后台运行时,不会阻断用户与UI的交互。 // 该闭包接收三个参数: data / response / error . // data是从请求返回的数据； // response是数据的描述,它可能包含数据的类型、数据量、状态码等; // error是出现的错误. // 注意: // 如果发生error,就不会设置data; // 如果返回data,就不会设置error. // 切记！ URLSession.shared.dataTask(with: request) &#123; data, response, error in if let data = data &#123; // 不能同时decode上面写的Result1结构和Response结构, // 只能一个个来,所以写了两个if。 if let decodedResponse = try? JSONDecoder().decode(Result1.self, from: data) &#123; // DispatchQueue.main.async()用来将工作发送到主线程。 // 因为iOS会让用户界面都在主线程运行,所以在后台获取数据,在后台解码JSON,然后在主线程实际更新属性。 // async代表着这是异步提交到主线程。 DispatchQueue.main.async &#123; self.count = decodedResponse.resultCount &#125; &#125; if let decodedResponse = try? JSONDecoder().decode(Response.self, from: data) &#123; DispatchQueue.main.async &#123; self.results = decodedResponse.results &#125; &#125; // 因为data和error是互斥的,所以这里要return,或者下面用else也可以,不能让print执行到。 return &#125; // 这里使用了可选链和空合运算符，如果存在错误则打印出错误，否则给出一个通用错误&quot;Unknown error&quot;。 print(&quot;Fetch failed: \\(error?.localizedDescription ?? &quot;Unknown error&quot;)&quot;) &#125;.resume() // 若没有.resume()的话,则该URLSession.shared.dataTask不会执行 &#125; var body: some View &#123; VStack &#123; Text(&quot;Total:\\(count)&quot;) List(results, id:\\.trackId) &#123; item in VStack(alignment: .leading) &#123; Text(item.trackName) .font(.headline) Text(item.collectionName) &#125; &#125; &#125; .onAppear(perform: loadData) &#125;&#125; (使用到async&#x2F;await) 123456789101112131415161718192021222324252627282930313233343536373839404142struct getDatasFromJsonPage2: View &#123; @State private var results:[Message] = [] // 这里在loadData()后面加async,代表这个函数是异步的 func loadData() async &#123; guard let url = URL(string: &quot;https://www.hackingwithswift.com/samples/user-messages.json&quot;) else &#123; print(&quot;Invalid url&quot;) return &#125; do &#123; // 这里用到了await,所以没有用到上面所写的.consume() let (data, _) = try await URLSession.shared.data(from: url) if let decodedResponse = try? JSONDecoder().decode([Message].self, from: data) &#123; DispatchQueue.main.async &#123; self.results = decodedResponse &#125; &#125; &#125; catch &#123; print(&quot;Invalid data&quot;) &#125; &#125; var body: some View &#123; VStack &#123; List(results, id:\\.id) &#123; item in Text(&quot;From:\\(item.from)&quot;) .font(.headline) Text(&quot;message:\\(item.message)&quot;) &#125; // .task修饰符只能用在iOS15.0以上 // SwiftUI provides a task modifier that you can use to execute an asynchronous function when a view appears // The system automatically cancels tasks when a view disappears. .task &#123; // loadData()是异步方法,所以需要用await await loadData() &#125; &#125; &#125;&#125; 取得图片数据,并直接在View中显示 Loading an image from a remote serverhttps://www.hackingwithswift.com/books/ios-swiftui/loading-an-image-from-a-remote-server 12// 首先,AsyncImage(url:)直接返回一个ImageAsyncImage(url: URL(string: &quot;https://hws.dev/img/logo.png&quot;)) 12345678910// 其次,这是AsyncImage(url:content:placeholder:)AsyncImage(url: URL(string: &quot;https://hws.dev/img/logo.png&quot;)) &#123; image in image .resizable() .scaledToFit()&#125; placeholder: &#123; Color.red&#125;.frame(width: 200, height: 200) 1234567891011121314151617// 最后,这是AsyncImage(url:content:)// content中返回的是一个enum AsyncImagePhase,// 它有case empty / case success(Image) / case failure(Error)三种情况:AsyncImage(url: URL(string: &quot;https://hws.dev/img/logo.png&quot;)) &#123; phase in if let image = phase.image &#123; image .resizable() .scaledToFit() &#125; else if phase.error != nil &#123; Text(&quot;There was an error loading the image.&quot;) // 或者这里加载一个错误的图片如Image(systemName: &quot;questionmark&quot;) &#125; else &#123; ProgressView() &#125;&#125;.frame(width: 200, height: 200) JSONDecoder().dateDecodingStrategy &#x3D; .iso8601当你发现需要提取的字符串的日期格式是这样的: 1&quot;registered&quot;: &quot;2015-11-10T01:47:18-00:00&quot; 这是时间和日期的国际标准 ISO-8601。需要如此提取为Date格式: 1234let decoder = JSONDecoder()// 多这一行代码decoder.dateDecodingStrategy = .iso8601// 接下来继续decode [unowned self] 与 [weak self] https://blog.csdn.net/Three_Zhang/article/details/80137421 弱引用（weak）,无主引用（unowned）.这二者的使用场景分别如下：如果捕获（比如 self）可以被设置为 nil(即Optional的场景)，也就是说它可能在闭包前被销毁，那么就要将捕获定义为 weak。如果它们一直是相互引用，即同时销毁的，那么就可以将捕获定义为 unowned。 singleton 即单例单例就比如： 123class TheOneAndOnlyKraken &#123; static let sharedInstance = TheOneAndOnlyKraken() // singleton&#125; 单例在使用中非常的普遍,单例有三个重要的准则:1.单例必须是唯一的(只能存在这一个实例,而且是能全局访问的)2.为保证单例的唯一性,单例类的初始化方法必须是私有的(即private init())3.单例必须是线程安全的(要满足隐藏的dispatch_once规则)(通过dispatch_once可保证实例化代码只运行一次) UUID().uuidstring 创建随机字符串UUID().uuidstring可以创建36位的随机字符串 12345678910import Foundationfor _ in 0..&lt;3 &#123; print(UUID().uuidString)&#125;// D3ABA279-6808-49E9-A3F5-953FB1EC6DAD// 8985DA1E-CCDA-4102-B21F-E7F8CCDF98EE// 97F65EBD-1A52-4489-8AC1-3F6B3CB45596 as &#x2F; as! &#x2F; as? 三种操作符as– 从派生类转换为基类,即向上转型(Upcasting)。 as!– 向下转型(Downcasting)。由于是强制类型转换,如果转换失败会报runtime错误。 as?– as?和as!操作符的转换规则完全一样,但as?如果转换不成功的时候就会返回一个nil对象。 https://www.cnblogs.com/dukework/p/6553714.html Timer &amp;&amp; DateTimerTimer.scheduledTimer(withTimeInterval: &lt;#T##TimeInterval#&gt;, repeats: &lt;#T##Bool#&gt;, block: &lt;#T##(Timer) -&gt; Void#&gt;)12345678910var count: Int = 0// 每秒更新给count变量的值加1// 如果repeat为false,则只执行一次Timer.scheduledTimer(withTimeInterval: 0.2, repeats: true) &#123; timer in self.count += 1 if counter == 50 &#123; // 停止timer timer.invalidate() &#125;&#125; 还可以这样: 1234567891011for _ in 1...20 &#123; delay += 0.2 Timer.scheduledTimer(withTimeInterval: delay, repeats: false) &#123; timer in self.count += 1 &#125;&#125;/* 不能错误理解成,第一个执行完,第二个过0.2秒执行完,轮到第三个开始过0.4秒执行,完毕后第四个开始计时，这是错误的。其实是,第一个执行完,第二个执行但等待0.2秒,第三个也是执行,但等待0.4秒,依次下去,所以每个的看上去相差均是0.2!所以这里的跟上面单独的timer相同的效果。*/ Timer.publish123456789101112131415161718192021// every指间隔时间,on指在哪个线程运行,in是指RunLoop.Mode,一般设置为.common// .autoconnect()是自动连接或断开该publish的意思let timer = Timer.publish(every: 1.0, on: .main, in: .common).autoconnect()@State var currentDate: Date = Date()var dateFormatter: DateFormatter &#123; let formatter = DateFormatter() formatter.timeStyle = .medium return formatter&#125;var body: some View &#123; VStack &#123; Text(dateFormatter.string(from: currentDate)) &#125; // .onReceive(Publisher, perform: &#123; _ in Code &#125;) // .onReceive接收一个Publisher,所以 .onReceive(timer, perform: &#123; value in currentDate = value &#125;) &#125; 以上是每秒走一秒的一个时钟 也可以用这个做一个计时器,比如10-9-8-…-1-时间到！下面是一个23:59:29倒计时的计时器的代码: 123456789101112131415161718192021let timer = Timer.publish(every: 1.0, on: .main, in: .common).autoconnect()@State var timeRemaining: String = &quot;&quot;let futureDate: Date = Calendar.current.date(byAdding: .day, value: 1, to: Date()) ?? Date()func updateTimeRemaing() &#123; let remaining = Calendar.current.dateComponents([.hour, .minute, .second], from: Date(), to: futureDate) let hour = remaining.hour ?? 0 let minute = remaining.minute ?? 0 let second = remaining.second ?? 0 timeRemaining = &quot;\\(hour):\\(minute):\\(second)&quot;&#125; var body: some View &#123; VStack &#123; Text(timeRemaining) &#125; .onReceive(timer, perform: &#123; _ in updateTimeRemaining() &#125;)&#125; Timer.publish的关闭紧接上例,要关闭timer,需要用到以下代码: 1timer.upstream.connect().cancel() 例子: 1234567891011121314151617struct ContentView: View &#123; let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect() @State private var counter = 0 var body: some View &#123; Text(&quot;Hello, World!&quot;) .onReceive(timer) &#123; time in if counter == 5 &#123; timer.upstream.connect().cancel() &#125; else &#123; print(&quot;The time is now \\(time)&quot;) &#125; counter += 1 &#125; &#125;&#125; Timer.publish的tolerance参数的设置tolerance参数的设置的用处:Before we’re done, there’s one more important timer concept I want to show you: if you’re OK with your timer having a little float, you can specify some tolerance. This allows iOS to perform important energy optimization, because it can fire the timer at any point between its scheduled fire time and its scheduled fire time plus the tolerance you specify. In practice this means the system can perform timer coalescing: it can push back your timer just a little so that it fires at the same time as one or more other timers, which means it can keep the CPU idling more and save battery power. 1let timer = Timer.publish(every: 1, tolerance: 0.5, on: .main, in: .common).autoconnect() 不知道理解的有没有错,若设置tolerance非默认的0值比如0.5之类,则能更加节能,但若不设置,能够更精确。经几个小时的测试,两者时间差并没有什么区别。不知道有什么更大的区别,还是需要更长时间的测试。 Date取得今日和明日的时间123456// 取得今日的时间let now = Date.now// 取得明日的时间let tomorrow = Date.now.addingTimeInterval(86400)// 取得今日和明日的时间区间let range = now...tomorrow DateComponentsDateComponents let us read or write specific parts of a date rather than the whole thing. So, if we wanted a date that represented 8am today, we could write code like this: 12345var components = DateComponents()components.hour = 8components.minute = 0let date = Calendar.current.date(from: components)// &quot;Jan 1, 1 at 8:00 AM&quot; 取得某日期的hour和minute: 1234let someDate = Date.nowlet components = Calendar.current.dateComponents([.hour, .minute], from: someDate)let hour = components.hour ?? 0let minute = components.minute ?? 0 Date的format1234// 7:02 PMText(Date.now, format: .dateTime.hour().minute())// May 16,2022Text(Date.now, format: .dateTime.day().month().year()) Date的formattedWe can convert any date to a string by calling its toString() method. 1234// May 16,2022 7:06 PMText(Date.now.formatted(date: .long, time: .shortened))// 7:07 PMText(Date.now.formatted(date: .omitted, time: .shortened)) DispatchQueueDispatchQueue.main 主线程IOS要求的所有界面要素(UI)需要在主线程上执行。 DispatchQueue.global() 非主线程联网请求、数据处理等,可以在该线程上进行。 DispatchQueue.global(qos: .background)是强大的后台线程,可快速完成任务,可堪比主线程的性能。qos:low, normarl, high 等等,性能稍差些,但可承担额外的后台线程任务。 主线程和后台线程的联合使用: 12345678910111213141516DispatchQueue.global(qos: .background).async &#123; // 下载数据所以放在后台线程上执行 let newData = downloadData() print(&quot;Check 1: \\(Thread.isMainThread)&quot;) // false print(&quot;check 1: \\(Thread.current)&quot;) // &lt;NSThread: 0xxxxxx&gt;&#123;number = 4, name = (null)&#125; DispatchQueue.main.async &#123; // 因为dataArray中的某个@Published变量是会让主界面的UI实时更新的,所以一定要放在主线程上执行 // 不然会报警告: // Publishing changes from background threads is not allowed; // make sure to publish values from the main thread on model updates. dataArray = newData print(&quot;Check 2: \\(Thread.isMainThread)&quot;) // true print(&quot;check 2: \\(Thread.current)&quot;) // &lt;NSThread: 0xxxxxx&gt;&#123;number = 1, name = main&#125; &#125;&#125; DispatchQueue.main.asyncAfter(deadline: &lt;#T##DispatchTime#&gt;, execute: &lt;#T##() -&gt; Void#&gt;)DispatchQueue.main.async 和 Dispatch.main.asyncAfter(.now(),{})都是异步的,而且两者没有区别。 Combine https://zhuanlan.zhihu.com/p/340281483 Combine解决的核心问题，是如何处理时间序列数据，也就是如何处理随着时间变化而变化的数据。Combine有三大核心概念: Publisher &#x2F; Operator &#x2F; Subscriber . Publisher – 数据的提供者。 Subscriber – 数据的接收者。 Operator – 中间处理器,起着上下联通Publisher和Subscriber的作用。 这里有一个使用Combine取数据的相对比较好的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import SwiftUIimport Combinestruct PostModel: Identifiable, Codable &#123; let userId, id: Int let title, body: String&#125;class DownloadWithCombineViewModel: ObservableObject &#123; @Published var posts: [PostModel] = [] var cancellables = Set&lt;AnyCancellable&gt;() init() &#123; getPosts() &#125; func getPosts() &#123; guard let url = URL(string: &quot;https://jsonplaceholder.typicode.com/posts&quot;) else &#123; return &#125; // 1. Create the publisher URLSession.shared.dataTaskPublisher(for: url) // 2. Subscribe publisher on background thread // 省略也可以,因为数据处理都是放在background的 .subscribe(on: DispatchQueue.global(qos: .background)) // 3. Receive on main thread // 不能省略,因为更新UI上的数据必须要在main thread .receive(on: DispatchQueue.main) // 4. tryMap (check that the data is good) .tryMap(handleOutput) /* .tryMap &#123; (data, response) -&gt; Data in guard let response = response as? HTTPURLResponse, response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else &#123; throw URLError(.badServerResponse) &#125; return data &#125; */ // 5. Decode (Decode data into PostModel) .decode(type: [PostModel].self, decoder: JSONDecoder()) // 6. Sink (Put the item into our app) .sink &#123; (completion) in // 可省略 // print(&quot;Completion: \\(completion)&quot;) // 更细致的话: switch completion &#123; case .finished: break case .failure(let error): print(&quot;Error downloading data. \\(error)&quot;) &#125; &#125; receiveValue: &#123; [weak self] (returnedPosts) in self?.posts = returnedPosts &#125; // 7. Store (Cancel subscription if needed) .store(in: &amp;cancellables) &#125; func handleOutput(outPut: URLSession.DataTaskPublisher.Output) throws -&gt; Data &#123; guard let response = outPut.response as? HTTPURLResponse, response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else &#123; throw URLError(.badServerResponse) &#125; return outPut.data &#125; &#125;struct DownloadWithCombine: View &#123; @StateObject var vm = DownloadWithCombineViewModel() var body: some View &#123; List &#123; ForEach(vm.posts) &#123; post in VStack(alignment: .leading) &#123; Text(post.title) .font(.headline) Text(post.body) .foregroundColor(.gray) &#125; .frame(maxWidth: .infinity, alignment: .leading) &#125; &#125; &#125;&#125; PassThroughSubject的使用PassThroughSubject实质上是把一个数据变为Publisher。看下面的代码例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import Foundationimport Combineclass JustViewObservableObject: ObservableObject &#123; var cancellable: AnyCancellable? struct Student: Decodable &#123; let name: String &#125; let json = &quot;&quot;&quot; [&#123; &quot;name&quot;: &quot;小明&quot; &#125;, &#123; &quot;name&quot;: &quot;小红&quot;, &#125;, &#123; &quot;name&quot;: &quot;李雷&quot; &#125;] &quot;&quot;&quot; init() &#123; // PassThroughSubject接受两个参数，一个输出数据和一个Error // 这里输出数据暂且设为String,Error设为Never let publisher = PassthroughSubject&lt;String, Never&gt;() cancellable = publisher // flatMap闭包要求的返回值必须是一个publisher,所以闭包内使用Just比较合适 // 后续处理中把json字符串映射成模型数组 .flatMap &#123; value in Just(value.data(using: .utf8)!) .decode(type: [Student].self, decoder: JSONDecoder()) // 如果上述json字符串中不是一个[Student]列表的字符串, // 比如字符串中一部分是... &quot;name&quot; &quot;Vito&quot; &lt;-- 少了一个冒号(:) // 就会被catch到,并生成器一个[Student(name:&quot;NoName&quot;)]的列表 .catch &#123; _ in Just([Student(name:&quot;NoName&quot;)]) &#125; &#125; .sink(receiveCompletion: &#123; _ in print(&quot;It is over.&quot;) &#125;, receiveValue: &#123; someValue in print(someValue) &#125;) // PassThroughSubject的send常用函数 // send（input:String）函数向该subject发送新值 // send(completion:.finished)发送完成 // send(completion: someError)发送error publisher.send(json) publisher.send(completion: .finished) &#125;&#125;var a = JustViewObservableObject()/*[__lldb_expr_31.JustViewObservableObject.Student(name: &quot;小明&quot;), __lldb_expr_31.JustViewObservableObject.Student(name: &quot;小红&quot;), __lldb_expr_31.JustViewObservableObject.Student(name: &quot;李雷&quot;)] It is over.*/ 为了管理外部数据，SwiftUI具有一个ObservableObject协议。这要求我们声明一个名为objectWillChange的变量，该变量需要一个Publisher；通常，我们可以使用PassThroughSubject。这就是遵守ObservableObject协议所需的全部。然后，当值更改时，我们需要在发布服务器上使用send方法发送消息。 使用Combine链式调用多个数据的方式 https://www.bilibili.com/video/BV1hY411W7TZ?spm_id_from=333.337.search-card.all.click 目标:从https://jsonplaceholder.typicode.com/posts中获取到https://jsonplaceholder.typicode.com/posts/1的用户数据,并根据该用户id,获取到https://jsonplaceholder.typicode.com/users/ + 这个id的用户具体数据 建立一个CombineChaining.swift来创建一个model:(CombineChaining.swift) 1234567891011import Foundation// 用户Model// 这里暂且只有id这一个元素struct UserModel: Codable &#123; var id: Int&#125;struct PostModel: Codable &#123; var body: String&#125; 建立网络服务的类,来处理网络服务的请求:(NetworkService.swift)因为我们要使用链式网络请求,而Combine是处于一个管道中,正好合适。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import Foundationimport Combineimport Metal// 定义一下网络服务中的错误,为了在View中进行显示:// 符合Error协议// 符合CustomStringConvertible协议,可以用字符串进行描述enum NetworkError: Error, CustomStringConvertible &#123; // URL错误 case URLError // 解码错误 case DecodeError // 响应错误,而且要将详细的错误类型返回回来 case ResponseError(error: Error) // 一个未知的错误 case unknownError // 符合CustomStringConvertible必须要实现一个description计算变量 var description: String &#123; switch self &#123; case .URLError: return &quot;URL Error!&quot; case .DecodeError: return &quot;Decode Error!&quot; case .ResponseError(let error): return &quot;Network Error: \\(error.localizedDescription)&quot; case .unknownError: return &quot;Unknown Error!&quot; &#125; &#125;&#125;class NetworkService &#123; // 生成一个singleton单例模式 static let shared = NetworkService() // 获取用户信息的网络请求 // 希望返回一个Publisher且是一个UserModel的数据 func fetchUser(index: String) -&gt; AnyPublisher&lt;UserModel, Error&gt; &#123; let url = URL(string: &quot;https://jsonplaceholder.typicode.com/users/&quot; + index) guard let url = url else &#123; // 光下面的代码会报错,因为希望返回的是AnyPublisher&lt;UserModel, Error&gt; // return Fail(error: NetworkError.URLError) // 所以要使用.eraseToAnyPublisher()把无用的参数去掉 return Fail(error: NetworkError.URLError).eraseToAnyPublisher() &#125; return URLSession.shared.dataTaskPublisher(for: url) // .tryMap会测试数据是否合法,若非法,会主动抛出错误 // .tryMap &#123; (data: Data, response: URLResponse) in Code &#125; .tryMap &#123; element -&gt; Data in guard let httpResponse = element.response as? HTTPURLResponse, httpResponse.statusCode &gt;= 200 &amp;&amp; httpResponse.statusCode &lt; 300 else &#123; throw URLError(.badServerResponse) &#125; return element.data &#125; .decode(type: UserModel.self, decoder: JSONDecoder()) // .mapError会把标准错误转换成我们自己定义的错误 .mapError &#123; error -&gt; NetworkError in switch error &#123; // 用类型检查操作符（is）来检查一个实例是否属于特定子类型 case is URLError: return .ResponseError(error: error) case is DecodingError: return .DecodeError default: // 如果不符合NetworkError设置的其他error类型, // 就套用NetworkError的.unknownError return error as? NetworkError ?? .unknownError &#125; &#125; .eraseToAnyPublisher() &#125; // 获取用户详情的网络请求 // fetchPost与fetchUser类似,可以精简 func fetchPost(index: String) -&gt; AnyPublisher&lt;PostModel, Error&gt; &#123; let url = URL(string: &quot;https://jsonplaceholder.typicode.com/posts/&quot; + index) guard let url = url else &#123; return Fail(error: NetworkError.URLError).eraseToAnyPublisher() &#125; return URLSession.shared.dataTaskPublisher(for: url) .tryMap &#123; element -&gt; Data in guard let httpResponse = element.response as? HTTPURLResponse, httpResponse.statusCode &gt;= 200 &amp;&amp; httpResponse.statusCode &lt; 300 else &#123; throw URLError(.badServerResponse) &#125; return element.data &#125; .decode(type: PostModel.self, decoder: JSONDecoder()) .mapError &#123; error -&gt; NetworkError in switch error &#123; case is URLError: return .ResponseError(error: error) case is DecodingError: return .DecodeError default: return error as? NetworkError ?? .unknownError &#125; &#125; .eraseToAnyPublisher() &#125; &#125; 建立一个View:(CombineChainingView.swift) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import SwiftUIimport Combinestruct CombineChainingView: View &#123; @State var index: String = &quot;&quot; @StateObject var vm = ViewModel() var body: some View &#123; VStack(spacing: 20) &#123; // 此处显示错误信息 Text(vm.errorMessage).bold() HStack(spacing: 0) &#123; TextField(&quot;Input index here&quot;, text: $index) .frame(width: 130) .padding() .background(Color.gray.opacity(0.2)) Button &#123; // 因为getUserSubject是一个Combine的PassThroughSubject方法, // 所以可以直接通过send()方法直接传值过去 vm.getUserSubject.send(index) &#125; label: &#123; Text(&quot;Get User and Post&quot;) .padding() &#125; .background(Color.blue) .foregroundColor(.white) .cornerRadius(10) .padding() &#125; // 此处显示用户的body信息 Text(vm.message).bold() &#125; &#125;&#125;extension CombineChainingView &#123; // 因为本案例相对比较简单,所以直接用extension了, // 一般都会再建议个ModelView的文件 class ViewModel: ObservableObject &#123; @Published var message: String = &quot;&quot; @Published var errorMessage: String = &quot;&quot; // 定义一个,作为使用Combine的内存管理 var cancellables = Set&lt;AnyCancellable&gt;() // 需要启动Combine的Publisher, // 所以使用到了PassthroughSubject // 传递一个index的String类型,而且因为定义过所有error,所以是永远不会出错的 var getUserSubject = PassthroughSubject&lt;String, Never&gt;() init() &#123; // 启动Combine流程 getUserSubject // 因为getUserSubject是PassthroughSubject&lt;String, Never&gt;的Publisher类型, // 而我们定义的NetworkService的fetchUser定义的返回值是 // AnyPublisher&lt;UserModel, Error&gt;, // 所以需要使用到.flatMap操作符去转换 // 但下面的.flatMap&#123;&#125;无法阻止用户多次点击多次发送的情况 /* .flatMap&#123; index -&gt; AnyPublisher&lt;UserModel, Error&gt; in print(&quot;Begin to fetch user.&quot;) return NetworkService.shared.fetchUser(index: index) &#125; */ // 所以需要使用到Combine的.map和.switchToLatest // 你多次点击后,虽然会一直打印&quot;Begin to fetch user.&quot;, // 但其实只取最后一次. .map &#123; index -&gt; AnyPublisher&lt;UserModel, Error&gt; in print(&quot;Begin to fetch user.&quot;) return NetworkService.shared.fetchUser(index: index) &#125; .switchToLatest() // 判断上述流程中是否会有错误 // 返回的也应该是getUserSubject定义中需要返回的类型 // 一旦捕获到错误就不会进入再下面的流程 .catch &#123; error -&gt; AnyPublisher&lt;UserModel, Error&gt; in Fail(error: error).eraseToAnyPublisher() &#125; // 下面再往下走,进行第二次请求 // 此时传递到的是NetworkService.shared.fetchUser定义的 // AnyPublisher&lt;UserModel, Error&gt; // 而且处理后得是fetchPost定义的返回值 // AnyPublisher&lt;PostModel, Error&gt; .flatMap &#123; userModel -&gt; AnyPublisher&lt;PostModel, Error&gt; in print(&quot;Begin to fetch post.&quot;) return NetworkService.shared.fetchPost(index: String(userModel.id)) &#125; // 再进行一次错误处理 .catch &#123; error -&gt; AnyPublisher&lt;PostModel, Error&gt; in Fail(error: error).eraseToAnyPublisher() &#125; // 因为要进入到显示环节,所以要转到main thread上来 .receive(on: RunLoop.main) // 一旦进入到.sink流程,Combine的链路就结束了 .sink &#123; completion in switch completion &#123; // 先处理可能会出现的错误 case .failure(let error): // 下面是很不合理的,只是因为例子相对简单 self.errorMessage = (error as! NetworkError).description default: // 不出错的情况下,打印下completion print(completion) &#125; &#125; receiveValue: &#123; [weak self] postModel in self?.message = postModel.body &#125; // 最后要用.store来管理下内存 .store(in: &amp;cancellables) &#125; &#125;&#125; 使用Combine的future&#x2F;promise等特性同时取得两个来源的数据具体看视频:(SwiftUI+Combine实现Dota Demo之三：用Zip合并两个Publisher) https://www.bilibili.com/video/BV1Mb4y117vF?spm_id_from=333.999.0.0 这里代码先不写了,以后有需要的时候再写下来。 使用Combine链式传值的一般使用视频出处: https://www.bilibili.com/video/BV1pb4y1X7ZH?p=27&amp;spm_id_from=pageDriver 利用Combine的Publisher和Subscriber来进行页面传值等,感觉是趋势,写多了感觉挺方便。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import SwiftUIimport Combineclass SubscriberViewModel: ObservableObject &#123; @Published var count: Int = 0 var cancellables = Set&lt;AnyCancellable&gt;() @Published var textFieldText: String = &quot;&quot; // textIsValid的值由textFieldText.count来决定, // 后续addTextFieldSubscriber()中会具体实现 @Published var textIsValid: Bool = false @Published var showButton: Bool = false init() &#123; setUpTimer() addTextFieldSubscriber() addButtonSubscriber() &#125; func addTextFieldSubscriber() &#123; // 从属性包装器投影值（$变量名） // 该变量也能作为一个publisher向下链式传递 $textFieldText // .debounce的作用是至少在一定时间后才继续执行下去 .debounce(for: 0.5, scheduler: DispatchQueue.main) .map &#123; (text) -&gt; Bool in if text.count &gt; 3 &#123; return true &#125; return false &#125; // .assign 是赋值 // 但不推荐,因为主要原因是on: .self是强引用,故不推荐 // .assign(to: \\.textIsValid, on: self) // 所以可以使用.sink .sink(receiveValue: &#123; [weak self] (isValid) in self?.textIsValid = isValid &#125;) .store(in: &amp;cancellables) &#125; func setUpTimer() &#123; Timer .publish(every: 1, on: .main, in: .common) .autoconnect() // .sink没有设置Completion是因为不会出错,所以不用判断成功与否 .sink &#123; [weak self] _ in guard let self = self else &#123; return &#125; self.count += 1 &#125; .store(in: &amp;cancellables) &#125; func addButtonSubscriber() &#123; $textIsValid // .combineLatest 可以再绑定一个变量并向下传 .combineLatest($count) .sink &#123; [weak self] (isValid, count) in guard let self = self else &#123; return &#125; if isValid &amp;&amp; count &gt; 3 &#123; self.showButton = true &#125; else &#123; self.showButton = false &#125; &#125; .store(in: &amp;cancellables) &#125; &#125;struct SubscriberBootcamp: View &#123; @StateObject var vm = SubscriberViewModel() var body: some View &#123; VStack &#123; Text(&quot;\\(vm.count)&quot;) .font(.largeTitle) TextField(&quot;Please input here ...&quot;, text: $vm.textFieldText) .frame(height: 55) .font(.headline) .padding(.leading) .background(Color.gray.opacity(0.2)) .cornerRadius(10) .overlay(alignment: .trailing) &#123; ZStack &#123; Image(systemName: &quot;xmark&quot;) .foregroundColor(.red) .opacity(vm.textIsValid ? 0.0 : 1.0) Image(systemName: &quot;checkmark&quot;) .foregroundColor(.green) .opacity(vm.textIsValid ? 1.0 : 0.0) &#125; .padding(.trailing) &#125; Button &#123; &#125; label: &#123; Text(&quot;Submit&quot;.uppercased()) .font(.headline) .foregroundColor(.white) .frame(height: 55) .frame(maxWidth: .infinity) .background(Color.blue) .cornerRadius(10) .opacity(vm.showButton ? 1.0 : 0.5) &#125; .disabled(!vm.showButton) &#125; .padding() &#125;&#125; 键路径表达式（Key-Path expression）即我们惯常会用到的 \\. Key-Path表达式用来引用一个类型的属性或者下标。基本的形式: \\typeName.path如果根据上下文通过类型推断可以确定隐式的类型,表达式的typeName可以省略。 The type name –is the name of a concrete type, including any generic parameters, such as String, [Int], or Set. The path –consists of property names, subscripts, optional-chaining expressions, and forced unwrapping expressions. Each of these key-path components can be repeated as many times as needed, in any order. 1234567891011121314151617181920212223struct SomeStructure &#123; var someValue: Int&#125;let s = SomeStructure(someValue: 2)let pathToProperty = \\SomeStructure.someValuelet value = s[keyPath: pathToProperty] // 2// 包含下标(Subscripts)的Key-Pathlet greetings = [&quot;hello&quot;, &quot;hi&quot;]let myGreeting = \\[String].[1]print(greetings[keyPath: myGreeting]) // hi// 包含可选链和强制解包的Key-Pathlet greetings2 = [&quot;hello&quot;, &quot;hola&quot;, &quot;bonjour&quot;, &quot;안녕&quot;]print(greetings2.first?.count as Any) // Optional(5)let count = greetings2[keyPath: \\[String].first?.count]print(count as Any) // Optional(5)// greetings2[keyPath: \\[String].first?] 结果就是&quot;hello&quot;// 使用self指向实例var a = (a:1, b:2)a[keyPath: \\.self] = (a:10, b:20)print(a) // (a:10, b:20) 传递引用 inout &amp;123456789101112131415var variable: Int = 1func changeNumber(num:inout Int) &#123; num = 4 print(&quot;num:\\(num)&quot;)&#125;changeNumber(num: &amp;variable)print(&quot;variable:\\(variable)&quot;)/*num:4variable:4*/ &amp;的使用确实将实参的内存地址传入函数（实参进行引用传递），但changeNumber内部并未操作指针，而是采取了Copy In Copy Out的做法： 调用该函数时，先复制实参的值，产生副本【get】 将副本的内存地址传入函数（副本进行引用传递），在函数内部可以修改副本的值 函数返回后，再将副本的值覆盖实参的值【set】 @State $ @Binding@State是一个属性包装器(property wrapper),被设计用来针对值类型进行状态管理,用于在Struct中mutable值类型.@Binding的作用是在保存状态的属性和更改数据的视图之间创建双向连接，将当前属性连接到存储在别处的单一数据源（single source of truth），而不是直接存储数据。将存储在别处的值语意的属性转换为引用语义，在使用时需要在变量名加$符号。 1234567891011121314151617181920212223242526272829303132333435363738//Modelstruct Product:Identifiable &#123; var isFavorited:Bool var title:String var id: String&#125;//SubViewstruct FilterView: View &#123; @Binding var showFavorited: Bool //3 var body: some View &#123; Toggle(isOn: $showFavorited) &#123; //4 Text(&quot;Change filter&quot;) &#125; &#125;&#125;//ParentViewstruct ProductsView: View &#123; let products: [Product] = [ Product(isFavorited: true, title: &quot;ggggg&quot;,id: &quot;1&quot;), Product(isFavorited: false, title: &quot;3333&quot;,id: &quot;2&quot;)] @State private var showFavorited: Bool = false //1 var body: some View &#123; List &#123; FilterView(showFavorited: $showFavorited) //2 ForEach(products) &#123; product in if !self.showFavorited || product.isFavorited &#123; Text(product.title) &#125; &#125; &#125; &#125;&#125; 对于 @State 修饰的属性的访问，只能发生在 body 或者 body 所调用的方法中。你不能在外部改变 @State 的值，只能@State初始化时，设置初始化值，它的所有相关操作和状态改变都应该是和当前 View 生命周期保持一致。(至于对@State值使用init()初始化的问题,见 “如何使用init()初始化@State” ) 在引用包装为@State的属性时，如果是读写都有，引用属性需要$开头，如果只读直接使用变量名即可 State针对具体View的内部变量进行管理，不应该从外部被允许访问，所以应该标记为private 如何使用init()初始化@State12345@State private var string: Stringinit(string: String) &#123; self.string = string // 会报错&#125; 应该是: 1_string = State(initialValue: string) .onChange()监视@State属性值的变化,而非通过设置@State属性的didSet方法！例如： 1234567891011121314151617181920struct ContentView: View &#123; @State private var blurAmount = 0.0 &#123; didSet &#123; print(&quot;New value is \\(blurAmount)&quot;) &#125; &#125; var body: some View &#123; VStack &#123; Text(&quot;Hello, World!&quot;) .blur(radius: blurAmount) Slider(value: $blurAmount, in: 0...20) Button(&quot;Random Blur&quot;) &#123; blurAmount = Double.random(in: 0...20) &#125; &#125; &#125;&#125; 以上代码,按下Button时,会打印blurAmount的值;而拉动Slider条的情况下,是不会打印blurAmount的值的。 如何解决: – 使用.onChange() 123456789101112131415struct ContentView: View &#123; @State private var blurAmount = 0.0 var body: some View &#123; VStack &#123; Text(&quot;Hello, World!&quot;) .blur(radius: blurAmount) Slider(value: $blurAmount, in: 0...20) .onChange(of: blurAmount) &#123; newValue in print(&quot;New value is \\(newValue)&quot;) &#125; &#125; &#125;&#125; 所以,不添加@State属性的didSet功能,而是使用.onChange来监视blurAmount的值的变化。 具体原因: https://www.hackingwithswift.com/books/ios-swiftui/responding-to-state-changes-using-onchange 改变icon的默认颜色如果是一个google的图标,默人颜色是黑色的,用Image引用后,想让它的颜色变成是绿色,可以这样做： 12345678Image(&quot;google&quot;) .renderingMode(.template) .resizable() //.aspectRatio(contentMode:.fit) .scaleToFit() .frame(width:200,height:200) //.clipped() .foregroundColor(.green) 切记: 需要使用.renderingMode(.template),这样才能改变前景色. 若不想每次都使用.renderingMode(.template),怎么办？可以在Assets.xcassets中找到图片,打开右上角的Inspectors,Image Set中,Render As选项默认是Default,选择为Template Image即可。 GridItem &#x2F; LazyVGrid &#x2F; LazyHGrid &#x2F; Section 实现excel的行和列适用于批量显示照片等,或者说,就是说可以像 excel 一样显示columns&#x2F;rows一样类似表格的东西： 1234567891011121314151617181920212223242526272829303132struct GridBootcamp: View &#123; // 常量columns中的 所有元素 表示每一行(row)中的所有列(column)的属性！ // 下面说明有五列,各个列的size有大有小 let columns: [GridItem] = [ GridItem(.fixed(50), spacing: nil, alignment: nil), GridItem(.fixed(50), spacing: nil, alignment: nil), GridItem(.fixed(100), spacing: nil, alignment: nil), GridItem(.fixed(75), spacing: nil, alignment: nil), GridItem(.fixed(50), spacing: nil, alignment: nil) ] // 上面的.fixed()可以换成.flexible() / .adaptive()来灵活使用列的宽度 // 但是使用.adaptive()的情况下,不一定表示一行只有两列,比如下面的: // let columns: [GridItem] = [ // GridItem(.adaptive(minimum: 50, maximum: 300), spacing: nil, alignment: nil), // GridItem(.adaptive(minimum: 150, maximum: 300), spacing: nil, alignment: nil) // ] // 就会变成一行有四列,它是智能选择排列的. // 我感觉就是,只要有这两个GridItem能尽量多的满足到,在实在无法满足其一的情况下,给我尽量满足其二吧. var body: some View &#123; // 这里是 // LazyVGrid(columns:content:) // 的使用: LazyVGrid(columns: columns) &#123; ForEach(0..&lt;50) &#123; index in Rectangle() .frame(height:50) &#125; &#125; &#125;&#125; 另一种使用方式,更复杂一些,但用处挺大: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct GridBootcamp: View &#123; let columns: [GridItem] = [ GridItem(.flexible(), spacing: nil, alignment: nil), GridItem(.flexible(), spacing: nil, alignment: nil), GridItem(.flexible(), spacing: nil, alignment: nil) ] var body: some View &#123; ScrollView &#123; // 这里可以作为标题内容啥的 Rectangle() .fill(Color.orange) .frame(height: 200) // 这里是 // LazyVGrid(columns:alignment:spacing:pinnedViews:content:) // 的使用: // // 这里的spacing是每行之间的间距,不是每列的间距 // pinnedViews是个列表,里面可以放.sectionHeaders/.sectionFs,当上拉到顶时会固定置顶 LazyVGrid(columns: columns, alignment: .center, spacing: nil, pinnedViews: [.sectionHeaders]) &#123; Section(header: Text(&quot;Section 1&quot;) .frame(maxWidth: .infinity, alignment: .leading) .font(.title) .background(Color.blue) .foregroundColor(.white) .padding() ) &#123; ForEach(0..&lt;50) &#123; index in Rectangle() .fill(Color.gray) .frame(height:150) &#125; &#125; Section(header: Text(&quot;Section 2&quot;) .frame(maxWidth: .infinity, alignment: .leading) .font(.title) .background(Color.red) .foregroundColor(.white) .padding() ) &#123; ForEach(0..&lt;50) &#123; index in Rectangle() .fill(Color.green) .frame(height:150) &#125; &#125; &#125; &#125; &#125;&#125; .ignoresSafeArea() &#x2F; .edgesIgnoringSafeArea().edgesIgnoringSafeArea() – Deprecated on iOS 13.0–15.2 SafeArea 是指不包含上下边界的范围. .edgesIgnoringSafeArea(.top) – 会包含到上边界,但不包含下边界.edgesIgnoringSafeArea(.bottom) – 会包含到下边界,但不包含上边界.edgesIgnoringSafeArea(.all) – 既包含上边界也包含下边界建议的做法:1.用ZStack,最底层设置.edgesIgnoringSafeArea(.all),最外层也就是包含content的不需要设置。2.在View外层使用背景色来.edgesIgnoringSafeArea(.all).代码如下: 12345678ScrollView &#123; // There is something ...&#125;// .background(Color.red) 你还可以在这里再加一层背景,但这层背景并不包含上下边界.background( Color.orange .edgesIgnoringSafeArea(.all)) .ignoresSafeArea()现在建议用.ignoresSafeArea(),而不是.edgesIgnoringSafeArea(） .ignoresSafeArea(edges: .top).ignoresSafeArea(edges: .bottom).ignoresSafeArea(edges: .all) statusBar – safeArea区域的状态栏是否显示的功能123456789101112struct ContentView: View &#123; @State private var hideStatusBar = false var body: some View &#123; Button(&quot;Toggle Status Bar&quot;) &#123; withAnimation &#123; hideStatusBar.toggle() &#125; &#125; .statusBar(hidden: hideStatusBar) &#125;&#125; NavigationView的Title设置NavigationView中设置.navigationTitle： 123456789101112131415NavigationView &#123; ScrollView &#123; SomeView() .navigationTitle(&quot;NavigationTitle&quot;) .navigationBaeTitleDisplayMode(.automatic) // .inline // .large // .automatic 相对比较好。一开始是.large大小,ScrollView上滑后,字体会变小成为.inline并留存在上方。 // .navigationBarHidden(true) 会隐藏该title,甚至包括返回键 // 那么隐藏了返回键,怎么返回上一个页面,可以使用 // @Environment(\\.presentationMode) var presentationMode // presentationMode.wrappedValue.dismiss() &#125;&#125; Dark Mode在Assets.xcassets中添加New Color Set,可以取名AdaptiveColor,这时在两个颜色中分别设置,比如Any Appearance设置成绿色,Dark Apeearance设置成黄色.使用的时候可以:.foregroundColor(Color(“AdaptiveColor”))或者:取得环境变量 @Environment(.colorScheme) var colorScheme.foregroundColor(colorScheme &#x3D;&#x3D; .light ? .green : .yellow) 储存数据两种方法: UserDefaults 以及 @AppStorage。先有前者,后面这种方法更方便,所以推荐用@AppStorage 此外,资料中建议:UserDefaults中存储的数据总量不要超过512K,不然会让app的启动变慢,因为app的启动会加载UserDefaults中的所有数据。 这是UserDefaults实际使用中的方法及可以储存的各种对象,包括到了Object对象,未验证,但下面笔记中已经讲到了struct对象的储存: http://t.zoukankan.com/hero11223-p-7655308.html UserDefaults.standard.setUserDefaults.standard.set() 设置值:[ UserDefaults.standard is the built-in instance of UserDefaults. So if you want to share defaults across several app extensions you might create your own UserDefaults instance. ] 123456789101112131415161718192021222324struct Test0011: View &#123; @State var currentName: String var body: some View &#123; VStack(spacing: 20) &#123; Text(currentName ?? &quot;Add name here&quot;) Button(&quot;Save&quot;.uppercased()) &#123; let name: String = &quot;Nick&quot; currentName = name // name这个位置可以放任何类型的变量,比如String/Bool/Array,表示你要存储的变量是什么 // forKey是放置该存储变量的key,以后调用就需要使用该key UserDefaults.standard.set(name, forKey: &quot;name&quot;) &#125; &#125; .onAppear &#123; // 这里是如何调用该存储的变量值 // 如果要读取的数据是int,则要写成UserDefaults.standard.integer(forKey:) currentName = UserDefaults.standard.string(forKey: &quot;name&quot;) &#125; &#125;&#125; UserDefaults储存Struct对象存储Struct对象的前提是,该Struct必须遵循Codable协议,例如: 12345struct User: Codable &#123; let firstName: String let lastName: String&#125;@State private var user = User(firstName: &quot;Taylor&quot;, lastName: &quot;Swift&quot;) To convert our user data into JSON data, we need to call the encode() method on a JSONEncoder. This might throw errors, so it should be called with try or try? to handle errors neatly. For example, if we had a property to store a User instance, like user above.Then we could create a button that archives the user and save it to UserDefaults like this: 1234567Button(&quot;Save User&quot;) &#123; let encoder = JSONEncoder() if let data = try? encoder.encode(user) &#123; UserDefaults.standard.set(data, forKey: &quot;UserData&quot;) &#125;&#125; It’s designed to store any kind of data you can think of, such as strings, images, zip files, and more. Here, though, all we care about is that it’s one of the types of data we can write straight into UserDefaults.取值:When we’re coming back the other way – when we have JSON data and we want to convert it to Swift Codable types – we should use JSONDecoder rather than JSONEncoder(), but the process is much the same. 123456789101112131415161718192021222324252627282930313233343536373839struct iExpense: View &#123; @State private var user = User(firstName: &quot;Tom&quot;, lastName: &quot;Hanks&quot;) var body: some View &#123; NavigationView &#123; VStack &#123; Form &#123; Text(&quot;The name is : \\(user.firstName) \\(user.lastName)&quot;) Section &#123; HStack &#123; Text(&quot;FirstName:&quot;) TextField(&quot;Input FirstName&quot;, text: $user.firstName) &#125; HStack &#123; Text(&quot;LastName:&quot;) TextField(&quot;Input LastName&quot;, text: $user.lastName) &#125; &#125; &#125; Button(&quot;Save user&quot;) &#123; let encoder = JSONEncoder() if let data = try? encoder.encode(user) &#123; UserDefaults.standard.set(data, forKey: &quot;user&quot;) &#125; &#125; .buttonStyle(.automatic) &#125; &#125; .onAppear &#123; let decoder = JSONDecoder() guard let data = try? UserDefaults.standard.data(forKey: &quot;user&quot;) else &#123; return &#125; guard let user = try? decoder.decode(User.self, from: data) else &#123; return &#125; self.user = user &#125; &#125;&#125; 以上虽然是针对struct对象的,但针对class对象,我觉得其实原理是一样的。 UserDefaults取出数据When you’re reading values from UserDefaults you need to check the return type carefully to ensure you know what you’re getting. Here’s what you need to know: integer(forKey:) returns an integer if the key existed, or 0 if not. bool(forKey:) returns a boolean if the key existed, or false if not. float(forKey:) returns a float if the key existed, or 0.0 if not. double(forKey:) returns a double if the key existed, or 0.0 if not. object(forKey:) returns Any? so you need to conditionally typecast it to your data type. 使用 object(forKey:) 取出数据时,你得typecast,就是需要使用到 as? as! 来optionally typecast &#x2F; force typecast 你的结果,但as!不推荐,因为一旦数据不对就会造成崩溃,所以一般推荐的方式是使用nil coalescing operaton: 12let array = defaults.object(forKey:&quot;SavedArray&quot;) as? [String] ?? [String]()let dict = defaults.object(forKey: &quot;SavedDict&quot;) as? [String: String] ?? [String: String]() @AppStorage@AppStorage is for reading and writing data in UserDefaults. 相较于UserDefaults.standard.set, @AppStorage非常的简单易用,只需要一行的代码量,而不是两行。 1234567891011121314151617struct Test0011: View &#123; // 只要这一条命令,后续 赋值/取值/存储 都只使用这个currentName变量即可,非常方便 // 但试了下,存储&quot;对象&quot;会出问题,还是得使用UserDefaults @AppStorage(&quot;name&quot;) var currentName: String? var body: some View &#123; VStack(spacing: 20) &#123; Text(currentName ?? &quot;Add name here&quot;) Button(&quot;Save&quot;.uppercased()) &#123; let name: String = &quot;Emily&quot; currentName = name &#125; &#125; &#125;&#125; 以上如果代码是： 1@AppStorage(&quot;name&quot;) var currentName: String = &quot;NoName&quot; 代表的意思是： 若key为”name”的@AppStorage有值,则取该值; 若之前没有设定值,则取值为”NoName”。 @SceneStorage – 属性绑定器@SceneStorage存在于每一个scene中,它只在Views中能被获取到。但要注意,它不像@AppStorage和UserDefaults是存储在手机里的,@SceneStorage存储的数据一个是只限于当前页面,此外若关闭程序,数据就会被摧毁。(试着关了一会再打开,但数据仍旧存在,但在xcode上就是关闭后数据就没有了) 很多资料上说,通常用于iPad上的应用程序,但在手机上操作一样可以。 123456789101112struct iExpense: View &#123;// @State private var name: String = &quot;&quot; @SceneStorage(&quot;name&quot;) var name = &quot;&quot; var body: some View &#123; VStack &#123; Button(&quot;The name is \\(name)&quot;) &#123; name = &quot;Stan&quot; &#125; &#125; &#125;&#125; Background Materials.background修饰符内可以使用material,类似于.opacity像垫了一个毛玻璃的效果,但使用起来又比透明度更好、更专业一点。共有五种Material:thinMaterial &#x2F; thickMaterial &#x2F; regularMaterial &#x2F; ultraThinMaterial &#x2F; ultraThickMaterial 。下面用到的是ultraThinMaterial,也是视频中更多推荐的： 123456789101112VStack &#123; Spacer() VStack &#123; Text(&quot;Hello&quot;) &#125; .frame(height: 350) .frame(maxWidth: .infinity) .background(.thinMaterial) .cornerRadius(30)&#125;.ignoresSafeArea() .textSelection(.enabled) 修饰符 – 可让用户选择文本 并 copy&#x2F; share12Text(&quot;This text can be copied or shared.&quot;) .textSelection(.enabled) .enabled是可复制可分享的状况,.disabled是禁止复制和分享。 对文本长按后会出现Copy和DShare的选择性操作: CoreData https://www.hackingwithswift.com/books/ios-swiftui/how-to-combine-core-data-and-swiftui Core Data is capable of sorting and filtering of our data, and can work with much larger data – there’s effectively no limit to how much data it can store. Even better, Core Data implements all sorts of more advanced functionality for when you really need to lean on it: data validation, lazy loading of data, undo and redo, and much more. 所有的Data Model都存在于扩展名为.xcdatamodeld的文件中。所以创建.xcdatamodeld该文件，流程: 创建文件-&gt;选择 Data Model-&gt;命名 即可。这里命名为Bookworm。随后添加Entity为Student,再添加属性id:UUID和name:String。 防止Entity中的某个属性重名带来的麻烦,对该属性进行constraints限制比如一个名为Country的Entity,有fullName和shortName,要求是shortName不能重名,这时候就要对shortName进行constraints限制。操作如下:select the Country entity, go to the View menu and choose Inspectors &gt; Data Model, click the + button under Constraints, and rename the example to “shortName”. 为Entity类的Country在Relationship中添加的candy 增加 One To Many 的属性 https://www.hackingwithswift.com/books/ios-swiftui/one-to-many-relationships-with-core-data-swiftui-and-fetchrequest 选择Country,选择Relationship中的candy,在右侧出现的the data model inspector窗口中,为”Type”选择”To Many”. p.s. Relationships comes in four forms: A one to one relationship means that one object in an entity links to exactly one object in another entity. In our example, this would mean that each type of candy has one country of origin, and each country could make only one types of candy. A one to many relationship means that one object in an entity links to many objects in another entity. In our example, this would mean that one type of candy could have been introduced simultaneously in many countries, but that each country still could only make one type of candy. A many to one relationship means that many objects in an entity link to one object in another entity. In our example. this would mean that each type of candy has one country of origin, and that each country can make many types of candy. A many to many relationship means that many objects in an entity link to many objects in another entity. In our example, this would mean that one type of candy had been introduced simultaneously in many countries, and each country can make many types of candy. 转换NSSet当对两个Entity分别为Candy和Country进行relationship操作时,具体是对Country进行To Many,对Candy增加relationship对上Country,且reverse指向自己,则后续在创建SubClass的时候,Country+CoreDataProperties.swift中就会有一个属性: 12// Country+CoreDataProperties.swift@NSManaged public var candy: NSSet? NSSet是什么？This is the older, Objective-C data type that is equivalent to Swift’s Set, but we can’t use it with SwiftUI’s ForEach.所以需要对NSSet进行转换。转换的过程就是为其添加一个计算属性： 123456public var candyArray: [Candy] &#123; let set = candy as? Set&lt;Candy&gt; ?? [] return set.sorted &#123; $0.wrappedName &lt; $1.wrappedName &#125;&#125; 以上顺便也给排了个序。 创建一个读取CoreData的class类工具12345678910111213141516171819202122import Foundationimport CoreDataclass DataController: ObservableObject &#123; // This tell Core Data we want to use the Bookworm data model. // It does prepare Core Data to load it. // Data models don&#x27;t contain our actual data, // just the definitions of properties. let container = NSPersistentContainer(name: &quot;Bookworm&quot;) init() &#123; // loadPersistentStores is to actually load the data // according to the data model. // this doesn&#x27;t load all the data into memory at the same time. container.loadPersistentStores &#123; description, error in if let error = error &#123; print(&quot;Core Data failed to load: \\(error.localizedDescription)&quot;) &#125; // 还有防止相同值重复写入的代码,见下面一个知识点 &#125; &#125;&#125; 在最外层的拥有@main的文件中在struct中加入该class类工具,作为一个data controller: 1@StateObject private var dataController = DataController() 把他放入SwiftUI的environment环境中: 1234WindowGroup &#123; ContentView() .environment(\\.managedObjectContext, dataController.container.viewContext)&#125; 注意:放入环境中的是由managedObjectContext管理的dataController.container.viewContext！！！文章中是这么说的：All our managed objects live inside a managed object context, one of which we created earlier. Placing it into the SwiftUI environment meant that it was automatically used for the @FetchRequest property wrapper – it uses whatever managed object context is available in the environment.这时候一是可以使用@FetchRequest取得数据,二是可以使用@Environment(.managedObjectContext) var moc来对该managed object context进行操作。 NSPersistentStoreContainer, which handles loading the actual data we have saved to the user’s device. managed object contexts:these are effectively the “live” version of your data – when you load objects and change them, those changes only exist in memory until you specifically save them back to the persistent store. So, the job of the view context is to let us work with all our data in memory, which is much faster than constantly reading and writing data to disk. 对CoreData的class类工具的改进 – 防止相同值重复写入你可以设置某个Entity的属性栏中的Constraints,填入某个自有的特定的Attribute的时候,则无法在save的时候出现重复数据,不然就会报错。但我们又希望即使有重复值,当加入多个同样值的对象,并将这些值写入CoreData的时候,会把重复值剔除,只保留一个: 12345678910111213141516import CoreDataclass DataController: ObservableObject &#123; let container = NSPersistentContainer(name: &quot;CoreDataProject&quot;) init() &#123; container.loadPersistentStores &#123; description, error in if let error = error &#123; print(&quot;Core Data failed to load: \\(error.localizedDescription)&quot;) &#125; // to specify how data should be merged in this situation self.container.viewContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump &#125; &#125;&#125; 这是即使你创建了多个Entity中的重复class对象,当执行moc.save()时,就会遵循上述merge的策略,剔除重复值。具体见: https://www.hackingwithswift.com/books/ios-swiftui/ensuring-core-data-objects-are-unique-using-constraints 但如果你只设置了一个attribute为A的属性不能重复,其他attribute为B的可以重复,这样多个数据,虽然有重复的A,但有不一样的B,系统是如何剔除数据的呢?试了一下,它只保存了一个数据,感觉还是随机只保存了一个数据。 对CoreData的struct工具结构的示例,可以作为常规使用 https://www.hackingwithswift.com/quick-start/swiftui/how-to-configure-core-data-to-work-with-swiftui 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct PersistenceController &#123; // A singleton for our entire app to use static let shared = PersistenceController() // Storage for Core Data let container: NSPersistentContainer // A test configuration for SwiftUI previews static var preview: PersistenceController = &#123; let controller = PersistenceController(inMemory: true) // Create 10 example programming languages. for _ in 0..&lt;10 &#123; let language = ProgrammingLanguage(context: controller.container.viewContext) language.name = &quot;Example Language 1&quot; language.creator = &quot;A. Programmer&quot; &#125; return controller &#125;() // An initializer to load Core Data, optionally able // to use an in-memory store. init(inMemory: Bool = false) &#123; // If you didn&#x27;t name your model Main you&#x27;ll need // to change this name below. container = NSPersistentContainer(name: &quot;Main&quot;) if inMemory &#123; container.persistentStoreDescriptions.first?.url = URL(fileURLWithPath: &quot;/dev/null&quot;) &#125; container.loadPersistentStores &#123; description, error in if let error = error &#123; fatalError(&quot;Error: \\(error.localizedDescription)&quot;) &#125; &#125; &#125; func save() &#123; let context = container.viewContext if context.hasChanges &#123; do &#123; try context.save() &#125; catch &#123; // Show some error here &#125; &#125; &#125;&#125; In the YourProjectNameApp.swift file. First, give your app struct a property to store the persistence controller: 123456let persistenceController = PersistenceController.shared// 其他代码省略ContentView() .environment(\\.managedObjectContext, persistenceController.container.viewContext) In SwiftUI this is done by adding a property to our app struct to monitor the scene phase: 1@Environment(\\.scenePhase) var scenePhase Then you can watch for that changing and call save() every time:p.s.用处之一就是,用户上划退出程序时,马上进行保存操作,放置数据的丢失。 1234567WindowGroup &#123; ContentView() .environment(\\.managedObjectContext, persistenceController.container.viewContext)&#125;.onChange(of: scenePhase) &#123; _ in persistenceController.save()&#125; @FetchRequestRetrieving information from Core Data – using a fetch request@FetchRequest is another property wrapper. It takes at least one parameter describing how we want the results to be sorted. 为何@FetchRequest能获取到数据?(上面重复的一段话,这里也可以使用)All our managed objects live inside a managed object context, one of which we created earlier. Placing it into the SwiftUI environment meant that it was automatically used for the @FetchRequest property wrapper – it uses whatever managed object context is available in the environment. 1@FetchRequest(sortDescriptors: []) var students: FetchedResults&lt;Student&gt; 这里的sort索引为空,取得的数据放在students属性中,该属性的类型是FetchedResults.感觉这样已经是取得了Core Data中的数据了。之后就可以使用这个students属性了。你可以List遍历该students中的属性: 12345VStack &#123; List(students) &#123; student in Text(student.name ?? &quot;Unknown&quot;) &#125;&#125; 这里要明确一点,student.name是一个optional。文章中是这样解释取属性是optional的原因:because all Core Data cares about is that the properties have values when they are saved – they can be nil at other times. 此外,还要明确一点,load了Core Data后, CoreData就会创建一个继承自它自己所本身就有类中的一个,比如现在系统中就有一个类是Student。该继承的类都指向一个基类–NSManagedObject。NSManagedObject: A base class that implements the behavior for a Core Data model object. 1class NSManagedObject : NSObject 所以在我们的代码中看不到这个Student类,因为这是自动产生的,就像Core ML的model一样。 接下来对managed object context进行操作: 1@Environment(\\.managedObjectContext) var moc 可以进行添加和存储对象的操作。 使用moc来对CoreData中的Student类进行创建对象的操作：这里使用到了 Student(context: moc) 123let student = Student(context: moc)student.id = UUID()student.name = &quot;\\(chosenFirstName) \\(chosenLastName)&quot; 最后,对创建的Studet进行储存至CoreData中: 12// 这里没有考虑到失败的情况,实际编码时要调整try? moc.save() 所以,最后创建一个按钮,可以实时创建并保存Student对象,这是上面的完整代码： 12345678910111213Button(&quot;Add&quot;) &#123; let firstNames = [&quot;Ginny&quot;, &quot;Harry&quot;, &quot;Hermione&quot;, &quot;Luna&quot;, &quot;Ron&quot;] let lastNames = [&quot;Granger&quot;, &quot;Lovegood&quot;, &quot;Potter&quot;, &quot;Weasley&quot;] let chosenFirstName = firstNames.randomElement()! let chosenLastName = lastNames.randomElement()! let student = Student(context: moc) student.id = UUID() student.name = &quot;\\(chosenFirstName) \\(chosenLastName)&quot; try? moc.save()&#125; 小总结： @FetchRequest(sortDescriptors: []) var students: FetchedResults可以加载数据; ContentView().environment(.managedObjectContext, dataController.container.viewContext)可供后续@Environment调用; 加载后Student类就可以使用;(貌似什么都不加载的情况下,Student类也可以使用) @Environment(.managedObjectContext) var moc 可以对增加等操作进行保存操作。 @FetchRequest 的具体使用第一种是加在全局变量中的：具体见CoreDataBootcamp项目。视频在: https://www.bilibili.com/video/BV1pb4y1X7ZH?p=15 CoreData &amp;&amp; MVVM 的形式 https://www.bilibili.com/video/BV1pb4y1X7ZH?p=16 Relationships, Predicate 的使用:(more than one hour and it can be understood and how to use properly?) https://www.bilibili.com/video/BV1pb4y1X7ZH?p=17 以下是另一种形式的:视频在: https://www.bilibili.com/video/BV1pb4y1X7ZH?p=16 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import SwiftUIimport CoreDataclass CoreDataViewModel: ObservableObject &#123; let container: NSPersistentContainer // FruitEntity是下面NSFetchRequest&lt;FruitEntity&gt;(entityName: &quot;FruitEntity&quot;) // 中&lt;FruitEntity&gt;定义的 @Published var savedEntities: [FruitEntity] = [] init() &#123; //首先要新建CoreData文件 /* // 加载CoreData文件,但在加载前,记得要建立这个文件, // 通过NewFile-CoreData-DataModel来新建这个CoreData文件 // 文件取名为FruitsContainer.xcdatamodeld,后缀不加的话默认会补上 // 新建后可以看到 AddEntity 按钮,新建Entity后改名为FruitEntity // 随后可以操作这个Entity,感觉这就是个数据库 */ // 加载CoreData文件,只要扩展名.xcdatamodeld前面的主文件名 container = NSPersistentContainer(name: &quot;FruitsContainer&quot;) // 加载CoreData的数据 container.loadPersistentStores &#123; (description, error) in // 这里只设置了error的情况,因为成功的情况没必要做其他事情了 if let error = error &#123; print(&quot;Error Loading Core Data. \\(error)&quot;) &#125; // else &#123; // print(&quot;Successfully loaded core data!&quot;) // &#125; &#125; fetchFruits() &#125; func fetchFruits() &#123; // 使用NSFetchRequest加载entityName,就是CoreData文件中建立的entity名称, // 此外还需要Generic parameter &#x27;ResultType&#x27;, // 且得遵循一个Entity,就是我们上面在CoreData文件中建立的Entity,即FruitEntity, // 而entityName可以随便取名,这里一般遵循名字 相同的原则 // ⚠️ 前面故意将entityName: &quot;FruitEntity&quot;写成entityName: &quot;FruitEntities&quot; // 导致崩溃,且查不到原因 let request = NSFetchRequest&lt;FruitEntity&gt;(entityName: &quot;FruitEntity&quot;) do &#123; savedEntities = try container.viewContext.fetch(request) &#125; catch let error &#123; print(&quot;Error fetching. \\(error)&quot;) &#125; &#125; func addFruit(text: String) &#123; let newFruit = FruitEntity(context: container.viewContext) newFruit.name = text saveData() &#125; func deleteFruit(indexSet: IndexSet) &#123; guard let index = indexSet.first else &#123; return &#125; let entity = savedEntities[index] container.viewContext.delete(entity) saveData() &#125; func updateFruit(entity: FruitEntity) &#123; let currentName = entity.name ?? &quot;&quot; let newName = currentName + &quot;!&quot; entity.name = newName saveData() &#125; func saveData() &#123; do &#123; try container.viewContext.save() fetchFruits() &#125; catch let error &#123; print(&quot;Error Saving. \\(error)&quot;) &#125; &#125;&#125;struct CoreDataBootcamp: View &#123; @StateObject var vm = CoreDataViewModel() @State var textFieldText: String = &quot;&quot; var body: some View &#123; NavigationView &#123; VStack(spacing: 20) &#123; TextField(&quot;Add fruit here...&quot;, text: $textFieldText) .font(.headline) .padding(.leading) .frame(height: 55) .background(Color.gray.opacity(0.3)) .cornerRadius(10) .padding(.horizontal) Button &#123; guard !textFieldText.isEmpty else &#123; return &#125; vm.addFruit(text: textFieldText) textFieldText = &quot;&quot; &#125; label: &#123; Text(&quot;Button&quot;) .font(.headline) .foregroundColor(.white) .frame(height: 55) .frame(maxWidth: .infinity) .background(Color.pink) .cornerRadius(10) .padding(.horizontal) &#125; List &#123; ForEach(vm.savedEntities) &#123; entity in Text(entity.name ?? &quot;No Name&quot;) .onTapGesture &#123; vm.updateFruit(entity: entity) &#125; &#125; .onDelete(perform: vm.deleteFruit) &#125; .listStyle(PlainListStyle()) &#125; .navigationTitle(&quot;Fruits&quot;) &#125; &#125;&#125;struct CoreDataBootcamp_Previews: PreviewProvider &#123; static var previews: some View &#123; CoreDataBootcamp() &#125;&#125; Relationships的实际运用,以及配合使用到的Predicate，如何在项目中很好地利用到：先看一下这篇文章:聊一下在SwiftUI中使用CoreData https://zhuanlan.zhihu.com/p/269441493 @FetchRequest的sortDescriptors的使用:以title字段排序:123@FetchRequest(sortDescriptors: [ SortDescriptor(\\.title)]) var books: FetchedResults&lt;Book&gt; 以title字段逆向排序:1SortDescriptor(\\.title, order: .reverse) 以title和author两个字段依序排序:1234@FetchRequest(sortDescriptors: [ SortDescriptor(\\.title), SortDescriptor(\\.author)]) var books: FetchedResults&lt;Book&gt; @FetchRequest的NSPredicate的使用 https://www.hackingwithswift.com/books/ios-swiftui/filtering-fetchrequest-using-nspredicate NSPredicate的一般用法之前使用到的 @FetchRequest(sortDescriptors: []) var books: FetchedResults其实还能在@FetchRequest中加一个predicate参数,作用是对按要求取的自己想要的数据。一般用法: 1@FetchRequest(sortDescriptors: [], predicate: nil) var ships: FetchedResults&lt;Ship&gt; 这是默认的没有要求的取数据的做法。 假设我们以universe属性来取值,要求其的值等于’Star Wars’,我们就可以这样写: 1@FetchRequest(sortDescriptors: [], predicate: NSPredicate(format: &quot;universe == &#x27;Star Wars&#x27;&quot;)) var ships: FetchedResults&lt;Ship&gt; 但是既有单引号又有双引号,看起来不是那么舒服,所以可以这样,也推荐这样: 1@FetchRequest(sortDescriptors: [], predicate: NSPredicate(format: &quot;universe == %@&quot;, &quot;Star Wars&quot;))) var ships: FetchedResults&lt;Ship&gt; 除了”&#x3D;&#x3D;”,我们也可以使用 “&lt;” 和 “&gt;”,比如: 1NSPredicate(format: &quot;name &lt; %@&quot;, &quot;F&quot;)) 还可以使用 “IN” : 1NSPredicate(format: &quot;universe IN %@&quot;, [&quot;Aliens&quot;, &quot;Firefly&quot;, &quot;Star Trek&quot;]) 以及 “BEGINSWITH” 和 “CONTAINS”: 12NSPredicate(format: &quot;name BEGINSWITH %@&quot;, &quot;E&quot;))NSPredicate(format: &quot;name CONTAINS %@&quot;, &quot;E&quot;)) 以上都是区分大小写的,因此还有不区分大小写的:[C] – 大写C makes an NSPredicate case-insensitive,小写c makes an NSPredicate case-sensitive。 12NSPredicate(format: &quot;name BEGINSWITH[c] %@&quot;, &quot;e&quot;))NSPredicate(format: &quot;name CONTAINS[c] %@&quot;, &quot;e&quot;)) 以及使用 “NOT” 进行条件取反的: 1NSPredicate(format: &quot;NOT name BEGINSWITH[c] %@&quot;, &quot;e&quot;)) 还有条件里使用 “AND” 来进行联合操作。 使用 “&#x3D;” 来判断条件的: 1NSPredicate(format: &quot;age = %i&quot;, 33) // 我这里应该是写错了,应该是== 为什么这里用%i而不是用%K或者%@?:%K是an argument substitution for indicating a keypath.%@是不是因为它会有双引号包着,而这里不能放String类型,而是数字类型,所以才出现了%i。 还有使用 “AND” 或者 “NSCompoundPredicate” 进行复合条件操作的。这个也非常重要,后续还要再添加相应的笔记。 使用@FetchRequest的NSPredicate制作一个Dynamically filtering动态过滤的view页面 https://www.hackingwithswift.com/books/ios-swiftui/dynamically-filtering-fetchrequest-with-swiftui 为什么会有这个问题？我们为什么不能建立一个类似 @FetchRequest(sortDescriptors: [], predicate: NSPredicate(format: “universe &#x3D;&#x3D; %@”, “Star Wars”))) var ships: FetchedResults ,随后”Star Wars”使用变量来进行动态地改变,那不就能够动态取值了吗？答案是,@FetchRequest是被创建的一个属性,如果你将引用到的其他值进行改变,@FetchRequest是会拒绝这个改变的,它就当什么都没发生。 因此,就得按照下面的流程操作：（感觉原理其实就是,在ContentView中插入一个View,这里View里有@FetchRequest,每当ContentView更新的时候,里面那个View也更新,@FetchRequest就会接收到新的变量传来的数据,其就会去请求CoreData数据库。） 先得按照 “Creating NSManagedObject subclasses” 这一节创建一个subclass,这个entity名为Singer.随后将新创建的Singer+CoreDataProperties.swift进行修改(就是增加二个变量): 12345678910111213141516171819202122232425262728// Singer+CoreDataProperties.swiftimport Foundationimport CoreDataextension Singer &#123; @nonobjc public class func fetchRequest() -&gt; NSFetchRequest&lt;Singer&gt; &#123; return NSFetchRequest&lt;Singer&gt;(entityName: &quot;Singer&quot;) &#125; @NSManaged public var firstName: String? @NSManaged public var lastName: String? // 新增的第一个变量 var wrappedFirstName: String &#123; firstName ?? &quot;Unknown&quot; &#125; // 新增的第二个变量 var wrappedLastName: String &#123; lastName ?? &quot;Unknown&quot; &#125;&#125;extension Singer : Identifiable &#123;&#125; 但我感觉这新增的两个变量不加也行,就是你得后续一直使用 nil coalescing,所以这一步建议还是要有的吧。 新建一个FilteredList.swift文件: 12345678910111213141516171819// FilteredList.swiftimport SwiftUIstruct FilteredList: View &#123; @FetchRequest var fetchRequest: FetchedResults&lt;Singer&gt; init(filter: String) &#123; // 像设置@State变量的值一样 _fetchRequest = FetchRequest&lt;Singer&gt;(sortDescriptors: [], predicate: NSPredicate(format: &quot;lastName BEGINSWITH %@&quot;, filter)) &#125; var body: some View &#123; List(fetchRequest, id:\\.self) &#123; singer in Text(&quot;\\(singer.wrappedFirstName) \\(singer.wrappedLastName)&quot;) &#125; &#125;&#125;// 下面不要preview了,因为没必要 最后ContentView.swift: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ContentView.swiftimport SwiftUIstruct ContentView: View &#123; @Environment(\\.managedObjectContext) var moc @State private var lastNameFilter = &quot;A&quot; var body: some View &#123; VStack &#123; FilteredList(filter: lastNameFilter) Button(&quot;Add Examples&quot;) &#123; let taylor = Singer(context: moc) taylor.firstName = &quot;Taylor&quot; taylor.lastName = &quot;Swift&quot; let ed = Singer(context: moc) ed.firstName = &quot;Ed&quot; ed.lastName = &quot;Sheeran&quot; let adele = Singer(context: moc) adele.firstName = &quot;Adele&quot; adele.lastName = &quot;Adkins&quot; if moc.hasChanges &#123; try? moc.save() &#125; &#125; Button(&quot;Show A&quot;) &#123; lastNameFilter = &quot;A&quot; &#125; Button(&quot;Show S&quot;) &#123; lastNameFilter = &quot;S&quot; &#125; &#125; &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() &#125;&#125; 以上代码的作用是:“Add Examples”按钮新增CoreData数据,“Show A”按钮只显示以字幕A开头的数据,“Show S”按钮只显示以字幕S开头的数据。 关于页面更新时向CoreData取值的效率说明:页面每次更新,也会重新创建fetch request,那是不是也是每次都会向CoreData再次查询取值呢？要是这样的话,就会很恐怖,一直在跑数据库,效率肯定会低下。幸运的是，并不是这样。以上代码只在filter string更改的时候,才会重新向CoreData发出查询的请求。 此外,上述代码只能适用于Singer,但不适用于任意的NSManagedObject(这就是Entity类的class类型,比如之前的Singer),因此,需要再行更改: 123456789101112131415161718struct FilteredList&lt;T: NSManagedObject, Content: View&gt;: View &#123; @FetchRequest var fetchRequest: FetchedResults&lt;T&gt; let content: (T) -&gt; Content init(filterKey: String, filterValue: String, @ViewBuilder content: @escaping (T) -&gt; Content) &#123; // %@不能用在attribute names中,因为会加引号, // 所以使用到%K,就不会加引号了 _fetchRequest = FetchRequest&lt;T&gt;(sortDescriptors: [], predicate: NSPredicate(format: &quot;%K BEGINSWITH %@&quot;, filterKey, filterValue)) self.content = content &#125; var body: some View &#123; List(fetchRequest, id:\\.self) &#123; singer in self.content(singer) &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839struct ContentView: View &#123; @Environment(\\.managedObjectContext) var moc @State private var lastNameFilter = &quot;A&quot; var body: some View &#123; VStack &#123; FilteredList(filterKey: &quot;lastName&quot;, filterValue: lastNameFilter) &#123; (singer: Singer) in Text(&quot;\\(singer.wrappedFirstName) \\(singer.wrappedLastName)&quot;) &#125; Button(&quot;Add Examples&quot;) &#123; let taylor = Singer(context: moc) taylor.firstName = &quot;Taylor&quot; taylor.lastName = &quot;Swift&quot; let ed = Singer(context: moc) ed.firstName = &quot;Ed&quot; ed.lastName = &quot;Sheeran&quot; let adele = Singer(context: moc) adele.firstName = &quot;Adele&quot; adele.lastName = &quot;Adkins&quot; if moc.hasChanges &#123; try? moc.save() &#125; &#125; Button(&quot;Show A&quot;) &#123; lastNameFilter = &quot;A&quot; &#125; Button(&quot;Show S&quot;) &#123; lastNameFilter = &quot;S&quot; &#125; &#125; &#125;&#125; 在preview页面中如何加载CoreData中entity引入的class类？12345678910111213141516struct DetailView_Previews: PreviewProvider &#123; static let moc = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType) static var previews: some View &#123; let book = Book(context: moc) book.title = &quot;Test book&quot; book.author = &quot;Test author&quot; book.genre = &quot;Fantasy&quot; book.rating = 4 book.review = &quot;This was a great book; I really enjoyed it.&quot; return NavigationView &#123; DetailView(book: book) &#125; &#125;&#125; 从CoreData中删除一个对象123456@Environment(\\.managedObjectContext) var moc...//假设CoreData中有实体Book,而book是其的一个实例moc.delete(book)...// 接下来可以做dismiss页面等一系列的操作 对@FetchRequest进行row limiting的操作,即只取限定的记录数,而非全部很多时候,我们只要取前几个记录就可以,那么如何操作实现这个row limiting?原理就是:首先,不要急于去生成这个@FetchRequest的全部,而是不带初始化的生成。 1@FetchRequest var languages: FetchedResults&lt;ProgrammingLanguage&gt; 随后,在init初始化中去设置这个@FetchRequest。比如说: 123456init() &#123; let request: NSFetchRequest&lt;ProgrammingLanguage&gt; = ProgrammingLanguage.fetchRequest() request.fetchLimit = 10 _languages = FetchRequest(fetchRequest: request)&#125; 但是,我们要sorting,甚至是filtering,最后再row limiting,应该这样: 1234567891011init() &#123; let request: NSFetchRequest&lt;ProgrammingLanguage&gt; = ProgrammingLanguage.fetchRequest() request.predicate = NSPredicate(format: &quot;active = true&quot;) request.sortDescriptors = [ NSSortDescriptor(keyPath: \\ProgrammingLanguage.name, ascending: true) ] request.fetchLimit = 10 _languages = FetchRequest(fetchRequest: request)&#125; 对从CoreData中的增删改进行保存操作接着上面的“从CoreData中删除一个对象” 1try? moc.save() 对有更改的数据才进行保存操作即Conditional saving of NSManagedObjectContext这样用: 123if moc.hasChanges &#123; try? moc.save()&#125; Creating NSManagedObject subclassesCoreData中load到的存储对象等数据,其的属性有很多都是带有optional的,因此要写很多nil coalescing,比如: 1book.name ?? &quot;Unknown name&quot; 为了解决要写那么多nil coalescing的烦恼,可以这样做： https://www.hackingwithswift.com/books/ios-swiftui/creating-nsmanagedobject-subclasses表述相对会比较复杂,所以还是看上述网址的文章吧。(详细讲明了具体原因,也写出了解决的办法) Entity中特殊属性的建立若属性是 含有字符串列表 的情况例如，我们要建议一个属性为tag:[String],那么如何在CoreData里建立的Entity中创建这个属性？其实我们是不能在CreoData中建立这样的属性的。我们可以这样,假设我们是从网络上获取到json数据中有这个属性:例如Entity名为CachedUser中,则添加Attribute名为tags,设置types为String,因为没有[String]之类的可以给你选择。再假设我们有Struct为User的结构,里面的tags:[String]是这样的。我们先: 1234// 获取到json数据let (data, _) = try await URLSession.shared.data(from: url)// decode成User结构let users = try decoder.decode([User].self, from: data) 其次,通过await MainActor.run 来调用方法在main thread中更新数据: 123await MainActor.run &#123; updateCache(with: users)&#125; 最后，我们定义的updateCache(with downloadedUsers: [User])方法是这样的: 123456789101112func updateCache(with downloadedUsers: [User]) &#123; for user in downloadedUsers &#123; let cachedUser = CachedUser(context: moc) // 其他属性全部省略了 // 使用user.tags.joined(separator: &quot;,&quot;)方法把这个列表全部串起来,串成一个字符串 cachedUser.tags = user.tags.joined(separator: &quot;,&quot;) &#125; try? moc.save()&#125; 上面用到了user.tags.joined(separator: “,”)方法把列表中的字符串连接起来,接下来也可以使用components(separatedBy:)把连接起来的字符串再分割成列表。 若属性是 含有Struct结构的列表 的情况假设我们有二个结构分别为User,Friend.而User中有一个属性是friends:[Friend]。而我们在CoreData中的二个Entity分别是CachedUser和CachedFriend,如何在CachedUser中设置这个friends属性？首先,你在attribute类目中是完全不能添加这个friends属性的,所以我们首先要将CachedUser和CachedFriend的Codegen都设置为Manual&#x2F;None.其次,回到CachedUser这个Entity,在Relationship中建立:Relationship:friends Destination:CachedFriend Inverse: 这个还不能建立,等设置完CachedFriend,就会自动选择的。再次,该relationShip的Type一定要选择成”To Many”,如图：那么,也要在CachedFriend这个Entity,在Relationship中建立:Relationship:user Destination:CachedUser这里Inverse:选择friends，则上面的CachedUser的Inverse就会自动指向user,那就会让两个entity的各一个relationship互相指向对方。此外,别忘了该relationship的Type一定要选择成”To One”,如图:此时,菜单中Editor-&gt;Create NSManagedObject Subclass,会分别为该二个Entity建立两个文件,是CachedUser+CoreDataClass &#x2F; CachedUser+CoreDataProperties &#x2F; CachedFriend+CoreDataClass &#x2F; CachedFriend+CoreDataProperties。在CachedUser+CoreDataProperties中,我们可以看到:@NSManaged public var friends: NSSet?我们需要为其建立一个array属性,便于我们调用: 1234567var friendsArray: [CachedFriend] &#123; let set = friends as? Set&lt;CachedFriend&gt; ?? [] return set.sorted &#123; $0.wrappedName &lt; $1.wrappedName &#125;&#125; 那么,最后就是将json数据转成struct再转成CoreData的entity的属性了: 1234// 获取到json数据let (data, _) = try await URLSession.shared.data(from: url)// decode成User结构let users = try decoder.decode([User].self, from: data) 其次,通过await MainActor.run 来调用方法在main thread中更新数据: 123await MainActor.run &#123; updateCache(with: users)&#125; 我们定义的updateCache(with downloadedUsers: [User])方法是这样的: 1234567891011121314151617181920212223func updateCache(with downloadedUsers: [User]) &#123; for user in downloadedUsers &#123; let cachedUser = CachedUser(context: moc) // 其他属性全部省略了 let cachedUser = CachedUser(context: moc) // 其他属性就省略了 for friend in user.friends &#123; let cachedFriend = CachedFriend(context: moc) cachedFriend.id = friend.id cachedFriend.name = friend.name // addToFriends是在CachedUser+CoreDataProperties中已自动建立好的, // 之所以会自动建立好,就是因为之前设置的一系列relationship中的&quot;To Many&quot;/&quot;To One&quot;的结果 cachedUser.addToFriends(cachedFriend) &#125; &#125; try? moc.save()&#125; 以上,具体见 FriendFace 项目。 ScenePhase https://developer.apple.com/documentation/swiftui/scenephase It’s a enumeration.An indication of a scene’s operational state. 取得scenePhase: 1@Environment(\\.scenePhase) private var scenePhase 具体的状态有：.active.inactive.background三种。 测试下来,进入scene时是.active状态,按住home键后进入.inactive状态,上划或者点击桌面的话进入.background状态. .background的使用场景:(onChange监测整个app都被放入后台的时候) 12345678910111213141516@mainstruct MyApp: App &#123; @Environment(\\.scenePhase) private var scenePhase var body: some Scene &#123; WindowGroup &#123; MyRootView() &#125; .onChange(of: scenePhase) &#123; phase in if phase == .background &#123; // Perform cleanup when all scenes within // MyApp go to the background. &#125; &#125; &#125;&#125; 又可以监测scene被放入后台的情况: 123456789101112131415struct MyScene: Scene &#123; @Environment(\\.scenePhase) private var scenePhase var body: some Scene &#123; WindowGroup &#123; MyRootView() &#125; .onChange(of: scenePhase) &#123; phase in if phase == .background &#123; // Perform cleanup when all scenes within // MyScene go to the background. &#125; &#125; &#125;&#125; 监测view是active还是inactive的情况: 1234567891011struct MyView: View &#123; @ObservedObject var model: DataModel @Environment(\\.scenePhase) private var scenePhase var body: some View &#123; TimerView() .onChange(of: scenePhase) &#123; phase in model.isTimerRunning = (phase == .active) &#125; &#125;&#125; #available因为用户ios系统版本的差异,所以引入: 123456if #available(iOS 15, *) &#123; content .listRowSeparator(.hidden)&#125; else &#123; content&#125; @availableYou can mark a function or an entire type as available for a specific operating system using the @available attribute. The function defined below is accessible only in iOS 15.1 and later: 12@available(iOS 15.1, *)func setupGroupSession() &#123;...&#125; Task &#x2F; .task注意一点:如果a是一个异步方法，调用的时候，必须在一个异步的上下文中，具体英语是:you can call an async function only from an asynchronous context.所以这时候就需要在代码中使用到Task{} 或者 .task{} Task使用Task来调取异步函数 1234567891011121314151617181920struct ContentView: View &#123; @StateObject var model = ViewModel() var body: some View &#123; NavigationView &#123; List &#123; Button &#123; Task &#123; await model.refresh() &#125; &#125; label: &#123; Text(&quot;Load Participants&quot;) &#125; ForEach(model.participants) &#123; participant in ... &#125; &#125; &#125; &#125;&#125; .task123456789101112131415VStack &#123; List(results, id:\\.id) &#123; item in Text(&quot;From:\\(item.from)&quot;) .font(.headline) Text(&quot;message:\\(item.message)&quot;) &#125; // .task修饰符只能用在iOS15.0以上 // SwiftUI provides a task modifier that you can use to execute an asynchronous function when a view appears // The system automatically cancels tasks when a view disappears. .task &#123; // loadData()是异步方法,所以需要用await await loadData() &#125;&#125; @discardableResult某些方法等返回的值,有时候不需要用到,但不用的话会收到warnings,这时候可以使用@discardableResult来取消warnings. 123@discardableResultstatic func save(scrums: [DailyScrum]) async throws -&gt; Int &#123;&#125; #if DEBUG &#x2F; #endifThe #if DEBUG flag is a compilation directive that prevents the enclosed code from compiling when you build the app for release. opaque return types例如Equatable协议(Both Int and Bool conform to a common Swift protocol called Equatable, which means “can be compared for equality.”),因为其是“protocol ‘Equatable’ can only be used as a generic constraint because it has Self or associated type requirements”.(就是基类的意思)所以一个property或者function不能直接返回Equatable，而是要做一个处理，这个处理就是some。 -&gt; some Equatable 。这种情况也出现在View中,我们最多看到的 var body: some View {} 也是一样的道理。(So, when you see some View in your SwiftUI code, it’s effectively us telling Swift “this is going to send back some kind of view to lay out, but I don’t want to write out the exact thing – you figure it out for yourself.”) function中接受多个function参数的情况下,这些trailing closures的格式是什么样子的？格式的样例： 12345678910111213141516171819// 需要调用的doImportantWork方法:func doImportantWork(first: ()-&gt; Void, second: ()-&gt; Void, third: ()-&gt; Void) &#123; print(&quot;About to start first work.&quot;) first() print(&quot;About to start second work.&quot;) second() print(&quot;About to start third work.&quot;) third()&#125;// 如果调用该doImportantWord方法,并将三个参数做trailing closures的格式doImportantWork &#123; print(&quot;This is the first work.&quot;)&#125; second: &#123; print(&quot;This is the second work.&quot;)&#125; third: &#123; print(&quot;This is the third work.&quot;)&#125;// 以上除了第一个func不需要写名字,后面的second和third都要写名字 you can make your function accept multiple function parameters if you want, in which case you can specify multiple trailing closures.When it comes to calling that, the first trailing closure is identical to what we’ve used already, but the second and third are formatted differently: you end the brace from the previous closure, then write the external parameter name and a colon, then start another brace the nil coalescing operator 即 ??例一 123456789let captains = [ &quot;Enterprise&quot;: &quot;Picard&quot;, &quot;Voyager&quot;: &quot;Janeway&quot;, &quot;Defiant&quot;: &quot;Sisko&quot;]let new = captains[&quot;Serenity&quot;] ?? &quot;N/A&quot;// 也可以写成下面这样:// let new = captains[&quot;Serenity&quot;, default: &quot;N/A&quot;] 例二 12let tvShows = [&quot;Archer&quot;, &quot;Babylon 5&quot;, &quot;Ted Lasso&quot;]let favorite = tvShows.randomElement() ?? &quot;None&quot; 例三 123456789struct Book &#123; let title: String let author: String?&#125;let book = Book(title: &quot;Beowulf&quot;, author: nil)let author = book.author ?? &quot;Anonymous&quot;print(author)这样author就是一个String,而不是一个optional 例四 1let savedData = first() ?? second() ?? &quot;&quot; Handle function failure with optionalsWe can run throwing functions using do, try, and catch in Swift,but an alternative is to use try? to convert a throwing function call into an optional. 1234567891011121314151617// runRiskyFunction()中一定是定义到了throws,// 才能使用到 try / try? / try!// try 一定要配合 do&#123;&#125;catch&#123;&#125; 使用do &#123; let result = try runRiskyFunction() print(result)&#125; catch &#123; // it failed!&#125;if let result = try? runRiskyFunction() &#123; print(result)&#125;// try? 的情况下,若出错,即返回nil,这种区别于try,它并不注重于出现的error;若不出错,返回的是Optional,切记！// 若使用 try! 的情况下,出错即会让程序崩溃 @FocusStateit’s specifically designed to handle input focus in our UI example: 1234567891011121314151617181920212223242526272829303132333435363738struct FocusStateExample: View &#123; @State private var checkAmount: Double = 0 // 不需要对amountIsFocused设置值,系统自动认定,focus时为true,失去focus时为false @FocusState private var amountIsFocused: Bool var body: some View &#123; NavigationView &#123; Form &#123; Section &#123; // 试了下Locale.current.currencyCode就是美元,可以直接使用&quot;CHY&quot;/(&quot;JPY&quot;)等等 TextField(&quot;Amount&quot;, value: $checkAmount, format: .currency(code: Locale.current.currencyCode ?? &quot;USD&quot;)) // 键盘类型为数字键盘 .keyboardType(.numberPad) // 绑定的$amountIsFocused决定了是否显示键盘 .focused($amountIsFocused) &#125; Section &#123; Text(checkAmount, format: .currency(code: Locale.current.currencyCode ?? &quot;USD&quot;)) &#125; &#125; .navigationTitle(&quot;Title&quot;) .toolbar &#123; // .keyboard 即在显示的键盘上添加按钮 ToolbarItemGroup(placement: .keyboard) &#123; // 因为数字键盘无法从屏幕上取消, // 所以添加Button来控制amountIsFocused Spacer() Button(&quot;Done&quot;) &#123; amountIsFocused = false &#125; &#125; &#125; &#125; &#125;&#125; shuffled()1var countries = [&quot;Estonia&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Ireland&quot;, &quot;Italy&quot;, &quot;Nigeria&quot;, &quot;Poland&quot;, &quot;Russia&quot;, &quot;Spain&quot;, &quot;UK&quot;, &quot;US&quot;].shuffled() As you can see, the shuffled() method automatically takes care of randomizing the array order for us. environment modifier vs regular modifier12345678VStack &#123; Text(&quot;Gryffindor&quot;) .font(.largeTitle) Text(&quot;Hufflepuff&quot;) Text(&quot;Ravenclaw&quot;) Text(&quot;Slytherin&quot;)&#125;.font(.title) 为什么Text(“Gryffindor”)的font不是.title大小的?文章中解释是:font() is an environment modifier, which means the Gryffindor text view can override it with a custom font. 12345678VStack &#123; Text(&quot;Gryffindor&quot;) .blur(radius: 0) Text(&quot;Hufflepuff&quot;) Text(&quot;Ravenclaw&quot;) Text(&quot;Slytherin&quot;)&#125;.blur(radius: 5) 为什么Text(“Gryffindor”)的模糊度和其他的不一样？文章中解释是：That won’t work the same way: blur() is a regular modifier, so any blurs applied to child views are added to the VStack blur rather than replacing it. Views as propertiescreate computed properties of some View: 第一种,放入一个stack中: 123456var spells: some View &#123; VStack &#123; Text(&quot;Lumos&quot;) Text(&quot;Obliviate&quot;) &#125;&#125; 第二种,放入一个Group中: 123456var spells: some View &#123; Group &#123; Text(&quot;Lumos&quot;) Text(&quot;Obliviate&quot;) &#125;&#125; 第三种,使用@ViewBuilder: 1234@ViewBuilder var spells: some View &#123; Text(&quot;Lumos&quot;) Text(&quot;Obliviate&quot;)&#125; 但第三种中,只显示了一个Text。 Core MLXCode中可以使用的 Core ML。ML即Machine Learning。Core ML is capable of handling a variety of training tasks, such as recognizing images, sounds, and even motion. 如何创建项目：Open Developer Tool &gt; Create ML可以看到有非常多的templates可供选择，比如Tabular Regression。 Tabular RegressionPlease choose Tabular Regression and press Next. For the project name please enter name like BetterRest, then press Next, select your desktop, then press Create. https://www.hackingwithswift.com/books/ios-swiftui/training-a-model-with-create-ml The first step is to provide Create ML with some training data. 像例子里提供了一个BetterRest.csv,格式是:wake estimatedSleep coffee actualSleep31500 9 6 3823032400 5 2 20180…So, in Create ML look under Data and select “Select…” under the Training Data title. When you press “Select…” again it will open a file selection window, and you should choose BetterRest.csv.The next job is to decide the target, which is the value we want the computer to learn to predict, and the features, which are the values we want the computer to inspect in order to predict the target. For example, if we chose how much sleep someone thought they needed and how much sleep they actually needed as features, we could train the computer to predict how much coffee they drink.In this instance, I’d like you to choose “actualSleep” for the target, which means we want the computer to learn how to predict how much sleep they actually need. Now press Choose Features, and select all three options: wake, estimatedSleep, and coffee – we want the computer to take all three of those into account when producing its predictions.Below the Select Features button is a dropdown button for the algorithm, and there are five options: Automatic, Random Forest, Boosted Tree, Decision Tree, and Linear Regression. Each takes a different approach to analyzing data, but helpfully there is an Automatic option that attempts to choose the best algorithm automatically. It’s not always correct, and in fact it does limit the options we have quite dramatically, but for this project it’s more than good enough. When you’re ready, click the Train button in the window title bar. After a couple of seconds – our data is pretty small! – it will complete, and you’ll see a big checkmark telling you that everything went to plan. To see how the training went, select the Evaluation tab then choose Validation to see some result metrics. The value we care about is called Root Mean Squared Error, and you should get a value around about 170. This means on average the model was able to predict suggested accurate sleep time with an error of only 170 seconds, or three minutes. Tip: Create ML provides us with both Training and Validation statistics, and both are important. When we asked it to train using our data, it automatically split the data up: some to use for training its machine learning model, but then it held back a chunk for validation. This validation data is then used to check its model: it makes a prediction based on the input, then checks how far that prediction was off the real value that came from the data. Even better, if you go to the Output tab you’ll see an our finished model has a file size of 544 bytes or so. Create ML has taken 180KB of data, and condensed it down to just 544 bytes – almost nothing. Now that our model is trained, I’d like you to press the Get button to export it to your desktop, so we can use it in code. Connecting SwiftUI to Core ML导出的模型是以.mlmodel结尾的文件,把它放入xcode的项目中。 123456789101112131415161718192021222324252627import CoreMLdo &#123; // Configuration是为了让你自定义的时候准备的,一般都用不到 let config = MLModelConfiguration() // using Core ML can throw errors when loading the model. // 导入的文件名是SleepCalculator.mlmodel， // 所以在导入的同时就会创建同名的class let model = try SleepCalculator(configuration: config) // 这里的wakeUp是类似Date.now一样的变量数据 let components = Calendar.current.dateComponents([.hour, .minute], from: wakeUp) let hour = (components.hour ?? 0) * 60 * 60 let minute = (components.minute ?? 0) * 60 // 套入项目数据并使用MachineLearning来预测 let prediction = try model.prediction(wake: Double(hour + minute), estimatedSleep: sleepAmount, coffee: Double(coffeeAmount)) // wakeUp是醒来的时间,prediction.actualSleep是预测要睡多少时间,就可以算出sleepTime即几点睡觉 let sleepTime = wakeUp - prediction.actualSleep alertTitle = &quot;Your ideal bedtime is…&quot; alertMessage = sleepTime.formatted(date: .omitted, time: .shortened)&#125; catch &#123; alertTitle = &quot;Error&quot; alertMessage = &quot;Sorry, there was a problem calculating your bedtime.&quot;&#125; clipped() &#x2F; cornerRadius(:) &#x2F; clipShape(:style)clipped()视图修改器将视图的绘制限制在其绑定frame内，其他所有内容将被隐藏。SwiftUI提供了两个clipped()替代方法:cornerRadius(:)和clipShape(:style)。特别是clipShape(_:style),可以使用任何图形,比如Circle()或者五角星Star(). 针对不同平台的代码适用对iOS() &#x2F; macOS() &#x2F; tvOS() &#x2F; watchOS() 方法的自定义和适用123456789101112131415161718192021222324252627282930313233343536373839extension View &#123; func iOS&lt;Content: View&gt;(_ modifier: (Self) -&gt; Content) -&gt; some View &#123; #if os(iOS) return modifier(self) #else return self #endif &#125;&#125;extension View &#123; func macOS&lt;Content: View&gt;(_ modifier: (Self) -&gt; Content) -&gt; some View &#123; #if os(macOS) return modifier(self) #else return self #endif &#125;&#125;extension View &#123; func tvOS&lt;Content: View&gt;(_ modifier: (Self) -&gt; Content) -&gt; some View &#123; #if os(tvOS) return modifier(self) #else return self #endif &#125;&#125;extension View &#123; func watchOS&lt;Content: View&gt;(_ modifier: (Self) -&gt; Content) -&gt; some View &#123; #if os(watchOS) return modifier(self) #else return self #endif &#125;&#125; 实际的使用: 12Text(&quot;Hello World&quot;) .iOS &#123; $0.padding(10) &#125; .confirmationDialog – 跳出带选项的确认菜单与.alert()修饰符的用法类似,作用也类似。.alert允许我们在上面有一到二个按钮,而.confirmationDialog允许我们加更多的按钮,而且是从bottom向上升起来一部分,不像alert是直接在屏幕中间霸屏。p.s.iOS14之前版本的系统,只能使用ActionSheet。 12345678910111213141516171819202122struct ContentView: View &#123; @State private var showingConfirmation = false @State private var backgroundColor = Color.white var body: some View &#123; Text(&quot;Hello, World!&quot;) .frame(width: 300, height: 300) .background(backgroundColor) .onTapGesture &#123; showingConfirmation = true &#125; .confirmationDialog(&quot;Change background&quot;, isPresented: $showingConfirmation) &#123; Button(&quot;Red&quot;) &#123; backgroundColor = .red &#125; Button(&quot;Green&quot;) &#123; backgroundColor = .green &#125; Button(&quot;Blue&quot;) &#123; backgroundColor = .blue &#125; Button(&quot;Cancel&quot;, role: .cancel) &#123; &#125; &#125; message: &#123; Text(&quot;Select a new color&quot;) &#125; &#125;&#125; DictionaryDictionary(grouping:by:)使用Dictionary对Array里面Struct中的某个property进行分组例如数据是这样的: 12345678910111213141516171819202122232425262728struct ExpenseItem: Identifiable, Codable, Hashable &#123; var id: UUID let name: String let type: String let amount: Double init(id: UUID, name: String, type: String, amount: Double) &#123; self.id = id self.name = name self.type = type self.amount = amount &#125;&#125;class Expenses &#123; @Published var items: [ExpenseItem] = [] init() &#123; items.append(ExpenseItem(id: UUID(), name:&quot;a&quot;, type: &quot;Personal&quot;, amount: 1.0)) items.append(ExpenseItem(id: UUID(), name:&quot;b&quot;, type: &quot;Business&quot;, amount: 2.0)) items.append(ExpenseItem(id: UUID(), name:&quot;c&quot;, type: &quot;Personal&quot;, amount: 3.0)) items.append(ExpenseItem(id: UUID(), name:&quot;d&quot;, type: &quot;Business&quot;, amount: 4.0)) items.append(ExpenseItem(id: UUID(), name:&quot;e&quot;, type: &quot;Personal&quot;, amount: 5.0)) items.append(ExpenseItem(id: UUID(), name:&quot;f&quot;, type: &quot;Business&quot;, amount: 6.0)) &#125;&#125;let expenses = Expenses() 目标:要对expenses中各个ExpenseItem的type进行分类,type为”Personal”、”Business”的分开显示: 1234567// 要对expenses中的type进行分组:// Dictionary(grouping:by:)let dictionaryByType = Dictionary(grouping: expenses.items, by: &#123; $0.type &#125;)print(type(of: dictionaryByType)) // Dictionary&lt;String, Array&lt;ExpenseItem&gt;&gt;let res = [dictionaryByType[&quot;Personal&quot;], dictionaryByType[&quot;Business&quot;]]print(type(of: res)) // Array&lt;Optional&lt;Array&lt;ExpenseItem&gt;&gt;&gt;print(res.count) // 2 Grid做数据表格,与excel类似。1.后续设置LazyVGrid的情况,代表每行有三个单元格;若是LazyHGrid,代表每列有三个单元格: 12345let layout = [ GridItem(.fixed(80)), GridItem(.fixed(80)), GridItem(.fixed(80))] 2.每个单元格的适应大小为不小于80. 123let layout = [ GridItem(.adaptive(minimum: 80)),] 3.每个单元格的适应大小为不小于80也不大于120. 123let layout = [ GridItem(.adaptive(minimum: 80, maximum: 120)),] 二、再在ScrollView中设置LazyVGrid&#x2F;LazyHGrid 1234567ScrollView &#123; LazyVGrid(columns: layout) &#123; ForEach(0..&lt;1000) &#123; Text(&quot;Item \\($0)&quot;) &#125; &#125;&#125; 或者:ScrollView { LazyHGrid(columns: layout) { ForEach(0..&lt;1000) { Text(“Item ($0)”) } }} ColorScheme设置ShapeStyle中的Color的扩展色设置了两个颜色,一个darkBackground和另一个lightBackground. 123456789extension ShapeStyle where Self == Color &#123; static var darkBackground: Color &#123; Color(red: 0.1, green: 0.1, blue: 0.2) &#125; static var lightBackground: Color &#123; Color(red: 0.2, green: 0.2, blue: 0.3) &#125;&#125; 使用这两个颜色的效果图:(主背景色为darkBackground;文字背景色为lightBackground) 告诉系统使用的管用模式是light mode 还是 dark mode1234567NavigationView &#123; ScrollView &#123; // .... &#125; .navigationTitle(&quot;Moonshoot&quot;) .preferredColorScheme(.dark)&#125; 这里选择了dark模式,那么navigationTitle的颜色就会始终是white了。 Equatable协议比如定义了一个数据结构Struct Item,又定义了一个类Class Items,且Items里面包含一个属性items:[Item]。当需要判断某个item是否属于Items,就需要该Item遵守Equatable协议，也就是能让它去比较，接下来就可以用：Items().items.firstIndex(of: item)。比如下面： 12345678910111213141516171819202122232425262728293031323334struct Activity: Codable, Identifiable, Equatable &#123; var id = UUID() var title: String var description: String var completionCount = 0 static let example = Activity(title: &quot;Example Activity&quot;, description: &quot;This is a test activity.&quot;)&#125;class Activities: ObservableObject &#123; @Published var activities: [Activity] &#123; didSet &#123; if let encoded = try? JSONEncoder().encode(activities) &#123; UserDefaults.standard.set(encoded, forKey: &quot;Activities&quot;) &#125; &#125; &#125; init() &#123; if let saved = UserDefaults.standard.data(forKey: &quot;Activities&quot;) &#123; if let decoded = try? JSONDecoder().decode([Activity].self, from: saved) &#123; activities = decoded return &#125; &#125; activities = [] &#125;&#125;// 进行判断,而该判断是基于Activity遵循Equatable协议的if let index = data.activities.firstIndex(of: activity) &#123; data.activities[index] = newActivity&#125; initDesignated Initializers (指定构造器)例如: 123init(parameters) &#123; statements&#125; class类型的构造器代理规则规则有三条，分别是： 指定构造器必须调用其直接父类的的指定构造器。 便利构造器必须调用同类中定义的其它构造器。 便利构造器最后必须调用指定构造器。 总结一下就是：指定构造器必须总是向上代理(去父类)；便利构造器必须总是横向代理(在本类)。如下图所示: 构造器的两个阶段Swift 中类的构造过程包含两个阶段。第一个阶段：给类中的每个存储属性赋初始值。只要每个存储属性初始值被赋值;第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步自定义它们的存储属性。 Swift 通过4步安全检查来确定构造器两个阶段的成功执行：安全检查1:指定构造器必须在完成本类所有存储属性赋值之后，才能向上代理到父类的构造器。 1234567891011class Animal &#123; var head = 1&#125;class Dog: Animal &#123; var foot: Int override init() &#123; super.init() foot = 4 &#125;&#125; 上面的super.init()会报错，因为此时 Dog 的 foot 还没有被赋值。将 init() 改为下面即可： 12345override init() &#123; foot = 4 //这句也可以省略，它默认是隐式调用的。 super.init()&#125; 安全检查2:指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器。 123456//这时，你必须显式的调用super.init()，因为你要修改继承属性- head 的值override init() &#123; foot = 4 super.init() head = 2&#125; 安全检查3:便利构造器必须先调用其他构造器，再为任意属性（包括所有同类中定义的）赋新值。 1234567convenience init(foot: Int) &#123; //先调用其他构造器，如果此处不调用会编译出错 self.init() //再为任意属性（包括所有同类中定义的）赋新值 self.foot = foot head = 3&#125; 安全检查4：构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。 1234567891011121314class Dog: Animal &#123; var foot: Int override init() &#123; foot = 4 super.init() head = 2 // 如果上面的未完成，是不能调用run()的，因为self还没有完整的创建 run() &#125; func run() &#123; //do something &#125;&#125; 现在看一下阶段一和阶段二的完整流程：阶段 1 - 自下而上 类的某个指定构造器或便利构造器被调用。 完成类的新实例内存的分配，但此时内存还没有被初始化。 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。 指定构造器切换到父类的构造器，对其存储属性完成相同的任务。 这个过程沿着类的继承链一直往上执行，直到到达继承链的最顶部。 当到达了继承链最顶部，而且继承链的最后一个类已确保所有的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。 阶段 2 - 自上而下 从继承链顶部往下，继承链中每个类的指定构造器都有机会进一步自定义实例。构造器此时可以访问 self、修改它的属性并调用实例方法等等。 最终，继承链中任意的便利构造器有机会自定义实例和使用 self。 Convenience Initializers(便利构造器) &amp;&amp; override123456789class Food &#123; var name: String init(name: String) &#123; self.name = name &#125; convenience init() &#123; self.init(name: &quot;[Unnamed]&quot;) &#125;&#125; 1234let namedMeat = Food(name: &quot;Bacon&quot;)// namedMeat&#x27;s name is &quot;Bacon&quot;let mysteryMeat = Food()// mysteryMeat&#x27;s name is &quot;[Unnamed]&quot; 再来一个 override convenience init: 12345678910class RecipeIngredient: Food &#123; var quantity: Int init(name: String, quantity: Int) &#123; self.quantity = quantity super.init(name: name) &#125; override convenience init(name: String) &#123; self.init(name: name, quantity: 1) &#125;&#125; Required Initializers(必要构造器)Write the required modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer. 12345678910class SomeClass &#123; required init() &#123; // initializer implementation goes here &#125;&#125;class SomeSubclass: SomeClass &#123; required init() &#123; // subclass implementation of the required initializer goes here &#125;&#125; Rule 1 If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers. 若不定义指定的初始化函数,则全部继承。 Rule 2 If your subclass provides an implementation of all of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers. 若定义了指定的初始化函数,则只继承convenience初始化函数。（是这个意思?) 123456789101112131415161718192021222324class A &#123; var num: Int required init(num: Int) &#123; self.num = num &#125;&#125;class B: A &#123; &#125;var b = B(num: 10)class C: A &#123; init(str: String) &#123; super.init(num: Int(str)!) &#125; required init(num: Int) &#123; super.init(num: num) &#125;&#125;var b1 = C(str: &quot;9&quot;)var b2 = C(num: 9) init(from:)Creates a new instance by decoding from the given decoder. 12// Declaration:init(from decoder: Decoder) throws 对于一个struct中的属性比如说是String、Int等等本身自带遵循Codable协议的,可以不写init(from decoder: Decoder) throws,但如果属性中有比如UIImage类型的,这时候你希望这个struct可以Encodable和Decodable的,你就必须写两个方法,一个是init(from decoder: Decoder) throws,一个是func encode(to encoder: Encoder) throws。例子: 1234567891011121314151617181920212223242526272829303132333435363738394041struct UserImage: Identifiable, Codable &#123; let id: UUID let name: String // 这里的UIImage是不自带遵循Codable协议的 let image: UIImage // 所以需要建立一个遵循CodingKey协议的enum,里面的一个case是上面的image enum CodingKeys: CodingKey &#123; case id, name, image &#125; init(id: UUID, name: String, image: UIImage) &#123; self.id = id self.name = name self.image = image &#125; // 为了让image能被decode,所以要写这个init(from decoder: Decoder) throws初始方法 init(from decoder: Decoder) throws &#123; let container = try decoder.container(keyedBy: CodingKeys.self) id = try container.decode(UUID.self, forKey: .id) name = try container.decode(String.self, forKey: .name) // 感觉是UIImage和原始数据之间需要有一个Data类型来做桥 let imageData = try container.decode(Data.self, forKey: .image) // 这里使用nil coalescing是因为UIImage(data: &lt;#T##Data#&gt;)返回的是一个UIImage？,所以在取不到值的情况下,需要返回空的UIImage() let decodedImage = UIImage(data: imageData) ?? UIImage() image = decodedImage &#125; func encode(to encoder: Encoder) throws &#123; var container = encoder.container(keyedBy: CodingKeys.self) try container.encode(id, forKey: .id) try container.encode(name, forKey: .name) if let jpegData = image.jpegData(compressionQuality: 0.8) &#123; // 感觉这里也是需要用Data类型来做桥 try container.encode(jpegData, forKey: .image) &#125; &#125;&#125; 接下来就是正常decode: 1234var images: [UserImage]let savePath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first?.appendingPathComponent(&quot;ImageContext&quot;)let data = try Data(contentsOf: savePath! )images = try JSONDecoder().decode([UserImage].self, from: data) 也能正常encode: 1let data = try JSONEncoder().encode(images) init?()This is a failable initializer: an initializer that might work or might not. You can write these in your own structs and classes by using init?() rather than init(), and return nil if something goes wrong. The return value will then be an optional of your type, for you to unwrap however you want. 1234567891011struct Person &#123; var id: String init?(id: String) &#123; if id.count == 9 &#123; self.id = id &#125; else &#123; return nil &#125; &#125;&#125; 必须要传入9位的id,不然构造器就会传出一个nil。 AlertAlert(item:content:) – 多个Alert情况的适用123456789101112131415161718192021222324252627282930313233struct AlertData: Identifiable &#123; let id = UUID() let title: Text let message: Text let button: Alert.Button static let firstAlert = AlertData(title: Text(&quot;First Alert&quot;), message: Text(&quot;This is the first alert&quot;), button: .default(Text(&quot;OK&quot;))) static let secondAlert = AlertData(title: Text(&quot;Second Alert&quot;), message: Text(&quot;This is the second alert&quot;), button: .default(Text(&quot;OK&quot;)))&#125;struct MultiAlertExamples: View &#123; @State private var alert: AlertData? var body: some View &#123; VStack(spacing: 20) &#123; Button &#123; alert = AlertData.firstAlert &#125; label: &#123; Text(&quot;Show First Alert&quot;) &#125; Button &#123; alert = AlertData.secondAlert &#125; label: &#123; Text(&quot;Show Second Alert&quot;) &#125; &#125; .alert(item: $alert) &#123; a in Alert(title: a.title, message: a.message, dismissButton: a.button) &#125; &#125;&#125; 注意一点:.alert(item:content)中item属性对应的参数，需要遵循Identifiable协议。 TextEditorTextField is for the users to enter short pieces of text.TextEditor is for the long pieces of text. @ViewBuilder简单来说,就是一个包含多个视图的闭包,或者说,就是一个可以接受多个视图的闭包。在SwiftUI框架中，所有的容器视图都是使用@ViewBuilder来修饰最后一个参数，因此这些容器视图可以接受多个子视图作为参数。比如HStack&#x2F;VStack&#x2F;ScrollView等。 1234567891011121314151617181920212223242526272829import SwiftUIstruct CustomContainerView&lt;Content&gt;: View where Content: View &#123; private let content: Content init(@ViewBuilder content: () -&gt; Content) &#123; self.content = content() &#125; var body: some View &#123; VStack &#123; content .padding() &#125; .foregroundColor(.red) .background(Color.green) .font(.title) &#125;&#125;struct test001: View &#123; var body: some View &#123; CustomContainerView &#123; Text(&quot;A&quot;) Text(&quot;B&quot;) Text(&quot;C&quot;) &#125; &#125;&#125; Type erasureType erasure is the process of hiding the underlying type of some data. This is used often in Swift: we have type erasing wrappers such as AnyHashable and AnySequence, and all they do is act as shells that forward on their operations to whatever they contain, without revealing what the contents are to anything externally. AnyViewIn SwiftUI we have AnyView for this purpose: it can hold any kind of view inside it, which allows us to mix and match views freely, like this: 1234567891011121314struct ContentView: View &#123; var randomText: some View &#123; if Bool.random() &#123; return AnyView(Text(&quot;Hello, World!&quot;) .frame(width: 300)) &#125; else &#123; return AnyView(Text(&quot;Hello, World!&quot;)) &#125; &#125; var body: some View &#123; randomText &#125;&#125; 但其实上面的代码会有性能上的问题,替代方案是使用@ViewBuilder:(不需要AnyView和return了) 1234567891011121314struct ContentView: View &#123; @ViewBuilder var randomText: some View &#123; if Bool.random() &#123; Text(&quot;Hello, World!&quot;) .frame(width: 300) &#125; else &#123; Text(&quot;Hello, World!&quot;) &#125; &#125; var body: some View &#123; randomText &#125;&#125; 下面的代码挺有意思,也贴一下: 123456789101112131415161718192021struct ContentView: View &#123; @State private var views = [AnyView]() var body: some View &#123; VStack &#123; Button(&quot;Add Shape&quot;) &#123; if Bool.random() &#123; views.append(AnyView(Circle().frame(height: 50))) &#125; else &#123; views.append(AnyView(Rectangle().frame(width: 50))) &#125; &#125; ForEach(0..&lt;views.count, id: \\.self) &#123; views[$0] &#125; Spacer() &#125; &#125;&#125; Using a ternary conditional operator to supply differing values当使用三元选择符生成,若生成的View的类型不同,就会报错,那么如何让其在不同类型的view中转换？ 12345extension View &#123; func erasedToAnyView() -&gt; AnyView &#123; AnyView(self) &#125;&#125; 如何使用? 123Text(&quot;Hello world&quot;) .font(.title) .erasedToAnyView() 这样就解决问题了。if条件生成不同类型的View也是一样的操作。 MainActor让代码运行在main actor： 123await MainActor.run &#123; // your work here&#125; 看文章上说:the main actor won’t ever run two pieces of code at the same time, so the work we ask for might need to wait for some other work to complete first.所以这大概就是主线程(不知道是不是用线程这两个字)只能用来更新界面元素的原因吧。这是因为,主界面在更新页面元素的时候,若底线程在更新界面元素,就会让这些元素不同步或是产生冲突,程序就会崩溃的。因此,创建和保存CoreData的数据就需要在MainActor上运行:So, when it comes to creating and saving all your Core Data objects, that’s definitely a task for the main actor, because it means your fetch request won’t start changing under SwiftUI’s feet. Core ImageApart from SwiftUI’s Image view, the three other image types are: UIImage, which comes from UIKit. This is an extremely powerful image type capable of working with a variety of image types, including bitmaps (like PNG), vectors (like SVG), and even sequences that form an animation. UIImage is the standard image type for UIKit, and of the three it’s closest to SwiftUI’s Image type. CGImage, which comes from Core Graphics. This is a simpler image type that is really just a two-dimensional array of pixels. CIImage, which comes from Core Image. This stores all the information required to produce an image but doesn’t actually turn that into pixels unless it’s asked to. Apple calls CIImage “an image recipe” rather than an actual image. There is some interoperability between the various image types: We can create a UIImage from a CGImage, and create a CGImage from a UIImage.We can create a CIImage from a UIImage and from a CGImage, and can create a CGImage from a CIImage.We can create a SwiftUI Image from both a UIImage and a CGImage. 不能把UIImage、CGImage、CIImage直接放入swiftui的view中,但可以通过转化的方式放入swiftui的image中。 另外,要想从CIImage -&gt; UIImage, 必须是:CIImage -&gt; CGImage -&gt; UIImage. 几种滤镜的使用1@State private var image: Image? sepia滤镜 ([‘siːpiə]即乌贼的墨；深褐色的意思)12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* loadImage()主要作用:对图片进行sepia过滤. 需要先import二个模块:CoreImage和CoreImage.CIFilterBuiltins这二个模块 主要思路: 创建UIImage-&gt;转化成CIImage-&gt;使用sepia过滤器来过滤-&gt;从过滤器中读取output image-&gt;使用output image创建UIImage-&gt;生成View下能使用的Image*/func loadImage() &#123; // 创建一个UIImage guard let inputImage = UIImage(named: &quot;threemonths&quot;) else &#123; return &#125; // 把UIImage转化成CIImage let beginImage = CIImage(image: inputImage) // create a Core Image context let context = CIContext() // create a Core Image filter // Core Image filter才是实际对图片进行处理的重要部件 // 这里引入的sepia([&#x27;siːpiə]即乌贼的墨；深褐色的意思) 过滤器 // 该过滤器只有两个属性:inputImage和intensity // 不同于let currentFilter = CIFilter.sepiaTone()返回的是CISepiaTone协议 // currentFilter: CIFilter = CIFilter.sepiaTone()返回的是CIFilter // 可以适用于所有的filter协议,利于你切换更多filter currentFilter: CIFilter = CIFilter.sepiaTone() // inputImage是要过滤的图片 // currentFilter.inputImage = beginImage // 下面的代码比上面的代码更好一些 // 为何不用上面的currentFilter.inputImage是因为这个不适用于全部filter currentFilter.setValue(beginImage, forKey: kCIInputImageKey) // intensity是sepia的强弱程度,范围是0(原始图片)-1(full sepia) currentFilter.intensity = 1 /* to convert the output from our filter to a SwiftUI Image that we can display in our view */ // Read the output image from our filter, which will be a CIImage. This might fail, so it returns an optional. guard let outputImage = currentFilter.outputImage else &#123; return &#125; // Ask our context to create a CGImage from that output image. This also might fail, so again it returns an optional. if let cgimg = context.createCGImage(outputImage, from: outputImage.extent) &#123; // Convert that CGImage into a UIImage let uiImage = UIImage(cgImage: cgimg) // Convert that UIImage into a SwiftUI Image image = Image(uiImage: uiImage) &#125;&#125; intensity为0.3的时候的效果:intensity为1.0的时候的效果: pixellate滤镜 – 像是加马赛克的感觉12345678// 上面的loadImage()方法更改create a Core Image filter那一部分的代码func loadImage() &#123; // ... let currentFilter = CIFilter.pixellate() currentFilter.inputImage = beginImagev currentFilter.scale = 10 // ...&#125; currentFilter.scale &#x3D; 1 时候的效果：currentFilter.scale &#x3D; 10 时候的效果:currentFilter.scale &#x3D; 100 时候的效果:currentFilter.scale &#x3D; 200 时候的效果: crystallize滤镜 – 像是变成水晶体化的意思123456789// 上面的loadImage()方法更改create a Core Image filter那一部分的代码func loadImage() &#123; // ... // 加载crystallize过滤器 let currentFilter = CIFilter.crystallize() currentFilter.inputImage = beginImage currentFilter.radius = 100 // ...&#125; currentFilter.radius &#x3D; 100 时候的效果: twirlDistortion过滤器 – 在某点对图像以某半径进行扭曲1234567891011// 上面的loadImage()方法更改create a Core Image filter那一部分的代码func loadImage() &#123; // ... // 加载twirlDistortion过滤器 let currentFilter = CIFilter.twirlDistortion() currentFilter.inputImage = beginImage // radius其实扭曲点的扭转半径 currentFilter.radius = 1000 // 扭转中心点,这里取的是图片的中心点 currentFilter.center = CGPoint(x: inputImage.size.width / 2, y: inputImage.size.height / 2) // ... 半径为 500在图片中心点的扭曲效果:半径为1000在图片中心点的扭曲效果: UIKit讲到了与SwiftUI联通的具体用法,可参考: https://www.hackingwithswift.com/books/ios-swiftui/wrapping-a-uiviewcontroller-in-a-swiftui-viewhttps://www.hackingwithswift.com/books/ios-swiftui/using-coordinators-to-manage-swiftui-view-controllers UIKit has a class called UIView, which is the parent class of all views in the layouts. So, labels, buttons, text fields, sliders, and so on – those are all views. UIKit has a class called UIViewController, which is designed to hold all the code to bring views to life. Just like UIView, UIViewController has many subclasses that do different kinds of work. UIKit uses a design pattern called delegation to decide where work happens. So, when it came to deciding how to respond to a text field changing, we’d create a custom class with our functionality and make that the delegate of our text field. Wrapping a UIKit view controller requires us to create a struct that conforms to the UIViewControllerRepresentable protocol.Conforming to UIViewControllerRepresentable does require us to fill in that struct with two methods: one called makeUIViewController(), which is responsible for creating the initial view controller, and another called updateUIViewController(), which is designed to let us update the view controller when some SwiftUI state changes. UIViewRepresentable协议 https://zhuanlan.zhihu.com/p/402897951 在SwiftUI中包装UIView非常简单，只需要创建一个遵守UIViewRepresentable协议的结构体就行了。UIViewrepresentable的协议并不复杂，只包含：makeUIView、updateUIView、dismantleUIView和makeCoordinator四个方法。makeUIView和updateUIView为必须提供实现的方法。UIViewrepresentable的协议的生命周期图: makeCoordinator如果我们声明了Coordinator（协调器）,UIViewRepresentable视图会在初始化后首先创建它的实例，以便在其他的方法中调用。Coordinator默认为Void，该方法在UIViewRepresentable的生命周期中只会调用一次，因此只会创建一个协调器实例。 makeUIView创建一个用来包装的UIKit视图实例。该方法在UIViewRepresentable的生命周期中只会调用一次。 updateUIViewSwiftUI会在应用程序的状态（State）发生变化时更新受这些变化影响的界面部分。当UIViewRepresentable视图中的注入依赖发生变化时，SwiftUI会调用updateUIView。其调用时机同标准SwiftUI视图的body一致，最大的不同为，调用body为计算值，而调用updateview仅为通知UIViewRepresentable视图依赖有变化，至于是否需要根据这些变化来做反应，则由开发者来自行处理。该方法在UIViewRepresentable的生命周期中会多次调用，直到视图被移出视图树（更准确地描述是切换到另一个不包含该视图的视图树分支）。在makeUIVIew执行后，updateUIVew必然会执行一次 dismantleUIView在UIViewRepresentable视图被移出视图树之前，SwiftUI会调用dismantleUIView，通常在此方法中可以执行u删除观察器等善后操作。dismantleUIView为类型方法。 PhotosUIPHPickerViewControllerA photo picker. 12345678910111213141516171819struct ImagePicker: UIViewControllerRepresentable &#123; typealias UIViewControllerType = PHPickerViewController func makeUIViewController(context: Context) -&gt; UIViewType &#123; var config = PHPickerConfiguration() // 选择相册 config.filter = .images // 选择视频 // config.filter = .videos let picker = UIViewType(configuration: config) return picker &#125; func updateUIViewController(_ uiViewController: UIViewType, context: Context) &#123; &#125;&#125; 差不多是这个样子的: UITextField上面PHPickerViewController的例子,我们再来实现简单功能的UITextField的包装视图–TextFieldWrapper: 123456789101112131415161718192021222324252627282930313233343536373839404142struct TextFieldWrapper: UIViewRepresentable &#123; let placeholder: String @Binding var text: String init(_ placeholder: String, text: Binding&lt;String&gt;) &#123; self.placeholder = placeholder self._text = text &#125; typealias UIViewType = UITextField func makeUIView(context: Context) -&gt; UITextField &#123; let textField = UITextField() textField.placeholder = placeholder textField.text = text return textField &#125; func updateUIView(_ uiView: UITextField, context: Context) &#123; &#125;&#125;struct Demo: View &#123; @State var name: String = &quot;&quot; var body: some View &#123; VStack &#123; TextFieldWrapper(&quot;name&quot;, text: $name) .border(.blue) .padding() &#125; &#125; &#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; Demo() &#125;&#125; coordinators此处的coordinators是来自swiftUI,与UIKit中的coordinators是完全不一样的，不要混淆。SwiftUI’s coordinators are designed to act as delegates for UIKit view controllers. MapKit 模块Integrating MapKit with SwiftUI MKCoordinateRegionMK就是MapKit的意思。 12345678import MapKit// 在View中// 以下的中心点就是 伦敦@State private var mapRegion = MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 51.5, longitude: -0.12), span: MKCoordinateSpan(latitudeDelta: 0.2, longitudeDelta: 0.2))// 在View的body中Map(coordinateRegion: $mapRegion) 效果图是: MapMarker1234567891011121314151617181920212223242526272829import SwiftUIimport MapKitstruct Location: Identifiable &#123; let id = UUID() let name: String let coordinate: CLLocationCoordinate2D&#125;struct ContentView: View &#123; // MK 就是MapKit // 以下的中心点就是 伦敦 @State private var mapRegion = MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 51.5, longitude: -0.12), span: MKCoordinateSpan(latitudeDelta: 0.2, longitudeDelta: 0.2)) let locations = [ Location(name: &quot;Buckingham Palace&quot;, coordinate: CLLocationCoordinate2D(latitude: 51.501, longitude: -0.141)), Location(name: &quot;Tower of London&quot;, coordinate: CLLocationCoordinate2D(latitude: 51.508, longitude: -0.076)) ] var body: some View &#123; NavigationView &#123; Map(coordinateRegion: $mapRegion, annotationItems: locations) &#123; location in MapMarker(coordinate: location.coordinate) // 后续可替代 // Using MapMarker doesn&#x27;t allow us to add text to the map. &#125; .navigationTitle(&quot;London Explorer&quot;) &#125; &#125;&#125; 以下默认的annotation效果图是: 也可以不使用默认的annotation标记: 12345678910111213// 上述可替代处,替代MapMarker(coordinate: location.coordinate)的代码MapAnnotation(coordinate: location.coordinate) &#123; NavigationLink &#123; Text(location.name) &#125; label: &#123; Circle() .stroke(.red, lineWidth: 3) .frame(width: 44, height: 44) .onTapGesture &#123; print(&quot;Tapped on \\(location.name)&quot;) &#125; &#125;&#125; 以下是custom的annotation效果图: LocalAuthentication 模块 – Using Touch ID and Face ID with SwiftUI https://www.hackingwithswift.com/books/ios-swiftui/using-touch-id-and-face-id-with-swiftui 要打开人脸或指纹检测,需要在项目中设置的是:Before we write any code, you need to add a new key to your project options, explaining to the user why you want access to Face ID. For reasons known only to Apple, we pass the Touch ID request reason in code, and the Face ID request reason in project options.So, select your current target, go to the Info tab, right-click on an existing key, then choose Add Row. Scroll through the list of keys until you find “Privacy - Face ID Usage Description” and give it the value “We need to unlock your data.” 123456789101112131415161718192021222324252627282930313233343536import LocalAuthentication// 可以在ContentView中定义func authenticate() &#123; // LA就是LocalAuthentication let context = LAContext() var error: NSError? // check whether biometric authentication is possible if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) &#123; // it&#x27;s possible, so go ahead and use it let reason = &quot;We need to unlock your data.&quot; context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) &#123; success, authenticationError in // authentication has now completed if success &#123; // authenticated successfully isUnlocked = true &#125; else &#123; // there was a problem &#125; &#125; &#125; else &#123; // no biometrics &#125;&#125;// 在ContentView中添加属性@State private var isUnlocked = false// 在Body中添加的ViewVStack &#123; if isUnlocked &#123; Text(&quot;Unlocked&quot;) &#125; else &#123; Text(&quot;Locked&quot;) &#125;&#125;.onAppear(perform: authenticate) 执行后仍旧是“Locked”,因为模拟器中未设置生物检测.To take Face ID for a test drive, go to the Features menu and choose Face ID &gt; Enrolled, then launch the app again. This time you should see the Face ID prompt appear, and you can trigger successful or failed authentication by going back to the Features menu and choosing Face ID &gt; Matching Face or Non-matching Face.模拟器中未尝试成功,但跳开模拟器的设置,直接安装到真机上后可正常执行。 CoreLocation在项目中需要你导入CoreLocation,因为有时候需要你自己去加载,是在 项目的TARGETS的BuildPhases的LinkBinaryWithLibraries中添加CoreLocation.framework。但试了下,其实不需要去导入的。但可以知道怎么导入模块。 CLLocationManagerDelegate &#x2F; CLLocationManager() – fetches the user’s location获取用户的具体位置: https://www.hackingwithswift.com/100/swiftui/78 1234567891011121314151617181920import CoreLocationclass LocationFetcher: NSObject, CLLocationManagerDelegate &#123; let manager = CLLocationManager() var lastKnownLocation: CLLocationCoordinate2D? override init() &#123; super.init() manager.delegate = self &#125; func start() &#123; manager.requestWhenInUseAuthorization() manager.startUpdatingLocation() &#125; func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; lastKnownLocation = locations.first?.coordinate &#125;&#125; 加一个用户授权的选项:To use that, start by adding a new key to Info.plist(就是Info) called “Privacy - Location When In Use Usage Description”, then give it some sort of value explaining to the user why you need their location. 具体调用(简单验证是否获取到): 12345678910111213141516171819struct ContentView: View &#123; let locationFetcher = LocationFetcher() var body: some View &#123; VStack &#123; Button(&quot;Start Tracking Location&quot;) &#123; self.locationFetcher.start() &#125; Button(&quot;Read Location&quot;) &#123; if let location = self.locationFetcher.lastKnownLocation &#123; print(&quot;Your location is \\(location)&quot;) &#125; else &#123; print(&quot;Your location is unknown&quot;) &#125; &#125; &#125; &#125;&#125; 后续可以使用这个location值做很多事情。 在模拟器中调试:If you’re using the simulator rather than a real device, you can fake a location by going to the Debug menu and choosing Location &gt; Apple. MVVM 设计样式Model View View-Model @MainActor@MainActor is responsible for running all user interface updates, and adding that attribute to the class means we want all its code – any time it runs anything, unless we specifically ask otherwise – to run on that main actor. This is important because it’s responsible for making UI updates, and those must happen on the main actor. 12345extension ContentView &#123; @MainActor class ViewModel: ObservableObject &#123; &#125;&#125; 使用了@MainActor后,就能得到保证,在ViewModel类中每一个部分都会运行在main-actor中,让你安全地更新UI,不必担心在哪里使用它。 @propertyWrapper – 属性包装器A property wrapper adds a layer of separation between code that manages how a property is stored and the code that defines a property.属性包装器，用来修饰属性，它可以抽取关于属性重复的逻辑来达到简化代码的目的。 通过 @propertyWrapper 来标识structure, enumeration, or class来实现属性包装，有两个要求: 必须使用属性@propertyWrapper进行定义; 它必须具有wrappedValue属性。 例子:没有使用@propertyWrapper是这样的: 12345678910111213141516171819202122232425struct NonNegative&lt;Value: BinaryInteger&gt; &#123; var value: Value init(wrappedValue: Value) &#123; if wrappedValue &lt; 0 &#123; value = 0 &#125; else &#123; value = wrappedValue &#125; &#125; var wrappedValue: Value &#123; get &#123; value &#125; set &#123; if newValue &lt; 0 &#123; value = 0 &#125; else &#123; value = newValue &#125; &#125; &#125;&#125;var example = NonNegative(wrappedValue: 5)example.wrappedValue -= 10print(example.wrappedValue) // 0 使用到@propertyWrapper是这样的: 123@propertyWrapperstruct NonNegative&lt;Value: BinaryInteger&gt; &#123;// 下面的代码省略 具体使用的时候: 12345678910struct User &#123; @NonNegative var score = 0&#125;var user = User()user.score += 10print(user.score)user.score -= 20print(user.score) TabView 123456789101112131415161718192021222324struct ContentView: View &#123; @State private var selectedTab = &quot;one&quot; var body: some View &#123; TabView(selection: $selectedTab) &#123; Text(&quot;Tab 1&quot;) .onTapGesture &#123; selectedTab = &quot;two&quot; &#125; .tabItem &#123; Label(&quot;One&quot;, systemImage: &quot;star&quot;) &#125; .tag(&quot;one&quot;) Text(&quot;Tab 2&quot;) .onTapGesture &#123; selectedTab = &quot;one&quot; &#125; .tabItem &#123; Label(&quot;Two&quot;, systemImage: &quot;circle&quot;) &#125; .tag(&quot;two&quot;) &#125; &#125;&#125; 以上代码可以在点击Text的同时进行Tab的切换。以上使用到了: TabView(selection:content:),其中selection参数是Binding; .tag是给Tab定义一个值,便于定位。 objectWillChange – 这是@Published的手动版 https://www.hackingwithswift.com/books/ios-swiftui/manually-publishing-observableobject-changes 一般在一个遵循@ObservableObject的class中,定义一个@Published属性的变量,那么在可对其进行监视的View中就可以实时更新该值了,然而,我们不用这个@Published的话,还有什么办法呢？可以使用这个到一个解决办法,就是 objectWillChange。看下面的代码,未对DelayedUpdater类的value属性定义成@Published,看是如何做的: 123456789101112131415161718192021222324struct ContentView: View &#123; @StateObject var updator = DelayedUpdater() @MainActor class DelayedUpdater: ObservableObject &#123; var value = 0 &#123; willSet &#123; objectWillChange.send() &#125; &#125; init() &#123; for i in 1...20 &#123; DispatchQueue.main.asyncAfter(deadline: .now() + Double(i)) &#123; self.value += 1 &#125; &#125; &#125; &#125; var body: some View &#123; Text(&quot;\\(updator.value)&quot;) &#125;&#125; objectWillChange的解释是这样的:Every class that conforms to ObservableObject automatically gains a property called objectWillChange. This is a publisher, which means it does the same job as the @Published property wrapper: it notifies any views that are observing that object that something important has changed. As its name implies, this publisher should be triggered immediately before we make our change, which allows SwiftUI to examine the state of our UI and prepare for animation changes.这是一个老式的操作办法,但从中我们可以log something,调用一个方法,或是做点其他什么事情,都是可以在我们的控制下去完成的。 !!!Important!!!:You should call objectWillChange.send() before changing your property, to ensure SwiftUI gets its animations correct. fileprivate(set)这里引入 fileprivate(set)什么时候使用?比如在一个遵守ObservableObject的class中有一个@Published变量 var people: [Prospect], People这个struct中有一个var isContacted &#x3D; false,当我们在外部而不是在这个class中更改这个isContacted成为true,这个people并不会被观察到,所以你必须杜绝外部更改这个isContacted,所以要使用到: 12345Struct People &#123; ... fileprivate(set) var isContacted = false ...&#125; 这样外部就无法修改了.而在这个class内部建立方法: 1234func toggle(_ prospect: Prospect) &#123; objectWillChange.send() prospect.isContacted.toggle()&#125; 当在外部调用到这个class的toggle方法时,就会通知到这个class的people要改变了,需要重新刷新view了。具体例子在: https://www.hackingwithswift.com/books/ios-swiftui/adding-options-with-swipe-actions fileprivate 和 private 的区别:两者区别就存在于这个file中,当一个文件中有一个类定义了fileprivate的属性,那么即使这个文件中有很多类,其他类还是可以调用这个fileprivate属性的。而private存在的结构或类,其他结构或类是无法调用的,即使这些都写在同一个文件中。 Result 类型 – 此处需要配合Task使用 https://www.hackingwithswift.com/books/ios-swiftui/understanding-swifts-result-type Result是一种特殊的数据类型,它既可以包含一个成功的值,也可以包含错误类型。比如下面的例子中,取出的Result属性,既可以是一个String,也可以是一个网络故障导致的连接错误。它在项目中会起到很大的作用,应当是要去理解的。 一般需要使用到这个Result数据类型,需要配合使用Task来引出。下面的例子正是如此。 看下面的代码: 12345678910111213141516171819202122232425262728struct ContentView: View &#123; @State private var output = &quot;&quot; var body: some View &#123; Text(&quot;Res:\\(output)&quot;) .task &#123; await fetchReadings() &#125; &#125; func fetchReadings() async &#123; let fetchTask = Task &#123; () -&gt; String in let url = URL(string: &quot;https://hws.dev/readings.json&quot;)! let (data, _) = try await URLSession.shared.data(from: url) let readings = try JSONDecoder().decode([Double].self, from: data) return &quot;Found \\(readings.count) readings.&quot; &#125; // 下面有经debug的result的具体类型和值 let result = await fetchTask.result switch result &#123; case .success(let str): output = str case .failure(let error): output = error.localizedDescription &#125; &#125;&#125; 可以看到程序显示的是: Res:Found 10000 readings. 需要说明的是: fetchTask是Task对象所对应的操作目标,通过它我们可以做多个操作,比如说取消这个Task任务; fetchTask.result就是一个Result类型,它既可能是一个字符串比如”Found 10000 readings.”,也可能是一个Error; 这个Result类型,具体到上述代码中,就是Result&lt;String, Error&gt;,进一步说明了,如果它成功了就是String,不成功就是Error; 处理这个result,用到了switch,就是根据其有两个属性,要么success,要么.failure,但还可以通过do { output &#x3D; try result.get()} catch { output &#x3D; “Error: (error.localizedDescription)”}。注意,这里是用到了result.get(),至于是用switch来分辨是成功还是失败,还是通过result.get(),感觉都可以。 上面代码中的result经debug后看到的详细: Image的Interpolation处理 https://www.hackingwithswift.com/books/ios-swiftui/controlling-image-interpolation-in-swiftui – 是要图片更圆滑还是棱角分明不做处理,可以选择当处理二维码图像时,肯定是不要进行圆滑处理的,不然二维码就会失真无法读取了。 以下是原图片:图片是很小的,但如果做放大处理,Image读取后,会默认做圆滑处理: 123456Image(&quot;example&quot;) .resizable() .scaledToFit() .frame(maxHeight: .infinity) .background(.black) .ignoresSafeArea() 图片是这样圆滑处理的: 若不做圆滑处理,则不需要这个默认圆滑处理,就需要使用到Image的.interpolation(.none): 1234567Image(&quot;example&quot;) .interpolation(.none) .resizable() .scaledToFit() .frame(maxHeight: .infinity) .background(.black) .ignoresSafeArea() 这是二维码显示的正确方式。.interpolation()中不光有.none,还有:.high &#x2F; .low &#x2F; .medium 。这里需要注意的一点是,当你延展该张图片(就像上面的.resizable().scaledToFit()),默认是使用到.interpolation且非.none进行圆滑处理的。 contextMenu() – modifier让一个view在长按后弹出menu菜单的功能。 想到的场景:长按图片跳出Save的按钮。 123456789101112131415161718192021222324VStack &#123; Text(/*@START_MENU_TOKEN@*/&quot;Hello, World!&quot;/*@END_MENU_TOKEN@*/) .padding() .background(backgroundColor) Text(&quot;Change Color&quot;) .padding() .contextMenu &#123; Button(role: .destructive) &#123; backgroundColor = .red &#125; label: &#123; Label(&quot;Red&quot;, systemImage: &quot;checkmark.circle.fill&quot;) .foregroundColor(.red) &#125; Button(&quot;Green&quot;) &#123; backgroundColor = .green &#125; Button(&quot;Blue&quot;) &#123; backgroundColor = .blue &#125; &#125;&#125; 效果图:这里注意,红色按钮的前景色是红色的,这是因为contextMenu会强制让里面元素的颜色、样式等变成统一的,也就是会摧毁一些设置,所以这里给Button加了一个role: .destructive,这样Button按钮的样式就会完全根据我们的需要来实现了。 Menu - view不同于modifier的contextMenu,Menu是一个View,但感觉用处是一样的: 12345678910111213struct ContentView: View &#123; var body: some View &#123; Menu &#123; Button(&quot;Order Now&quot;, action: placeOrder) Button(&quot;Adjust Order&quot;, action: adjustOrder) &#125; label: &#123; Label(&quot;Options&quot;, systemImage: &quot;paperplane&quot;) &#125; &#125; func placeOrder() &#123; &#125; func adjustOrder() &#123; &#125;&#125; 下面是Menu嵌套Menu的情况: 12345678910111213141516171819struct ContentView: View &#123; var body: some View &#123; Menu(&quot;Options&quot;) &#123; Button(&quot;Order Now&quot;, action: placeOrder) Button(&quot;Adjust Order&quot;, action: adjustOrder) Menu(&quot;Advanced&quot;) &#123; Button(&quot;Rename&quot;, action: rename) Button(&quot;Delay&quot;, action: delay) &#125; Button(&quot;Cancel&quot;, action: cancelOrder) &#125; &#125; func placeOrder() &#123; &#125; func adjustOrder() &#123; &#125; func rename() &#123; &#125; func delay() &#123; &#125; func cancelOrder() &#123; &#125;&#125; 还有给Menu增加一个primaryAction,就是按下并马上放开,即执行primaryAction;若长按,则调出菜单: 12345678910111213141516171819struct ContentView: View &#123; var body: some View &#123; Menu(&quot;Options&quot;) &#123; Button(&quot;Order Now&quot;, action: placeOrder) Button(&quot;Adjust Order&quot;, action: adjustOrder) Button(&quot;Cancel&quot;, action: cancelOrder) &#125; primaryAction: &#123; justDoIt() &#125; &#125; func justDoIt() &#123; print(&quot;Button was tapped&quot;) &#125; func placeOrder() &#123; &#125; func adjustOrder() &#123; &#125; func cancelOrder() &#123; &#125;&#125; swipeActions() – modifier针对List中的元素,当对其向左划时,给出一个action及相应的显示。 1234567891011List &#123; Text(&quot;Taylor Swift&quot;) .swipeActions &#123; Button &#123; print(&quot;Hi&quot;) &#125; label: &#123; Label(&quot;Send Message&quot;, systemImage: &quot;message&quot;) &#125; &#125;&#125; 效果图: 还可以增加从左往右划的action: 1234567891011121314151617181920List &#123; Text(&quot;Taylor Swift&quot;) .swipeActions &#123; Button &#123; print(&quot;Hi&quot;) &#125; label: &#123; Label(&quot;Send Message&quot;, systemImage: &quot;message&quot;) &#125; &#125; Text(&quot;Taylor Swift&quot;) .swipeActions(edge: .leading) &#123; Button &#123; print(&quot;Hi&quot;) &#125; label: &#123; Label(&quot;Pin&quot;, systemImage: &quot;pin&quot;) &#125; .tint(.orange) 效果图:swipeActions与contextMenu类似,都会对里面的元素有限制,所以这里对Button使用了一个tint()modifier,是为了增加一个选中的颜色,但你也可以像contextMenu例子中一样,对Button的role设置一个.destructive。 UserNotifications – Scheduling local notifications https://www.hackingwithswift.com/books/ios-swiftui/scheduling-local-notifications 给用户弹出提醒的消息,效果图如下: 代码如下: 123456789101112131415161718192021222324252627282930313233import UserNotificationsVStack &#123; // 请求用户的许可 // 下面请求了三样东西: .alert / .badge /.sound // 所以后续弹出的通知中就会有声音、文字等 Button(&quot;Request Permission&quot;) &#123; UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) &#123; success, error in if success &#123; print(&quot;All set!&quot;) &#125; else if let error = error &#123; print(error.localizedDescription) &#125; &#125; &#125; // 设置具体的通知 Button(&quot;Schedule Notification&quot;) &#123; let content = UNMutableNotificationContent() content.title = &quot;Feed the cat&quot; content.subtitle = &quot;It looks hungry&quot; content.sound = UNNotificationSound.default // show this notification five seconds from now let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false) // choose a random identifier let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger) // add our notification request UNUserNotificationCenter.current().add(request) &#125;&#125; 注意:真机中直接按住电源键,即可在五秒后收到通知。模拟机中需要按照键盘的Cmd+L,才能模拟息屏的操作。 以上是每次都会要求用户允许发出通知,但还有更好的办法,就是查看一下用户之前是不是允许了,如果允许了,就直接发出通知,如果没有允许,才继续问用户,而不是一直在反复问用户,这会让用户觉得烦而关掉通知的。 UserNotifications – 根据之前是否已授权而发用户提醒的一个方法 https://www.hackingwithswift.com/books/ios-swiftui/posting-notifications-to-the-lock-screen 12345678910111213141516171819202122232425262728293031323334353637383940// Prospect是项目中的一个struct,这里暂且不用管它的结构是怎么样的,其实也就是几个属性func addNotification(for prospect: Prospect) &#123; // 第一部分 let center = UNUserNotificationCenter.current() let addRequest = &#123; let content = UNMutableNotificationContent() content.title = &quot;Contact \\(prospect.name)&quot; content.subtitle = prospect.emailAddress content.sound = UNNotificationSound.default // var dateComponents = DateComponents() // dateComponents.hour = 9 // let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: false) // 上面的代码是会在下次9点的时候发出通知的 // 下面的代码没有使用上面的时间组件,而是设置成5秒后发送一次 // 是为了测试用 let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false) let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger) center.add(request) &#125; // 第二部分 // 既使用 getNotificationSettings() 又使用 requestAuthorization() // 后者是在前一次没有得到授权的情况下才会用到 center.getNotificationSettings &#123; settings in if settings.authorizationStatus == .authorized &#123; addRequest() &#125; else &#123; center.requestAuthorization(options: [.alert, .badge, .sound]) &#123; success, error in if success &#123; addRequest() &#125; else &#123; print(&quot;D&#x27;oh!&quot;) &#125; &#125; &#125; &#125;&#125; Adding Swift package dependencies in Xcode加载依赖包 在project中,在File menu中选择Add Packages,随后输入URL,比如下面的:加载完后,import这个包就行了。 QR code – quick respond code 二维码Generating and scaling up a QR code hackingwithswift.com&#x2F;books&#x2F;ios-swiftui&#x2F;generating-and-scaling-up-a-qr-code Core Image 可以将一串字符串生成一个二维码图像。 一,引入CoreImage.CIFilterBuiltins模块;二,需要二个属性来存储Core Image context 即CIContext() 和 一个Core Image’s QR code generator filter的实例即CIFilter.qrCodeGenerator();三,创建这个QR:1.因为我们是要将字符串转换成UIImage的,而CIImage是接收数据信息的,所以先要生成CIImage信息:1)CIFilter.qrCodeGenerator()的message属性接收数据信息;2)CIFilter.qrCodeGenerator()的outputImage生成CIImage图像。2.CIImage要转换成UIImage,必须先转换成CGImage,CIContext()的createCGImage方法可以生成CGImage;3.将CGImage转换成UIImage,即UIImage(cgImage:)四,用Image(uiImage:)来显示图像.因为带有锯齿,Image会自动优化润滑,导致二维码模糊,所以需要使用到.interpolation(.none),让这个二维码有棱有角,不需要任何的加工。 具体代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 导入必要的CoreImage.CIFilterBuiltinsimport CoreImage.CIFilterBuiltinsstruct MeView: View &#123; @State private var name = &quot;Anonymous&quot; @State private var emailAddress = &quot;you@yoursite.com&quot; // 存储Core Image context let context = CIContext() // 创建一个一个Core Image’s QR code generator filter的实例 let filter = CIFilter.qrCodeGenerator() func generateQRCode(from string: String) -&gt; UIImage&#123; // 给filter传入显示的具体数据 filter.message = Data(string.utf8) // 传入具体数据后,生成CIImage if let outputImage = filter.outputImage &#123; // CIImage转换成CGImage if let cgimg = context.createCGImage(outputImage, from: outputImage.extent) &#123; // 最后生成我们需要的UIImage return UIImage(cgImage: cgimg) &#125; &#125; // 在无法生成二维码的情况下,生成一个带叉的图像,或者就是一个UIImage的空对象 return UIImage(systemName: &quot;xmark.circle&quot;) ?? UIImage() &#125; var body: some View &#123; NavigationView &#123; Form &#123; TextField(&quot;Name&quot;, text: $name) // .textContentType会告诉ios系统这里用户输入的是什么样的数据, // 比如名字,以及下面的邮箱地址 .textContentType(.name) .font(.title) TextField(&quot;Email Address&quot;, text: $emailAddress) .textContentType(.emailAddress) .font(.title) Image(uiImage: generateQRCode(from: &quot;\\(name)\\n\\(emailAddress)&quot;)) .interpolation(.none) .resizable() .scaledToFit() .frame(width: 250, height: 250) &#125; .navigationTitle(&quot;Your code&quot;) &#125; &#125;&#125; Scanning QR codes with SwiftUI https://www.hackingwithswift.com/books/ios-swiftui/scanning-qr-codes-with-swiftui 检索一个QR codes,需要使用到AVFoundation库。 Paul为我们准备了一个package,可以直接使用,包在https://github.com/twostraws/CodeScanner。已下载放在CodePackages&#x2F;CodeScanner-main目录中。里面有具体的用法。 Vibrations – 震动UINotificationFeedbackGenerator – 相对简单默认的震动模式UINotificationFeedbackGenerator是来自于UIKit,而另一个震动的模块是CoreHaptics,是两个不一样的模块。 12345678func simpleSuccess() &#123; let generator = UINotificationFeedbackGenerator() generator.notificationOccurred(.success)&#125;// 启用这个方法Text(&quot;Hello, World!&quot;) .onTapGesture(perform: simpleSuccess) 以上点击以后就会出现震动,这是.success模式,还可以替换成.success &#x2F; .error &#x2F; .warning这些模式,用下来感觉都差不多,但还是有差别的。 prepare() – 解决UINotificationFeedbackGenerator()可能延迟一秒钟的问题 https://www.hackingwithswift.com/books/ios-swiftui/making-iphones-vibrate-with-uinotificationfeedbackgenerator UINotificationFeedbackGenerator()的触动反馈,是需要Taptic Engine预热的,不然可能会有一秒左右的延迟,所以引入其的prepare()方法,就是预热的准备。 示例: 12345678910111213141516171819202122232425@State private var feedback = UINotificationFeedbackGenerator()// 这里View的代码省略了 someView .gesture( DragGesture() .onChanged &#123; gesture in offset = gesture.translation feedback.prepare() &#125; .onEnded &#123; _ in if abs(offset.width) &gt; 100 &#123; if offset.width &gt; 0 &#123; feedback.notificationOccurred(.success) &#125; else &#123; feedback.notificationOccurred(.error) &#125; removal?() &#125; else &#123; offset = .zero &#125; &#125; ) Core Haptics – 可自定义的震动模式 https://www.hackingwithswift.com/books/ios-swiftui/making-vibrations-with-uinotificationfeedbackgenerator-and-core-haptics 这是CoreHaptics模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445import CoreHapticsstruct ContentView: View &#123; @State private var engine: CHHapticEngine? func prepareHaptics() &#123; guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else &#123; return &#125; do &#123; engine = try CHHapticEngine() try engine?.start() &#125; catch let error &#123; print(&quot;There was an error creating the engine: \\(error.localizedDescription)&quot;) &#125; &#125; func complexSuccess() &#123; // make sure that the device supports haptics guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else &#123; return &#125; var events = [CHHapticEvent]() // create one intense, sharp tap let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1) let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 1) let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0) events.append(event) // convert those events into a pattern and play it immediately do &#123; let pattern = try CHHapticPattern(events: events, parameters: []) let player = try engine?.makePlayer(with: pattern) try player?.start(atTime: 0) &#125; catch &#123; print(&quot;Failed to play pattern: \\(error.localizedDescription).&quot;) &#125; &#125; var body: some View &#123; Text(&quot;Hi&quot;) .onAppear(perform: prepareHaptics) .onTapGesture &#123; complexSuccess() &#125; &#125;&#125; 以上代码就自定义了一个点击后的震动,感觉起来,好像也没什么特别的,但如果你将complexSuccess方法中的create one intense, sharp tap下面的代码换成如下: 12345678910111213for i in stride(from: 0, to: 1, by: 0.1) &#123; let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: Float(i)) let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: Float(i)) let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: i) events.append(event)&#125;for i in stride(from: 0, to: 1, by: 0.1) &#123; let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: Float(1 - i)) let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: Float(1 - i)) let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 1 + i) events.append(event)&#125; 这震动就非常的特别。 contentShape() modifier1234567Circle() .fill(.red) .frame(width: 300, height: 300) .contentShape(Rectangle()) .onTapGesture &#123; print(&quot;Circle tapped!&quot;) &#125; 没有.contentShape(Rectangle())的时候,点击在圆以外是没有响应的,若有.contentShape(Rectangle())的时候,点击在圆以外的正方形边缘上,是会有响应的。 此外,还有一个用处: 123456789VStack &#123; Text(&quot;Hello&quot;) Spacer().frame(height: 100) Text(&quot;World&quot;)&#125;.contentShape(Rectangle()).onTapGesture &#123; print(&quot;VStack tapped!&quot;)&#125; 没有.contentShape(Rectangle())的时候,点击在Spacer()范围,是没有反应的;若有.contentShape(Rectangle())的时候,点击在Spacer()范围,是会有反应的。 如何获知app到了后台,或者是不活跃状态? https://www.hackingwithswift.com/books/ios-swiftui/how-to-be-notified-when-your-swiftui-app-moves-to-the-background 首先,获取环境变量scenePhase;其次,使用onChange()观察这个环境变量scenePhase;最后,根据scenePhase的三种可能的状态(.active &#x2F; .inactive &#x2F; .background)做出回应。 例子如下: 1234567891011121314151617struct ContentView: View &#123; @Environment(\\.scenePhase) var scenePhase var body: some View &#123; Text(&quot;Hello, world!&quot;) .padding() .onChange(of: scenePhase) &#123; newPhase in if newPhase == .active &#123; print(&quot;Active&quot;) &#125; else if newPhase == .inactive &#123; print(&quot;Inactive&quot;) &#125; else if newPhase == .background &#123; print(&quot;Background&quot;) &#125; &#125; &#125;&#125; 经操作发现,总是这样的流程:.active与.background之间的转换,总是当中会有个过渡,即.inactive。 Accessibility 辅助功能给色盲人群的设置For example, one of the accessibility options is “Differentiate without color”, which is helpful for the 1 in 12 men who have color blindness. When this setting is enabled, apps should try to make their UI clearer using shapes, icons, and textures rather than colors.需要使用到一个环境变量,来侦测是否处于“Differentiate without color”模式: 1@Environment(\\.accessibilityDifferentiateWithoutColor) var differentiateWithoutColor 具体实例: 1234567891011121314151617struct ContentView: View &#123; @Environment(\\.accessibilityDifferentiateWithoutColor) var differentiateWithoutColor var body: some View &#123; HStack &#123; if differentiateWithoutColor &#123; Image(systemName: &quot;checkmark.circle&quot;) &#125; Text(&quot;Success&quot;) &#125; .padding() .background(differentiateWithoutColor ? .black : .green) .foregroundColor(.white) .clipShape(Capsule()) &#125;&#125; 如何在模拟器中使用到“Differentiate without color”模式: 简化动画渲染–不要动画不要动画渲染,侦测的是: 1@Environment(\\.accessibilityReduceMotion) var reduceMotion 具体实例: 123456789101112131415161718struct ContentView: View &#123; @Environment(\\.accessibilityReduceMotion) var reduceMotion @State private var scale = 1.0 var body: some View &#123; Text(&quot;Hello, World!&quot;) .scaleEffect(scale) .onTapGesture &#123; if reduceMotion &#123; scale *= 1.5 &#125; else &#123; withAnimation &#123; scale *= 1.5 &#125; &#125; &#125; &#125;&#125; 以上虽然还可以,但是,每次都要if…else…的判断,比较麻烦,所以下面的方法withOptionalAnimation可以替代withAnimation： 1234567func withOptionalAnimation&lt;Result&gt;(_ animation: Animation? = .default, _ body: () throws -&gt; Result) rethrows -&gt; Result &#123; if UIAccessibility.isReduceMotionEnabled &#123; return try body() &#125; else &#123; return try withAnimation(animation, body) &#125;&#125; 总的代码是: 1234567891011121314151617181920212223struct ContentView: View &#123;// @Environment(\\.accessibilityReduceMotion) var reduceMotion @State private var scale = 1.0 func withOptionalAnimation&lt;Result&gt;(_ animation: Animation? = .default, _ body: () throws -&gt; Result) rethrows -&gt; Result &#123; if UIAccessibility.isReduceMotionEnabled &#123; return try body() &#125; else &#123; return try withAnimation(animation, body) &#125; &#125; var body: some View &#123; Text(&quot;Hello, World&quot;) .scaleEffect(scale) .onTapGesture &#123; withOptionalAnimation &#123; scale *= 1.5 &#125; &#125; &#125;&#125; 简化透明度渲染–不要透明度不要透明度渲染,侦测的是: 12@Environment(\\.accessibilityReduceTransparency) var reduceTransparency 具体实例: 1234567891011struct ContentView: View &#123; @Environment(\\.accessibilityReduceTransparency) var reduceTransparency var body: some View &#123; Text(&quot;Hello, World!&quot;) .padding() .background(reduceTransparency ? .black : .black.opacity(0.5)) .foregroundColor(.white) .clipShape(Capsule()) &#125;&#125; 页面布局AlignmentGuides https://www.jianshu.com/p/ddd4d177fada这篇文章写的挺好。 自定义alignment guide https://www.hackingwithswift.com/books/ios-swiftui/how-to-create-a-custom-alignment-guide GeometryReaderWhich coordinate space you want to use depends on what question you want to answer: Want to know where this view is on the screen? Use the global space. Want to know where this view is relative to its parent? Use the local space. What to know where this view is relative to some other view? Use a custom space. @Environment(.horizontalSizeClass) – 获取屏幕是竖屏还是横屏状态we have only two size classes horizontally and vertically, called “compact” and “regular”.竖屏是compact,横屏是regular。 123456789101112131415struct ContentView: View &#123; @Environment(\\.horizontalSizeClass) var sizeClass var body: some View &#123; if sizeClass == .compact &#123; VStack &#123; UserView() &#125; &#125; else &#123; HStack &#123; UserView() &#125; &#125; &#125;&#125; searchable() modifier https://www.hackingwithswift.com/books/ios-swiftui/making-a-swiftui-view-searchable 搜索框的用法。一定要在NavigationView中使用。 1234567891011struct ContentView: View &#123; @State private var searchText = &quot;&quot; var body: some View &#123; NavigationView &#123; Text(&quot;Searching for \\(searchText)&quot;) .searchable(text: $searchText, prompt: &quot;Look for something&quot;) .navigationTitle(&quot;Searching&quot;) &#125; &#125;&#125; 下面是一个案例,对于页面中的内容的搜索和过滤功能： 1234567891011121314151617181920212223struct ContentView: View &#123; @State private var searchText = &quot;&quot; let allNames = [&quot;Subh&quot;, &quot;Vina&quot;, &quot;Melvin&quot;, &quot;Stefanie&quot;] var body: some View &#123; NavigationView &#123; List(filteredNames, id: \\.self) &#123; name in Text(name) &#125; .searchable(text: $searchText, prompt: &quot;Look for something&quot;) .navigationTitle(&quot;Searching&quot;) &#125; &#125; var filteredNames: [String] &#123; if searchText.isEmpty &#123; return allNames &#125; else &#123; return allNames.filter &#123; $0.contains(searchText) &#125; // 使用localizedCaseInsensitiveContains()可以忽略大小写 &#125; &#125;&#125; 搜索框实际是被隐藏的,所以需要下拉List: 还有searchCompletion() modifier for each suggestion: 123456789101112131415161718192021222324252627282930struct ContentView: View &#123; let names = [&quot;Holly&quot;, &quot;Josh&quot;, &quot;Rhonda&quot;, &quot;Ted&quot;] @State private var searchText = &quot;&quot; var body: some View &#123; NavigationView &#123; List &#123; ForEach(searchResults, id: \\.self) &#123; name in NavigationLink(destination: Text(name)) &#123; Text(name) &#125; &#125; &#125; .searchable(text: $searchText) &#123; ForEach(searchResults, id: \\.self) &#123; result in Text(&quot;Are you looking for \\(result)?&quot;).searchCompletion(result) &#125; &#125; .navigationTitle(&quot;Contacts&quot;) &#125; &#125; var searchResults: [String] &#123; if searchText.isEmpty &#123; return names &#125; else &#123; return names.filter &#123; $0.contains(searchText) &#125; &#125; &#125;&#125; SF Symbolcustom colors and transparency with SF Symbols1234Image(systemName: &quot;person.3.sequence.fill&quot;) .symbolRenderingMode(.palette) .foregroundStyle(.blue, .green, .red) .font(.system(size: 144)) 12345678Image(systemName: &quot;person.3.sequence.fill&quot;) .symbolRenderingMode(.palette) .foregroundStyle( .linearGradient(colors: [.red, .black], startPoint: .top, endPoint: .bottomTrailing), .linearGradient(colors: [.green, .black], startPoint: .top, endPoint: .bottomTrailing), .linearGradient(colors: [.blue, .black], startPoint: .top, endPoint: .bottomTrailing) ) .font(.system(size: 144)) 以上代码使用的是.foregroundStyle,而不是.foregroundColor。 layout - 页面布局fixedSize() – How to make two views the same width or height?用处,可以让HStack中的元素等高,可以让VStack中的元素等宽,看上去会很舒服。 https://www.hackingwithswift.com/quick-start/swiftui/how-to-make-two-views-the-same-width-or-height example 1: 12345678910111213HStack &#123; Text(&quot;This is a short string.&quot;) .padding() .frame(maxHeight: .infinity) .background(.red) Text(&quot;This is a very long string with lots and lots of text that will definitely run across multiple lines because it&#x27;s just so long.&quot;) .padding() .frame(maxHeight: .infinity) .background(.green)&#125;.fixedSize(horizontal: false, vertical: true).frame(maxHeight: 200) example 2: 12345678910111213141516VStack &#123; Button(&quot;Log in&quot;) &#123; &#125; .foregroundColor(.white) .padding() .frame(maxWidth: .infinity) .background(.red) .clipShape(Capsule()) Button(&quot;Reset Password&quot;) &#123; &#125; .foregroundColor(.white) .padding() .frame(maxWidth: .infinity) .background(.red) .clipShape(Capsule())&#125;.fixedSize(horizontal: true, vertical: false) safeAreaInset() – modifier是在safe area区域内插入内容,区别于ignoresSafeArea(),完全不同的概念。 https://www.hackingwithswift.com/quick-start/swiftui/how-to-inset-the-safe-area-with-custom-content 在safe area中插入一个文本: 1234567891011121314NavigationView &#123; List(0..&lt;100) &#123; i in Text(&quot;Row \\(i)&quot;) &#125; .navigationTitle(&quot;Select a row&quot;) .safeAreaInset(edge: .bottom) &#123; Text(&quot;Outside Safe Area&quot;) .font(.largeTitle) .foregroundColor(.white) .frame(maxWidth: .infinity) .padding() .background(.indigo) &#125;&#125; 在safe area中插入一个按钮,并且靠右排列: 1234567891011121314151617NavigationView &#123; List(0..&lt;100) &#123; i in Text(&quot;Row \\(i)&quot;) &#125; .navigationTitle(&quot;Select a row&quot;) .safeAreaInset(edge: .bottom, alignment: .trailing) &#123; Button &#123; print(&quot;Show help&quot;) &#125; label: &#123; Image(systemName: &quot;info.circle.fill&quot;) .font(.largeTitle) .symbolRenderingMode(.multicolor) .padding(.trailing) &#125; .accessibilityLabel(&quot;Show help&quot;) &#125;&#125; ScrollViewReader在ScrollView中进行定位的作用。 123456789101112131415161718192021222324252627ScrollViewReader inside it. This provides a scrollTo() method that can move to any view inside the parent scrollview, just by providing its anchor.For example, this creates 100 colored boxes in a vertical scroll view, and when you press the button it will scroll directly to the box with ID 8:struct ContentView: View &#123; let colors: [Color] = [.red, .green, .blue] var body: some View &#123; ScrollView &#123; ScrollViewReader &#123; value in Button(&quot;Jump to #8&quot;) &#123; value.scrollTo(8) &#125; .padding() ForEach(0..&lt;100) &#123; i in Text(&quot;Example \\(i)&quot;) .font(.title) .frame(width: 200, height: 200) .background(colors[i % colors.count]) .id(i) &#125; &#125; &#125; .frame(height: 350) &#125;&#125; ScrollViewReader - anchor让定位的图片向上对齐: 123456789101112131415161718192021222324252627anchor, to control where your target view should be positioned after the scroll has completed.For example, this will scroll to the same view as before, except this time place that view at the top:struct ContentView: View &#123; let colors: [Color] = [.red, .green, .blue] var body: some View &#123; ScrollView &#123; ScrollViewReader &#123; value in Button(&quot;Jump to #8&quot;) &#123; value.scrollTo(8, anchor: .top) &#125; .padding() ForEach(0..&lt;100) &#123; i in Text(&quot;Example \\(i)&quot;) .font(.title) .frame(width: 200, height: 200) .background(colors[i % colors.count]) .id(i) &#125; &#125; &#125; .frame(height: 350) &#125;&#125; pickerColorPicker颜色选择器: 1234567891011struct ContentView: View &#123; @State private var bgColor = Color.red var body: some View &#123; VStack &#123; ColorPicker(&quot;Set the background color&quot;, selection: $bgColor) &#125; .frame(maxWidth: .infinity, maxHeight: .infinity) .background(bgColor) &#125;&#125; 效果图:上图可以看到opacity的选择,若不需要该功能,可以: 1ColorPicker(&quot;Set the background color&quot;, selection: $bgColor, supportsOpacity: false) Link – opens a URL in Safari when pressed1Link(&quot;Learn SwiftUI&quot;, destination: URL(string: &quot;https://www.hackingwithswift.com/quick-start/swiftui&quot;)!) 按下这个类似按钮的view后,就会用Safari打开该URL网页。 程序的启动your app launches through one struct that conforms to the App protocol. Its job is to create your initial view using either WindowGroup, DocumentGroup, or similar.比如: 123456789101112struct SwiftUITestApp: App &#123; var body: some Scene &#123; WindowGroup &#123; TabView &#123; HomeView() ContactsView() LocationView() AccountView() &#125; &#125; &#125;&#125; 本来WindowGroup中是放置的ContentView()的,但你也可以放置TabView,会更方便。 另外,你也可以放一些启动程序,获取些数据什么的,都是比较有用的,比如: 12345678910111213141516@mainstruct ExampleApp: App &#123; // register initial UserDefaults values every launch init() &#123; UserDefaults.standard.register(defaults: [ &quot;name&quot;: &quot;Taylor Swift&quot;, &quot;highScore&quot;: 10 ]) &#125; var body: some Scene &#123; WindowGroup &#123; ContentView() &#125; &#125;&#125; 在body被call之前，init()就先行启动了。 detect device rotation – portrait or landscape orientation检测屏幕是竖屏还是横屏。 https://www.hackingwithswift.com/quick-start/swiftui/how-to-detect-device-rotation 123456789101112131415161718192021222324252627282930313233343536373839404142// Our custom view modifier to track rotation and// call our actionstruct DeviceRotationViewModifier: ViewModifier &#123; let action: (UIDeviceOrientation) -&gt; Void func body(content: Content) -&gt; some View &#123; content .onAppear() .onReceive(NotificationCenter.default.publisher(for: UIDevice.orientationDidChangeNotification)) &#123; _ in action(UIDevice.current.orientation) &#125; &#125;&#125;// A View wrapper to make the modifier easier to useextension View &#123; func onRotate(perform action: @escaping (UIDeviceOrientation) -&gt; Void) -&gt; some View &#123; self.modifier(DeviceRotationViewModifier(action: action)) &#125;&#125;// An example view to demonstrate the solutionstruct ContentView: View &#123; @State private var orientation = UIDeviceOrientation.unknown var body: some View &#123; Group &#123; if orientation.isPortrait &#123; Text(&quot;Portrait&quot;) &#125; else if orientation.isLandscape &#123; Text(&quot;Landscape&quot;) &#125; else if orientation.isFlat &#123; Text(&quot;Flat&quot;) &#125; else &#123; Text(&quot;Unknown&quot;) &#125; &#125; .onRotate &#123; newOrientation in orientation = newOrientation &#125; &#125;&#125; DisclosureGroup - view1234DisclosureGroup(&quot;Show Terms&quot;) &#123; Text(&quot;Long terms and conditions here long terms and conditions here long terms and conditions here long terms and conditions here long terms and conditions here long terms and conditions here.&quot;)&#125;.frame(width: 300) GroupBox - ContainersGroupBox会有一个明显的背景色,里面放view的话,感觉和Group差不多: 1234567891011GroupBox &#123; Text(&quot;Outer Content&quot;) GroupBox &#123; Text(&quot;Middle Content&quot;) GroupBox &#123; Text(&quot;Inner Content&quot;) &#125; &#125;&#125; 还能在GroupBox加上抬头: 123456GroupBox(&quot;Your account&quot;) &#123; VStack(alignment: .leading) &#123; Text(&quot;Username: tswift89&quot;) Text(&quot;City: Nashville&quot;) &#125;&#125; mask – modifier不同于clipShape(),这是在前面的view上加一层面具,而且只取面具能覆盖的那部分: 1234567Image(&quot;laser-show&quot;) .resizable() .frame(width: 300, height: 300) .mask( Text(&quot;SWIFT!&quot;) .font(.system(size: 72)) ) preivew your layout.sizeCategory environment value – preview your layout at different Dynamic Type sizes测试你的页面在不同字体大小的情况下的显示效果,可以使用.sizeCategory environment value 1234567891011121314151617struct ContentView: View &#123; var body: some view &#123; Text(&quot;Hello, World!&quot;) &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() .environment(\\.sizeCategory, .extraSmall) ContentView() ContentView() .environment(\\.sizeCategory, .accessibilityExtraExtraExtraLarge) &#125;&#125; 各个情况的显示效果:在自己的程序中测试各个字体版本的显示效果,对于页面设计是有好处的。 preferredColorScheme(.dark) – modifierpreview your layout in light and dark mode. 12345struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView().preferredColorScheme(.dark) &#125;&#125; 是这样显示的: 也可以多种效果一起显示: 1234567struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ForEach(ColorScheme.allCases, id: \\.self) &#123; ContentView().preferredColorScheme($0) &#125; &#125;&#125; 是这样显示的:精简的代码也可以这样写: 12345struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ForEach(ColorScheme.allCases, id: \\.self, content: ContentView().preferredColorScheme) &#125;&#125; .previewDevice() – modifier -preview your layout in different devices123ContentView() .previewDevice(PreviewDevice(rawValue: &quot;iPhone 12 Pro Max&quot;)) .previewDisplayName(&quot;iPhone 12&quot;) 调试Self._printChanges() – method https://www.hackingwithswift.com/quick-start/swiftui/how-to-find-which-data-change-is-causing-a-swiftui-view-to-update The Self._printChanges() method should be called inside the body property.可以用来观察View的变化: 1234567891011121314151617181920212223class EvilStateObject: ObservableObject &#123; var timer: Timer? init() &#123; timer = Timer.scheduledTimer( withTimeInterval: 1, repeats: true ) &#123; _ in if Int.random(in: 1...5) == 1 &#123; self.objectWillChange.send() &#125; &#125; &#125;&#125;struct ContentView: View &#123; @StateObject private var evilObject = EvilStateObject() var body: some View &#123; let _ = Self._printChanges() Text(&quot;What could possibly go wrong?&quot;) &#125;&#125; 上述出处文章中还讲到了一个方法,即对特定View生成随机背景色,当下次View再次被revoked的时候,背景色就会变化,就能知道是否出现变化了。 Instruments – profile your SwiftUI code and identify slow layouts https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-instruments-to-profile-your-swiftui-code-and-identify-slow-layouts Instruments – 分析您的 SwiftUI 代码并识别慢速布局 使用方法:按下Cmd+I启动Instruments,选择SwiftUI。打开后,按下record即可启动项目并观察了。 跳出指定循环在嵌套循环中,如何跳出指定循环,需要使用labeled statements。Swift’s labeled statements allow us to name certain parts of our code, and it’s most commonly used for breaking out of nested loops. 1234567891011outerLoop: for i in 1...10 &#123; for j in 1...10 &#123; let product = i * j print (&quot;\\(i) * \\(j) is \\(product)&quot;) if product == 50 &#123; print(&quot;It&#x27;s a bullseye!&quot;) break outerLoop &#125; &#125;&#125; 以上代码,会直接跳出最外层循环,因为标记是跳出outerLoop这个循环。outerLoop是可以任意取名的。若只是brea,则只跳出当前循环。 此外,continue也是可以使用labeled statements的,但https://www.hackingwithswift.com/quick-start/understanding-swift/when-to-use-break-and-when-to-use-continue中称从来没有看到有人这么做过。 catch &#x2F; throws &#x2F; rethrows https://www.donnywals.com/working-with-throwing-functions-in-swift/从一个方面讲述了try…catch的应用,以及在func中定义throws和rethrows的场景。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://giantslayer1980.github.io/categories/iOS/"},{"name":"SwiftUI","slug":"iOS/SwiftUI","permalink":"http://giantslayer1980.github.io/categories/iOS/SwiftUI/"}],"tags":[]}],"categories":[{"name":"Paintings","slug":"Paintings","permalink":"http://giantslayer1980.github.io/categories/Paintings/"},{"name":"WeChat Mini Program","slug":"WeChat-Mini-Program","permalink":"http://giantslayer1980.github.io/categories/WeChat-Mini-Program/"},{"name":"iOS","slug":"iOS","permalink":"http://giantslayer1980.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"http://giantslayer1980.github.io/categories/iOS/Swift/"},{"name":"SwiftUI","slug":"iOS/SwiftUI","permalink":"http://giantslayer1980.github.io/categories/iOS/SwiftUI/"}],"tags":[]}