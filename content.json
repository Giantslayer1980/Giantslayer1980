{"meta":{"title":"Stand-Down Comedian","subtitle":"","description":"","author":"John Doe","url":"http://Giantslayer1980.github.io","root":"/"},"pages":[],"posts":[{"title":"Swift","slug":"Swift","date":"2023-01-02T16:00:00.000Z","updated":"2023-02-27T14:42:14.050Z","comments":true,"path":"Swift/","link":"","permalink":"http://giantslayer1980.github.io/Swift/","excerpt":"UIKit is the iOS user interface toolkit. IB is Interface Builder. CA is Core Animation. Like CALayer is a Core Animation data type responsible for managing the way your view looks. Core Animation handles animation. CG is Apple’s Core Graphics framework. Like CGColor. Core Graphics handles drawing. KVO is key-value observing. NS is Next Step. Steve Jobs did lots. VFL is a technique called Auto Layout Visual Format Language. GCD is Grand Central Dispatch. FIFO is First In, First Out. MK is Mapkit. NS came from the NeXTSTEP libraries Foundation and AppKit(those names are still used by Apple’s Cocoa frameworks). UN is UserNotification. FileManager枚举程序设备目录内的所有文件1234567let fm = FileManager.defaultlet path = Bundle.main.resourcePath!let items = try! fm.contentsOfDirectory(atPath: path)for item in items &#123;&#125; BundleBundle.main.url(forResource:) – 仅通过文件名而返回该文件的urlFinding a path to a file is something you’ll do a lot, because even though you know the file is called “start.txt” you don’t know where it might be on the filesystem. So, we use a built-in method of Bundle to find it: path(forResource:). This takes as its parameters the name of the file and its path extension, and returns a String? – i.e., you either get the path back or you get nil if it didn’t exist. 1234567// 假设要找寻到start.txt这个文件if let startWordsURL = Bundle.main.url(forResource: &quot;start&quot;, withExtension: &quot;txt&quot;) &#123; // 若找到该start.txt的url后读取里面的文本内容 if let startWords = try? String(contentsOf: startWordsURL) &#123; // 省略后续代码 &#125;&#125; NSObjectNSObject is what’s called a universal base class for all Cocoa Touch classes. That means all UIKit classes ultimately come from NSObject, including all of UIKit.","text":"UIKit is the iOS user interface toolkit. IB is Interface Builder. CA is Core Animation. Like CALayer is a Core Animation data type responsible for managing the way your view looks. Core Animation handles animation. CG is Apple’s Core Graphics framework. Like CGColor. Core Graphics handles drawing. KVO is key-value observing. NS is Next Step. Steve Jobs did lots. VFL is a technique called Auto Layout Visual Format Language. GCD is Grand Central Dispatch. FIFO is First In, First Out. MK is Mapkit. NS came from the NeXTSTEP libraries Foundation and AppKit(those names are still used by Apple’s Cocoa frameworks). UN is UserNotification. FileManager枚举程序设备目录内的所有文件1234567let fm = FileManager.defaultlet path = Bundle.main.resourcePath!let items = try! fm.contentsOfDirectory(atPath: path)for item in items &#123;&#125; BundleBundle.main.url(forResource:) – 仅通过文件名而返回该文件的urlFinding a path to a file is something you’ll do a lot, because even though you know the file is called “start.txt” you don’t know where it might be on the filesystem. So, we use a built-in method of Bundle to find it: path(forResource:). This takes as its parameters the name of the file and its path extension, and returns a String? – i.e., you either get the path back or you get nil if it didn’t exist. 1234567// 假设要找寻到start.txt这个文件if let startWordsURL = Bundle.main.url(forResource: &quot;start&quot;, withExtension: &quot;txt&quot;) &#123; // 若找到该start.txt的url后读取里面的文本内容 if let startWords = try? String(contentsOf: startWordsURL) &#123; // 省略后续代码 &#125;&#125; NSObjectNSObject is what’s called a universal base class for all Cocoa Touch classes. That means all UIKit classes ultimately come from NSObject, including all of UIKit. DataData(contentsOf: URL)从特定url取得数据 123456789101112override func viewDidLoad() &#123; super.viewDidLoad() // let urlString = &quot;https://api.whitehouse.gov/v1/petitions.json?limit=100&quot; let urlString = &quot;https://www.hackingwithswift.com/samples/petitions-1.json&quot; if let url = URL(string: urlString) &#123; if let data = try? Data(contentsOf: url) &#123; // we&#x27;re OK to parse! &#125; &#125;&#125; Data.write(to:)下面是通过UIImagePickerController取得照片后写入本地的一个例子：见 UIImagePickerController –&gt; 一般示例代码 跳转到 UIViewUIView是UIKit框架里面最基础的视图类，UIView类定义了一个矩形的区域，并管理该区域内的所有屏幕显示。UIView is the parent class of all of UIKit’s view types: labels, buttons, progress views, and more.程序启动后，创建的第一个视图就是UIWindow，接着创建视图控制器的view，并把view放到UIWindow上，于是控制器的view就显示在屏幕上了。 所以我们可以这样使用UIView(): 123456override func loadView() &#123; view = UIView() view.backgroundColor = .white // more code to come!&#125; Previously we assigned a WKWebView instance directly as our view, meaning that it automatically took up all the space. Here, though, we’re going to be adding lots of child views and positioning them by hand, so we need a big, empty canvas to work with. 下面是在一个UIView()的基础上再添加一个UIView() 1234// buttonsView是为了后续添加大量UIButton进行显示的一个容器viewlet buttonsView = UIView()buttonsView.translatesAutoresizingMaskIntoConstraints = falseview.addSubview(buttonsView) tintColor任何UIView子类的tintColor属性,可以改变应用在其上的颜色效果,但具体什么效果,取决于你应用在什么上面。在navigationBar和tab bars上面,意味着改变button上的text和icons的颜色;在text views上面,意味着改变被选择和高亮的text部分的颜色;在progress bars上面,意味着改变它的track color(这是不是progress前半进程的颜色？)的颜色。在tableView的cell上面,改变的就是在editing模式下,选择区域的颜色,具体见tableView的tintColor一块的笔记。 设置单个页面的tintColor123override func viewDidLoad() &#123; view.tintColor = UIColor.red&#125; 设置项目中所有views的tint – 需要在AppDelegate.swift中设置AppDelegate.swift: 123456func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. window?.tintColor = UIColor.red return true&#125; UITableViewController需要实现的方法override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { }override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { }123456override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 在IB中的cell设置中必须注明Identifier是&quot;Picture&quot; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Picture&quot;, for: indexPath) cell.textLabel?.text = pictures[indexPath.row] return cell&#125; 可以实现的方法override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { }12345678910override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; // 1: try loading the &quot;Detail&quot; view controller and typecasting it to be DetailViewController if let vc = storyboard?.instantiateViewController(withIdentifier: &quot;Detail&quot;) as? DetailViewController &#123; // 2: success! Set its selectedImage property vc.selectedImage = pictures[indexPath.row] // 3: now push it onto the navigation controller navigationController?.pushViewController(vc, animated: true) &#125;&#125; override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) { }可以划动删除&#x2F;添加的操作。（在模拟器上没有成功,但在真机上向左划动会出现”删除”字样。） 12345678override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; objects.remove(at: indexPath.row) tableView.deleteRows(at: [indexPath], with: .fade) &#125; else if editingStyle == .insert &#123; // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view. &#125;&#125; tableView.layoutMargins &#x2F; tableView.separatorInset &#x2F; UIEdgeInsets – 修改边缘的空白空间的大小未设置前: 在viewDidLoad()中加入代码: 1234// tableView.layoutMargins -- the default spacing to use when laying out content in the view.tableView.layoutMargins = UIEdgeInsets.zero// tableView.separatorInset -- the default inset of cell separators.tableView.separatorInset = UIEdgeInsets.zero 在tableView的cellForRowAt方法中加入代码: 12// 这里是给每个cell设置layoutMarginscell.layoutMargins = UIEdgeInsets.zero 设置后的效果: tableView.backgroundColor – 设置tableView的底色将某张图片设置tableView的底色,并编排该底色 123if let backgroundImage = UIImage(named: &quot;white_wall&quot;) &#123; tableView.backgroundColor = UIColor(patternImage: backgroundImage)&#125; tableView.allowsMultipleSelection – 除了编辑状态下,允许多行选定1tableView.allowsMultipleSelection = true tableView.allowsMultipleSelectionDuringEditing – 编辑状态下允许多行选定1tableView.allowsMultipleSelectionDuringEditing = true tableView.reloadData()Reloads the rows and sections of the table view: 1tableView.reloadData() override func setEditing(_ editing: Bool, animated: Bool) {} – 默认这是个默认在tableView中会实现的方法,一般不需要去修改它。比如你定义了一个UIBarButtonItem: 1editButton = UIBarButtonItem(barButtonSystemItem: .edit, target: self, action: #selector(enterEditingMode)) 若点击该edit的button,就会自动调用到setEditing方法。setEditing(true, animated: true) – 就是出现editing模式;setEditing(false, animated: true) – 就是取消editing模式。 那么,什么时候需要覆写该setEditing方法呢?比如当你想点击该edit按钮后,你想让toolbarItems出现你自定义的按钮,包括你想取消editing模式时,又出现toolbarItems自定义的其他按钮,那你就可以去使用它,但每次覆写都必须实现super.setEditing(editing, animated: animated): 1234567891011121314151617181920212223// 点击edit按钮调用的方法:@objc func enterEditingMode() &#123; navigationItem.rightBarButtonItems = [cancelButton]// toolbarItems = [spacerButton, deleteAllButton] setEditing(true, animated: true)&#125;// 取消edit模式调用的方法:@objc func cancelEditingMode() &#123; navigationItem.rightBarButtonItems = [editButtonItem]// toolbarItems = [spacerButton, notesCountButton, spacerButton, newNoteButton] setEditing(false, animated: true)&#125;override func setEditing(_ editing: Bool, animated: Bool) &#123; // ?? super.setEditing(editing, animated: animated) if editing &#123; toolbarItems = [spacerButton] &#125; else &#123; toolbarItems = [spacerButton, notesCountButton, spacerButton, newNoteButton] &#125;&#125; tableView.isEditing – 反映tableView是否在editing模式tableView.isEditing is a boolean value that determines whether the table view is in editing mode.例子请结合 tableView.indexPathsForSelectedRows 一起看。 tableView.indexPathsForSelectedRowsThe index paths that represent the selected rows. 就是一个所有被选中cell的index列表。 12345678override func tableView(_ tableView: UITableView, didDeselectRowAt indexPath: IndexPath) &#123; if tableView.isEditing &#123; if tableView.indexPathsForSelectedRows == nil || tableView.indexPathsForSelectedRows!.isEmpty &#123; toolbarItems = [spacerButton, deleteAllButton] &#125; // 其他代码省略 &#125;&#125; tableView.indexPathForSelectedRow – 返回被选中列的IndexPathcell.selectedBackgroundView – 设置cell在选中状态下的背景view123// cell: UITableViewCell// selectedCellView: UIView?cell.selectedBackgroundView = selectedCellView cell.multipleSelectionBackgroundView – 设置cell在被多选状态下的背景view1234// cell: UITableViewCelllet multipleSelectedCellView = UIView()multipleSelectedCellView.backgroundColor = UIColor.orange.withAlphaComponent(0.2)cell.multipleSelectionBackgroundView = multipleSelectedCellView UITableViewCell.tintColor – cell在editing模式下选择区域的背景颜色12// cell: UITableViewCellcell.tintColor = .orange UIImage生成UIImage的方法UIImage(named:)12let imageName = &quot;nssl0042.jpg&quot;let image = UIImage(named: imageName) UINavigationControllerDeclaration: 1@MainActor class UINavigationController : UIViewController title - 标题直接在页面使用 title &#x3D; “ I’m the title, etc. “ 即可。 largeTitle在UINavigationController中,title的default style都是small text,那么如何设置成largeTitle呢? 1navigationController?.navigationBar.prefersLargeTitles = true 以上。 那么,一些类似detail的页面不需要largeTitle而主页面需要的情况下,该怎么设置呢？只要在detail页面加入代码: 1navigationItem.largeTitleDisplayMode = .never 以上。 UINavigationBarBy default, a UINavigationController has a bar across the top, called a UINavigationBar, and as developers we can add buttons to this navigation bar that call our methods. 1navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .action, target: self, action: #selector(shareTapped)) 这里选择的是barButtonSystemItem: .action, 可以选择其他的,比如 .cancel &#x2F; .done &#x2F; .add &#x2F; .camera &#x2F;.bookmarks &#x2F;.edit 等等很多其他的。 还可以让图标自定义显示: 1navigationItem.leftBarButtonItem = UIBarButtonItem(title: &quot;Score&quot;, style: .plain, target: self, action: #selector(showScore)) 该自定义的图标可设置样式: 1navigationItem.leftBarButtonItem.setTitleTextAttributes([NSAttributedString.Key.font: UIFont.systemFont(ofSize: 11), NSAttributedString.Key.foregroundColor : UIColor.darkText], for: .normal) 点击页面即隐藏或显示navigationBar123456789override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) navigationController?.hidesBarsOnTap = true&#125;override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) navigationController?.hidesBarsOnTap = false&#125; 在显示该页面时,即开启点击页面任何处可隐藏navigationBar,再点击可显示navigationBar的功能。但为何在viewWillDisappear中还要取消该功能?想想这样的场景,在detail页面可观看一张图片,点击可显示&#x2F;隐藏navigationBar,但如果你点击返回退回到前一页(可能是主页面),该页面并不需要隐藏navigationBar,但却在navigationController中开启了该功能,会非常的不好,所以需要取消。 Disclosure IndicatorDisclosure Indicator 即如下图每个cell右边的箭头(&gt;)符号:如何设置显示或不显示:在storyBoard中选中cell,在其的属性中的Accessory中去设置:可以看到我们选择的是DisclosureIndicator,还有DetailDisclosure&#x2F;Checkmark&#x2F;Detail都是很好的选择,主要看所使用的场景。 UINavigationController? 的 popViewController &#x2F; pushViewControllerUINavigationController是IOS编程中的一个view controller的容器，通过栈管理viewControllers，每一次pushViewController操作都将在栈顶添加一个view controller，然后通过popViewController将该栈最顶端的controller移除。上面说的栈最顶端是这样的,navigationController?.viewControllers中保存着所有的view controller,你push进去一个view controller,就放在这个列表的最后面,你pop的话,也是将列表的最后面那个view controller删除。这就是栈的后进先出的概念。 这里自己写了个例子: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ViewController.swiftclass ViewController: UIViewController &#123; @IBOutlet var textView: UITextView! override func viewDidLoad() &#123; super.viewDidLoad() navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .action, target: self, action: #selector(toDetailView)) print(navigationController?.viewControllers) // Optional([&lt;SwiftTest001.ViewController: 0x117e07490&gt;]) // 一个ViewController navigationController?.popViewController(animated: true) // 这里pop了,为什么下面显示的栈里面还是有一个ViewController? // 感觉是因为栈里总得有一个ViewController吧, // 所以这行代码是没有意义的。 print(navigationController?.viewControllers) // Optional([&lt;SwiftTest001.ViewController: 0x117e07490&gt;]) // 还是原来那个ViewController &#125; @objc func toDetailView() &#123; if let vc = storyboard?.instantiateViewController(withIdentifier: &quot;Detail&quot;) as? DetailViewController &#123; navigationController?.pushViewController(vc, animated: true) &#125; &#125;&#125;// DetailViewController.swiftclass DetailViewController: UIViewController &#123; override func viewDidLoad() &#123; navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .cancel, target: self, action: #selector(deleteTopView)) print(navigationController?.viewControllers) // Optional([&lt;SwiftTest001.ViewController: 0x117e07490&gt;, &lt;SwiftTest001.DetailViewController: 0x117e22d20&gt;]) // 有二个ViewController了,栈顶就是这个DetailViewController &#125; @objc func deleteTopView() &#123; navigationController?.popViewController(animated: true) print(navigationController?.viewControllers) // Optional([&lt;SwiftTest001.ViewController: 0x117e07490&gt;]) // 又回到原来的那个ViewController了,pop出的就是后进来的DetailViewController了。 &#125;&#125; UIButton设置UIButton上的文字 – .setTitle()12345let submit = UIButton(type: .system)submit.translatesAutoresizingMaskIntoConstraints = false// 设置显示的文字submit.setTitle(&quot;SUBMIT&quot;, for: .normal)view.addSubview(submit) 在UIButton上设置UIImage12// 前提是,button1是UIButton类型的按钮button1.setImage(UIImage(named: countries[0]), for: .normal) 设置UIButton的边框粗细1button1.layer.borderWidth = 1 our border will be 1 pixel on non-retina devices, 2 pixels on retina devices, and 3 on retina HD devices. 设置UIButton的边框颜色1button1.layer.borderColor = UIColor.lightGray.cgColor By default, the border of CALayer is black, but you can change that if you want by using the UIColor data type. I said that CALayer brings with it a little more complexity, and here’s where it starts to be visible: CALayer sits at a lower technical level than UIButton, which means it doesn’t understand what a UIColor is. UIButton knows what a UIColor is because they are both at the same technical level, but CALayer is below UIButton, so UIColor is a mystery. Don’t despair, though: CALayer has its own way of setting colors called CGColor, which comes from Apple’s Core Graphics framework. This, like CALayer, is at a lower level than UIButton, so the two can talk happily – again, as long as you’re happy with the extra complexity. Even better, UIColor (which sits above CGColor) is able to convert to and from CGColor easily, which means you don’t need to worry about the complexity. 以上的颜色也可以写成这种表现形式: 1UIColor(red: 1.0, green: 0.6, blue: 0.2, alpha: 1.0).cgColor 设置UIButton的大小1234let letterButton = UIButton(type: .system)letterButton.setTitle(&quot;WWW&quot;, for: .normal)let frame = CGRect(x: col * width, y: row * height, width: width, height: height)letterButton.frame = frame 通过IB来创建UIButton的Action方法 https://www.hackingwithswift.com/read/2/5/from-outlets-to-actions-creating-an-ibaction 在IB中通过ctrl拉动UIButton按钮至assistant页面中,跳出页面选项选择Connection:Action而非Connection:Outlet。 会生成按钮点击的@IBAction方法: 12@IBAction func buttonTapped(_ sender: UIButton) &#123;&#125; 通过此方法,可以使多个按钮使用同一方法的情况。注意:有可能上面的sender的属性是Any,这时候最好把Any改成UIButton。 如何在多个按钮使用同一方法的情况下,识别是哪个按钮被点击?在IB界面的这个UIButton属性中设置其的tag为一个唯一的数字: 随后在这个UIButton按钮的action中可查看其的tag: 123@IBAction func buttonTapped(_ sender: UIButton) &#123; print(sender.tag)&#125; sender.isHidden 的Bool值 让UIButton隐身在 @IBAction func buttonTapped(_ sender: UIButton) { 中设置sender.isHidden &#x3D; true 或者 false 可让该UIButton隐藏或显示。 通过代码来给UIButton()添加action12345678910let submit = UIButton(type: .system)submit.translatesAutoresizingMaskIntoConstraints = falsesubmit.setTitle(&quot;SUBMIT&quot;, for: .normal)view.addSubview(submit)// 为submit按钮添加一个objc类型的submitTapped方法,而且激活按钮要求是.touchUpInside,即按钮按下并松开时,松开手势得在按钮正上方submit.addTarget(self, action: #selector(submitTapped), for: .touchUpInside)@objc func submitTapped(_ sender: UIButton) &#123; &#125; 让UIButton()隐藏但仍占据位置1234567let submit = UIButton(type: .system)submit.translatesAutoresizingMaskIntoConstraints = falsesubmit.setTitle(&quot;SUBMIT&quot;, for: .normal)view.addSubview(submit)// 隐藏该submit按钮但仍旧占位submit.isHidden = true UIAlertController一般使用12345678let ac = UIAlertController(title: title, message: &quot;Your score is \\(score).&quot;, preferredStyle: .alert)ac.addAction(UIAlertAction(title: &quot;Continue&quot;, style: .default, handler: askQuestion))present(ac, animated: true)// 对应的askQuestion方法// 既设置了必要的action参数,也可在调用时不输入该参数。func askQuestion(action: UIAlertAction! = nil) &#123; &#125; Apple recommends you use .alert when telling users about a situation change, and .actionSheet when asking them to choose from a set of options. 像下面这样的方式 (preferredStyle: .actionSheet) 1234567891011121314151617181920navigationItem.rightBarButtonItem = UIBarButtonItem(title: &quot;Open&quot;, style: .plain, target: self, action: #selector(openTapped))@objc func openTapped() &#123; let ac = UIAlertController(title: &quot;Open page…&quot;, message: nil, preferredStyle: .actionSheet) // var websites = [&quot;apple.com&quot;, &quot;hackingwithswift.com&quot;] for website in websites &#123; ac.addAction(UIAlertAction(title: website, style: .default, handler: openPage)) &#125; ac.addAction(UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler: nil)) // 感觉主要是下面的代码,让菜单从下往上弹的。 // 没感觉下面这行代码的意义,没有也一样可以, // 但看到的很多代码都有这一样,而且一般是哪个button点击后调用的, // 就设置ac.popoverPresentationController?.barButtonItem对应该button。 // 但为啥要这么设置啊？？？？？？？？？？ ac.popoverPresentationController?.barButtonItem = self.navigationItem.rightBarButtonItem present(ac, animated: true)&#125; 添加TextField文本框供输入12345678910111213@objc func promptForAnswer() &#123; let ac = UIAlertController(title: &quot;Enter answer&quot;, message: nil, preferredStyle: .alert) // 可以添加不止一个TextField输入框 ac.addTextField() let submitAction = UIAlertAction(title: &quot;Submit&quot;, style: .default) &#123; [weak self, weak ac] action in guard let answer = ac?.textFields?[0].text else &#123; return &#125; self?.submit(answer) &#125; ac.addAction(submitAction) present(ac, animated: true)&#125; UIActivityViewControllerUIActivityViewController will automatically give us functionality to share by iMessage, by email and by Twitter and Facebook, as well as saving the image to the photo library, assigning it to contact, printing it out via AirPrint, and more. It even hooks into AirDrop and the iOS extensions system so that other apps can read the image straight from us. 123456789101112131415navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .action, target: self, action: #selector(shareTapped))@objc func shareTapped() &#123; guard let image = imageView.image?.jpegData(compressionQuality: 0.8) else &#123; print(&quot;No image found&quot;) return &#125; // &quot;activityItems:&quot;是要传递的东西。这里传递的是一张图片。 let vc = UIActivityViewController(activityItems: [imageView.image!], applicationActivities: []) // 这里将vc.popoverPresentationController?.barButtonItem也绑定在navigationItem.rightBarButtonItem, // 感觉是,总得绑在一个触发的UIBarButtonItem上面,而只有这个正在被触发。 vc.popoverPresentationController?.barButtonItem = navigationItem.rightBarButtonItem present(vc, animated: true)&#125; 若选择Save Image,还需要编辑Info.plist在Info.plist中添加row,选择 “Privacy - Photo Library Additions Usage Description”, 添加String值类似“We need to save photos you like.” UIToolbarUIToolbar holds and shows a collection of UIBarButtonItem objects that the user can tap on. 123456let spacer = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil)let refresh = UIBarButtonItem(barButtonSystemItem: .refresh, target: webView, action: #selector(webView.reload))toolbarItems = [spacer, refresh]// 决定toolbarItems是否显示navigationController?.isToolbarHidden = false toolbar的样式设定123456789guard let toolbar = navigationController?.toolbar else &#123; return &#125;// background: transparenttoolbar.setBackgroundImage(UIImage(), forToolbarPosition: .any, barMetrics: .default)toolbar.setShadowImage(UIImage(), forToolbarPosition: .any)toolbar.isTranslucent = true// foregroundtoolbar.tintColor = .orange WKWebViewimport1import WebKit 正常使用1234567891011121314151617class ViewController: UIViewController, WKNavigationDelegate &#123; var webView: WKWebView! // 为什么要在loadView()而非viewDidLoad()中加载webView,那是因为这个view需要直接load成功,而非load完后再去加载,感觉会造成资源浪费 override func loadView() &#123; webView = WKWebView() // 因为下面这行,所以ViewController需要遵循WKNavigationDelegate !!! webView.navigationDelegate = self view = webView &#125; override func viewDidLoad() &#123; let url = URL(string: &quot;https://www.hackingwithswift.com&quot;)! webView.load(URLRequest(url: url)) webView.allowsBackForwardNavigationGestures = true &#125;&#125; 使用webView加载内容,并显示出来显示效果是类似这样的: 1234567891011121314151617181920212223242526272829303132333435363738import UIKitimport WebKitstruct Petition: Codable &#123; var title: String var body: String var signatureCount: Int&#125;class DetailViewController: UIViewController &#123; var webView: WKWebView! var detailItem: Petition? override func loadView() &#123; webView = WKWebView() view = webView &#125; override func viewDidLoad() &#123; super.viewDidLoad() guard let detailItem = detailItem else &#123; return &#125; let html = &quot;&quot;&quot; &lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;style&gt; body &#123; font-size: 150%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; \\(detailItem.body) &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot; webView.loadHTMLString(html, baseURL: nil) &#125;&#125; webView可实现的方法func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) { }123func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) &#123; title = webView.title&#125; 可实现网页显示标题 func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) { }1234567891011121314func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) &#123; let url = navigationAction.request.url if let host = url?.host &#123; for website in websites &#123; if host.contains(website) &#123; decisionHandler(.allow) return &#125; &#125; &#125; decisionHandler(.cancel)&#125; 这方法就像是网页浏览器的过滤器,任何url都会在这边过滤一下,最终决定是decisionHandler(.allow)运行呢,还是decisionHandler(.cancel)拒绝呢。 UIProgressViewUIProgressView is a colored bar that shows how far a task is through its work, sometimes called a “progress bar.” 实际案例 + 使用到addObserver&#x2F;observeValue这两个观察者&#x2F;处理者(即KVO)通过网页的加载进度,直接反映在UIProgressView进度条上: https://www.hackingwithswift.com/read/4/4/monitoring-page-loads-uitoolbar-and-uiprogressview 123456789101112131415161718192021222324252627282930313233343536var progressView: UIProgressView!override func loadView() &#123; webView = WKWebView() webView.navigationDelegate = self view = webView&#125;override func viewDidLoad() &#123; // 省略其他代码 let url = URL(string: &quot;https://hackingwithswift.com&quot;)! webView.load(URLRequest(url: url)) progressView = UIProgressView(progressViewStyle: .default) progressView.sizeToFit() let progressButton = UIBarButtonItem(customView: progressView) // 这里就让progressButton占满toolbarItems这一整行 toolbarItems = [progressButton] // 决定toolbarItems是否显示 navigationController?.isToolbarHidden = false // 在这个被定位主view的webView中增加一个观察者,主要观察这个key--WKWebView.estimatedProgress,有变化就会被告知 webView.addObserver(self, forKeyPath: #keyPath(WKWebView.estimatedProgress), options: .new, context: nil)&#125;// 这是观察后实时进行处理的函数override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123; if keyPath == &quot;estimatedProgress&quot; &#123; // estimatedProgress is a Double, Unhelpfully, UIProgressView&#x27;s progress property is a Float progressView.progress = Float(webView.estimatedProgress) &#125;&#125; UITextCheckerUITextChecker类来源于UIKit,在SwiftUI没有替代方案的情况下,只能使用该方法了。 使用的案例(简单实现,下面的NSRange和rangeOfMisspelledWord又会重复一遍这个操作):查找用户输入的英语单词是否在字典里,有没有拼错的情况: 12345678910111213141516import UIKitlet word = &quot;swift&quot;let checker = UITextChecker()// location是从哪个位置开始,一般都是0,length是计算word在utf16中的长度let range = NSRange(location: 0, length: word.utf16.count)// in是要核对的词,range是核对的范围长度,wrap是持续核对的意思(具体没有试过)let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: &quot;en&quot;)// 返回值要么是The range of the first misspelled word encountered// 没找到就是&#123;NSNotFound, 0&#125; if none is found.let allGood = misspelledRange.location == NSNotFound// 有这个单词也没拼错的情况返回true,不然返回false 方法的解释可以参考下面的文章: https://www.hackingwithswift.com/books/ios-swiftui/working-with-stringshttps://www.hackingwithswift.com/books/ios-swiftui/validating-words-with-uitextchecker 注意：UITextChecker uses the built-in system dictionary.我们不用为其特意准备单词表等文档。 Auto Layout 自动页面布局的设置通过Storyboard来设置 https://www.hackingwithswift.com/read/6/2/advanced-auto-layout 以上是三面国旗间如何通过storyboard来自动设置布局,以让起在portrait&#x2F;landscape中均能够有一个好的效果。通过该视频就能大致了解了,而看文字的话比较繁琐。 通过Storyboard自动布局后如何让它变为自动布局在Storyboard中布局各个view后,可以让屏幕自动布局页面,这样在landscape或是不同屏幕大小的机型上,都可以自动适应布局: Select the view controller by clicking on “View Controller” in the document outline, then go to the Editor menu and choose Resolve Auto Layout Issues &gt; Reset To Suggested Constraints. 通过Storyboard布局后,如何让一个view在Storyboard上回到它应该显示的位置上？我们在Storyboard上扔下一个UILabel,让其显示”Here is a UILbale !”,字体设置为30,随后通过鼠标contrl指向空白处,此时选择”Center Horizontally in safe area” &#x2F; “Center Vertically in safe area”,随后鼠标点击该label,我们看的是:我们来分析一个这个图:可以看到实线包围的label和一个虚线包围的label。实线的(the solid orange lines)代表你的label现在在的位置,而虚线的(the dashed orange lines)代表程序运行后你的label会在的位置。 那么如何让这个label回到它在程序运行后应该在的位置呢?Editor menu and choosing Resolve Auto Layout Issues &gt; Update Frames设置后是这样的:这样就这样了,没有橙线了。 通过addConstraints with Visual Format Language (VFL) https://www.hackingwithswift.com/read/6/3/auto-layout-in-code-addconstraints-with-visual-format-language 一个不通过Storyboard可视化布局来显示页面的简单例子:(因为之前有执念一直在想有没有办法能够实现,所以一知道怎么做了,就写进了笔记里) 123456789101112131415override func viewDidLoad() &#123; super.viewDidLoad() let imageView = UIImageView() // 关键的translatesAutoresizingMaskIntoConstraints的设置 imageView.translatesAutoresizingMaskIntoConstraints = false imageView.image = UIImage(systemName: &quot;star&quot;) imageView.layer.backgroundColor = UIColor.red.cgColor // 这里不要关心我这里布局代码用到的是anchor,只是随便用了个布局方法 imageView.widthAnchor.constraint(equalToConstant: 100).isActive = true imageView.heightAnchor.constraint(equalToConstant: 100).isActive = true view.addSubview((imageView)) &#125; 这里之前一直想随便写个view让其能够显示,始终没有显示,后来发觉是因为没有这行代码: 1imageView.translatesAutoresizingMaskIntoConstraints = false because by default iOS generates Auto Layout constraints for you based on a view’s size and position. We’ll be doing it by hand, so we need to disable this feature. Q: 为什么 imageView.translatesAutoresizingMaskIntoConstraints &#x3D; true 的时候就没有显示这个view呢？A: I have no answer……. 详细一点的例子: 12345678910111213141516171819202122232425262728293031323334353637383940// 首先是 五个label图像元素verride func viewDidLoad() &#123; super.viewDidLoad() let label1 = UILabel() label1.translatesAutoresizingMaskIntoConstraints = false label1.backgroundColor = UIColor.red label1.text = &quot;THESE&quot; label1.sizeToFit() let label2 = UILabel() label2.translatesAutoresizingMaskIntoConstraints = false label2.backgroundColor = UIColor.cyan label2.text = &quot;ARE&quot; label2.sizeToFit() let label3 = UILabel() label3.translatesAutoresizingMaskIntoConstraints = false label3.backgroundColor = UIColor.yellow label3.text = &quot;SOME&quot; label3.sizeToFit() let label4 = UILabel() label4.translatesAutoresizingMaskIntoConstraints = false label4.backgroundColor = UIColor.green label4.text = &quot;AWESOME&quot; label4.sizeToFit() let label5 = UILabel() label5.translatesAutoresizingMaskIntoConstraints = false label5.backgroundColor = UIColor.orange label5.text = &quot;LABELS&quot; label5.sizeToFit() view.addSubview(label1) view.addSubview(label2) view.addSubview(label3) view.addSubview(label4) view.addSubview(label5)&#125; 现在这些图像都挤在左上角！还互相叠着！ 设置一个dict: 1let viewsDictionary = [&quot;label1&quot;: label1, &quot;label2&quot;: label2, &quot;label3&quot;: label3, &quot;label4&quot;: label4, &quot;label5&quot;: label5] 添加布局: 123for label in viewsDictionary.keys &#123; view.addConstraints( NSLayoutConstraint.constraints(withVisualFormat: &quot;H:|[\\(label)]|&quot;, options: [], metrics: nil, views: viewsDictionary))&#125; NSLayoutConstraint.constraints(withVisualFormat:)相对比较关键。里面的用字符串表示的”H:|[label1]|”中,H代表Horizontal,前后的两个｜分别代表了屏幕的左右边缘。 看懂下面的代码: 1view.addConstraints( NSLayoutConstraint.constraints(withVisualFormat: &quot;V:|[label1]-[label2]-[label3]-[label4]-[label5]&quot;, options: [], metrics: nil, views: viewsDictionary)) 5个label按照次序沿着屏幕左侧开始依次排列。其中分隔每个label的符号”-“意味着有间隔,这个间隔的默认值是10,可以自定义。 以及设置更精确的数据: 1view.addConstraints( NSLayoutConstraint.constraints(withVisualFormat: &quot;V:|[label1(==88)]-[label2(==88)]-[label3(==88)]-[label4(==88)]-[label5(==88)]-(&gt;=10)-|&quot;, options: [], metrics: nil, views: viewsDictionary)) 以及使用到metrics参数的情况: 12let metrics = [&quot;labelHeight&quot;: 88]view.addConstraints( NSLayoutConstraint.constraints(withVisualFormat: &quot;V:|[label1(labelHeight)]-[label2(labelHeight)]-[label3(labelHeight)]-[label4(labelHeight)]-[label5(labelHeight)]-&gt;=10-|&quot;, options: [], metrics: metrics, views: viewsDictionary)) So when your designer &#x2F; manager &#x2F; inner-pedant decides that 88 points is wrong and you want some other number, you can change it in one place to have everything update. 以及使用优先级priority的情况:(优先级是从1-1000,数字越大优先级越高) - @数字 1&quot;V:|[label1(labelHeight@999)]-[label2(label1)]-[label3(label1)]-[label4(label1)]-[label5(label1)]-&gt;=10-|&quot; 自己理解:label1设置了一个高度,并对该高度设置了一个优先级,那么其他四个label的高度和其一样(包括优先级)。 通过Auto Layout anchors来自动布局Every UIView has a set of anchors that define its layouts rules.The most important ones arewidthAnchor, heightAnchor, topAnchor, bottomAnchor, leftAnchor, rightAnchor, leadingAnchor, trailingAnchor, centerXAnchor, and centerYAnchor. 一般用例: 1234for label in [label1, label2, label3, label4, label5] &#123; label.widthAnchor.constraint(equalTo: view.widthAnchor).isActive = true label.heightAnchor.constraint(equalToConstant: 88).isActive = true&#125; 一般用例: 1234567if let previous = previous &#123; // we have a previous label – create a height constraint label.topAnchor.constraint(equalTo: previous.bottomAnchor, constant: 10).isActive = true&#125; else &#123; // this is the first label label.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 0).isActive = true&#125; 这里用到的view.safeAreaLayoutGuide其实理解下来就是除了上下那两块的其他安全区域的屏幕范围。 还有这样的: 1yourView.widthAnchor.constraint(equalTo: view.safeAreaLayoutGuide.widthAnchor, multiplier: 0.5, constant: 50).isActive = true 就是在0.5倍的基础上再加50的意思。 还可以用到NSLayoutConstraint.activate集合很多规则: 123456NSLayoutConstraint.activate([ scoreLabel.topAnchor.constraint(equalTo: view.layoutMarginsGuide.topAnchor), scoreLabel.trailingAnchor.constraint(equalTo: view.layoutMarginsGuide.trailingAnchor), // more constraints to be added here!]) Notice the way I’m pinning the label to view.layoutMarginsGuide – that will make the score label have a little distance from the right edge of the screen. yourView.setContentHuggingPriority(UILayoutPriority(Int), for: )12cluesLabel.setContentHuggingPriority(UILayoutPriority(1), for: .vertical)answersLabel.setContentHuggingPriority(UILayoutPriority(1), for: .vertical) 优先级是从1-1000的,此处设置为1,代表最没有优先级,for是指适用于垂直面的。 创建的Game项目的屏幕大小layout的适配 https://www.hackingwithswift.com/read/14/2/getting-up-and-running-skcropnode 创建了一个Game项目,之前教程中均是使用spriteKit来制作的,一般都会设置屏幕大小为1024*768,这在一般iPad上都没问题,11-inch iPad Pro会比较特殊,所以需要做一个适配:在GameViewController.swift中,将“scene.scaleMode &#x3D; .aspectFill”替换成“scene.scaleMode &#x3D; .fill” UIEdgeInsets – 类似于给UIView加一个padding的设置我们创建一个UITextView: 1@IBOutlet var textView: UITextView! 并在storyboard上设置了它的大小,执行后是这样的: 如果我们给它加上Inset: 1textView.contentInset = UIEdgeInsets(top: 50, left: 50, bottom: 50, right: 50) 它就会是这样: UITabBarController如何更改Tabbar的显示文字和图标假设3个页面依次嵌套是这样的:View Controller Scene – Navigation Controller Scene – Tab Bar Controller Scene 如何更改Tabbar的显示文字和图标？需要在Storyboard中找到Navigation Controller Scene(而非Tab Bar Controller Scene),随后选到这个Tabbar元素(a new type of object called a UITabBarItem),再右侧属性栏的Bar Item中去更改其的Title和Image。 如何增加Tab页面 https://www.hackingwithswift.com/read/7/5/finishing-touches-didfinishlaunchingwithoptions 打开AppDelegate.swif,找寻到didFinishLaunchingWithOptions方法,在里面添加如下代码,最终的代码是: 12345678910111213141516func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -&gt; Bool &#123; if let tabBarController = window?.rootViewController as? UITabBarController &#123; // 以上代码,因为上面讲过3个页面嵌套,Tab Bar Controller Scene是最root的view // 找到我们的storyboard,我们的storyboard默认取名是Main let storyboard = UIStoryboard(name: &quot;Main&quot;, bundle: nil) // 之前给Navigation Controller Scene起过一个StoryboardID是NavController,这里生成一个这样的页面 let vc = storyboard.instantiateViewController(withIdentifier: &quot;NavController&quot;) // 从storyboard中可以看到,Navigation Controller Scene里面有一个tabBarItem, // 所以给tabBarItem定义成一个UITabBarItem,重要的是tag为1,因为本来就有存在的那个tag为0 vc.tabBarItem = UITabBarItem(tabBarSystemItem: .topRated, tag: 1) // 将该tabBarItem所在的vc添加进tabBarController tabBarController.viewControllers?.append(vc) &#125; return true&#125; 随后,如何在相同的一个ViewControllerScene中区别开是哪个tab页面? 123456789let urlString: Stringif navigationController?.tabBarItem.tag == 0 &#123; // urlString = &quot;https://api.whitehouse.gov/v1/petitions.json?limit=100&quot; urlString = &quot;https://www.hackingwithswift.com/samples/petitions-1.json&quot;&#125; else &#123; // urlString = &quot;https://api.whitehouse.gov/v1/petitions.json?signatureCountFloor=10000&amp;limit=100&quot; urlString = &quot;https://www.hackingwithswift.com/samples/petitions-2.json&quot;&#125; UILabel()12345678910111213scoreLabel = UILabel()scoreLabel.translatesAutoresizingMaskIntoConstraints = false// 设置对齐scoreLabel.textAlignment = .right// 设置内容scoreLabel.text = &quot;Score: 0&quot;// 设置字体大小scoreLabel.font = UIFont.systemFont(ofSize: 24)// 设置背景色scoreLabel.backgroundColor = .blue// 设置字体颜色scoreLabel.textColor = UIColor.redview.addSubview(scoreLabel) UITextfield1234567891011currentAnswer = UITextField()currentAnswer.translatesAutoresizingMaskIntoConstraints = false// 设置placeholdercurrentAnswer.placeholder = &quot;Tap letters to guess&quot;// 设置对齐currentAnswer.textAlignment = .center// 设置字体大小currentAnswer.font = UIFont.systemFont(ofSize: 44)// 设置是否用户可输入currentAnswer.isUserInteractionEnabled = falseview.addSubview(currentAnswer) 注意:UITextField只能显示一行,而UITextView可以显示多行,这就是两者的区别。 UITextViewUITextView可以显示多行,而UITextField只能显示一行,这就是两者的区别。 UITextView.contentInset – 类似于一个padding具体操作见 “Auto Layout 自动页面布局的设置” -&gt; “UIEdgeInsets” 。 UITextView.endEditing(true&#x2F;false) – 隐藏&#x2F;显示 keyboard12// textView: UITextViewtextView.endEditing(true) GCD - Grand Central DispatchGCD是帮助你自动化管理进程的一套东西。GCD中的三个方法之一，最重要的就是async()。 后台进程中,有四种选择,或者叫QoS level set: User Interactive: this is the highest priority background thread, and should be used when you want a background thread to do work that is important to keep your user interface working. This priority will ask the system to dedicate nearly all available CPU time to you to get the job done as quickly as possible. User Initiated: this should be used to execute tasks requested by the user that they are now waiting for in order to continue using your app. It’s not as important as user interactive work – i.e., if the user taps on buttons to do other stuff, that should be executed first – but it is important because you’re keeping the user waiting. The Utility queue: this should be used for long-running tasks that the user is aware of, but not necessarily desperate for now. If the user has requested something and can happily leave it running while they do something else with your app, you should use Utility. The Background queue: this is for long-running tasks that the user isn’t actively aware of, or at least doesn’t care about its progress or when it completes. Those QoS queues affect the way the system prioritizes your work: User Interactive and User Initiated tasks will be executed as quickly as possible regardless of their effect on battery life, Utility tasks will be executed with a view to keeping power efficiency as high as possible without sacrificing too much performance, whereas Background tasks will be executed with power efficiency as its priority. 如何使用: 123// 在默认的Background queue进程中// The default GCD background queue has a lower priority than .userInitiated but higher than .utility.DispatchQueue.global().async &#123; 12// 指定在User Initiated进程中DispatchQueue.global(qos: .userInitiated).async &#123; 此外,在 async() 里面的代码不需要使用[weak self] in之类的语句,因为async()执行完就会被丢弃,不存在留存东西的情况。 performSelector(inBackground:) 和 performSelector(onMainThread:) 这两种方法更好用一些,因为更加简单,只要决定是放在main thread,还是background上运行就行。(初步用下来,performSelector会有些问题,莫名的警告之类的,可能更推荐使用DispatchQueue.global()&#x2F;DispatchQueue.main之类的吧)示例代码: 1234567performSelector(onMainThread: #selector(showError), with: nil, waitUntilDone: false)@objc func showError() &#123; let ac = UIAlertController(title: &quot;Loading error&quot;, message: &quot;There was a problem loading the feed; please check your connection and try again.&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) present(ac, animated: true)&#125; This is an Objective-C call, so the @objc attribute is required. 这里发现个情况，几种代码的情况竟然都是可以的:场景是,一个class ViewController: UITableViewController内定义了fun tableView的实现,这时候,需要在background中对tabaleView中的UI数据进行更新,肯定是要在主线程即main thread中更新的,我们可以: 123DispatchQueue.main.async &#123; self?.tableView.reloadData()&#125; 也可以: 12// 这里写self?是因为在DispatchQueue.global().async这个closure中,里面引用的外部self必须是个optional,这里请忽略self?.tableView.performSelector(onMainThread: #selector(self?.tableView.reloadData), with: nil, waitUntilDone: false) 竟然还可以: 1self?.tableView.performSelector(onMainThread: #selector(UITableView.reloadData), with: nil, waitUntilDone: false) 没想到的是,#selector(UITableView.reloadData)中的“UITableView.”竟然也是可以引用到这个方法的,一时半会儿有点概念不清晰，但又感觉可能可以。 UICollectionView https://www.hackingwithswift.com/read/10/2/designing-uicollectionview-cells 在Storyboard上创建UIColletionView的过程,与创建UITableView差不多,也是在删除原有的controller,在libraries里拖拉出一个Collection View Controller拖进storyboard。 接下来要建立一个对应UICollectionViewCell的Cocoa Touch Class的文件,在storyboard中找到CollectionViewCell(就如同找到table cell一样),让其的class对应该协议,此外要给该CollectionViewCell的identifier取个名字,好在代码中生成这个cell。 需要实现的方法override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int { }示例代码: 123override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 10&#125; override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {}示例代码: 123456789override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;Person&quot;, for: indexPath) as? PersonCell else &#123; // we failed to get a PersonCell – bail out! fatalError(&quot;Unable to dequeue PersonCell.&quot;) &#125; // if we&#x27;re still here it means we got a PersonCell, so we can return it return cell&#125; 可以实现的方法override func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) { }示例代码: 1234567891011121314151617override func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; let person = people[indexPath.item] let ac = UIAlertController(title: &quot;Rename person&quot;, message: nil, preferredStyle: .alert) ac.addTextField() ac.addAction(UIAlertAction(title: &quot;Cancel&quot;, style: .cancel)) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default) &#123; [weak self, weak ac] _ in guard let newName = ac?.textFields?[0].text else &#123; return &#125; person.name = newName self?.collectionView.reloadData() &#125;) present(ac, animated: true)&#125; UIImagePickerControllerThis new class is designed to let users select an image from their camera to import into an app. When you first create a UIImagePickerController, iOS will automatically ask the user whether the app can access their photos. privacy permission查看、使用用户的照片,需要对用户进行告知:we need to add a text string describing our intent. So, open Info.plist, select any item, click +, then choose the key name “Privacy - Photo Library Additions Usage Description”. Give it the value “We need to import photos” then press return. 一般示例代码123456789101112// 先由一个按钮引出navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(addNewPerson))// 引出方法@objc func addNewPerson() &#123; let picker = UIImagePickerController() picker.allowsEditing = true // 由于这行代码,需要本身的class必须遵循到UIImagePickerControllerDelegate protocol, // 而且还要额外遵循 UINavigationControllerDelegate protocol. picker.delegate = self present(picker, animated: true)&#125; 用户选择照片后,会自动运行到一个方法: 123456789101112131415161718func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) &#123;ntroller, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) &#123; guard let image = info[.editedImage] as? UIImage else &#123; return &#125; let imageName = UUID().uuidString let imagePath = getDocumentsDirectory().appendingPathComponent(imageName) if let jpegData = image.jpegData(compressionQuality: 0.8) &#123; try? jpegData.write(to: imagePath) &#125; dismiss(animated: true)&#125;func getDocumentsDirectory() -&gt; URL &#123; let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask) return paths[0]&#125; 其中,info参数是一个dict,它有两个参数,分别是 .editedImage (the image that was edited) or .originalImage , but in our case it should only ever be the former unless you change the allowsEditing property. SpriteKit(According to the project 11 from “100 hundred days of Swift”) Create a new project in xCode and choose Game, sets its Game Technology to be Spritekit. 坐标系统的不同1.UIKit的物体坐标都是基于一个view的左上角为起点的,而SpriteKit是基于物体的中心点。2.UIKit的坐标系Y:0是基于屏幕的上边沿,而SpriteKit是基于屏幕的下边沿。 GameScene.sks 是类似于Interface Builder的双击打开GameScene.sks,就打开了Scene Editor,这图形界面类似于Interface Builder。 SKScene当建立一个project是基于Game的，那么GameScene.swift文件的GameScene这个class就是基于SKScene协议的。 didMove(to:) 类似于viewDidLoad()在里面写入代码: 123456789101112override func didMove(to view: SKView) &#123; // 建立一个背景图片的节点 let background = SKSpriteNode(imageNamed: &quot;background.jpg&quot;) // 图片的中心点是基于CGPoint坐标的,这里设置的是屏幕的中心点 background.position = CGPoint(x: 512, y: 384) // The .replace option means &quot;just draw it, ignoring any alpha values,&quot; which makes it fast for things without gaps such as our background. background.blendMode = .replace // 这个背景图片的节点在整个场景的z坐标的-1位置,其实就是放在最后面 background.zPosition = -1 // 这是用于给场景添加节点的方法 addChild(background)&#125; override func didMove(to view: SKView) { }这个类似于viewDidLoad方法。 override func update(_ currentTime: TimeInterval) { }The update() method is called once every frame, and lets us make changes to our game.Try not to do too much work, because it can slow your game down. override func touchesBegan(_ touches: Set, with event: UIEvent?) { }1234567891011121314override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; // 每次触碰到屏幕就会进入循环 if let touch = touches.first &#123; // 取得触碰的位置坐标 let location = touch.location(in: self) // 生成一个SKSpriteNode节点,该节点是基于CGSize生成的一个红色正方形 let box = SKSpriteNode(color: UIColor.red, size: CGSize(width: 64, height: 64)) // 该正方形所放置的位置 box.position = location // 添加进场景 addChild(box) &#125;&#125; override func touchesEnded(_ touches: Set, with event: UIEvent?) {}Tells the responder when one or more fingers raised from a view or window. override func touchesMoved(_ touches: Set, with event: UIEvent?) { }测试下来,跟touchesBegan一样的用法,只是它只在触摸屏幕并移动时,才会被触发。touchesMoved() is called when an existing touch changes position. SKSpriteNode 类似于各个主页面的节点建立一个正方形: 1SKSpriteNode(color: UIColor.red, size: CGSize(width: 64, height: 64)) 建立一个基于image文件的图形: 1SKSpriteNode(imageNamed:) 好像不能直接建立一个圆形,是不是先要做一个圆形出来,随后再基于该圆形设计出该SKSpriteNode?待后续碰到了再补充吧…但下面代码中ball.physicsBody &#x3D; SKPhysicsBody(circleOfRadius: ball.size.width &#x2F; 2.0)就可以设计出一个圆形的物理属性来。 SKSpriteNode.texture -&gt; SKTexture(imageNamed:)class called SKTexture, which is to SKSpriteNode sort of what UIImage is to UIImageView – it holds image data, but isn’t responsible for showing it. 1234567// 之前设定的charNode是一个SKSpriteNode,显示的是图片&quot;penguinGood&quot;charNode = SKSpriteNode(imageNamed: &quot;penguinGood&quot;)// 但现在我想把charNode显示的图片改成是&quot;penguinEvil&quot;// 这时只要更改charNode的材质,即charNode.texture// open class SKSpriteNode : SKNode, SKWarpable &#123;// open var texture: SKTexture?charNode.texture = SKTexture(imageNamed: &quot;penguinEvil&quot;) Changing the character node’s texture like this is helpful because it means we don’t need to keep adding and removing nodes. Instead, we can just change the texture to match what kind of penguin this is, then change the node name to match so we can do tap detection later on. SKSpriteNode(texture:)可以直接用SKTexture生成SKSpriteNode,而不需要再设置SKSpriteNode的texture: 1234// 先设置SKTexturelet skyTexture = SKTexture(imageNamed: &quot;sky&quot;)// 再生成SKSpriteNodelet sprite = SKSpriteNode(texture: skyTexture) SKSpriteNode.colorBlendFactor &#x3D; 1 &amp;&amp; SkSpriteNode.color &#x3D; .redOnly SKSpriteNode has a colorBlendFactor property !!!SKSpriteNode.colorBlendFactor是一个CGFloat,从0.0到1.0,代表与原材质的颜色的混同程序,0.0代表颜色不会改变,就是原材质,1.0代表可以完全改变原材质的颜色。 1234let firework = SKSpriteNode(imageNamed: &quot;rocket&quot;)firework.colorBlendFactor = 1// 这时可以设置其的颜色fireworl.color = .cyan SKShapeNodeSKShapeNode是SpriteKit的一个class,它可以让你在Game中方便且快捷地画出随意的图形,比如画圆形、线、长方形,之前接触到的就是使用贝塞尔图形来画画,在Project23中,水果忍者游戏中用来切水果划屏幕的那条线,它的容器就是SKShapeNode。 SKShapeNode有一个属性叫path,是用来描绘我们想要画的图形的。当path为nil,就什么都不画了;当path被设置为一个有效的路径的话,就可以按照SKShapeNode的设置来画图形了。另外,SKShapeNode期望的path是一个CGPath属性,而我们使用UIBezierPath.cgPath就能够符合这一要求了。 1234567let shape = SKShapeNode()shape.path = UIBezierPath(roundedRect: CGRect(x: -128, y: -128, width: 256, height: 256), cornerRadius: 64).cgPathshape.position = CGPoint(x: frame.midX, y: frame.midY)shape.fillColor = UIColor.redshape.strokeColor = UIColor.blueshape.lineWidth = 10addChild(shape) 水果忍者中那条划过屏幕的线代码太多,还是看教程中的代码,读一遍就懂了。 https://www.hackingwithswift.com/example-code/games/how-to-create-shapes-using-skshapenode SKPhysicsBody属性感觉是给 场景 或 节点 添加物理属性范围的。 1234567// box虽然有两个框架,就是上面设置的正方形// 但还得给这个box设置一个物理框架,范围就是这个正方形的范围(也就是说也能设置个圆形物理框架吧吧)box.physicsBody = SKPhysicsBody(rectangleOf: CGSize(width: 64, height: 64))// The second line of code adds a physics body to the whole scene that is a line on each edge, effectively acting like a container for the scene.physicsBody = SKPhysicsBody(edgeLoopFrom: frame) 还能添加圆形的球以及圆形的物理属性范围,以及使用到 .resitution 的反弹属性,值范围为0-1的小数。 1234567let ball = SKSpriteNode(imageNamed: &quot;ballRed&quot;)// ball的物理属性范围仍旧是其本身ball.physicsBody = SKPhysicsBody(circleOfRadius: ball.size.width / 2.0)// restitution是 恢复原状 的意思ball.physicsBody?.restitution = 0.4ball.position = locationaddChild(ball) 设计一个有物理属性但不会跟着动的东西,简单说就是,我造了个东西,这东西被撞了却不会动,但撞它的其他东西会被弹开:这里使用到了 .isDynamic : 12345let bouncer = SKSpriteNode(imageNamed: &quot;bouncer&quot;)bouncer.position = CGPoint(x: 512, y: 0)bouncer.physicsBody = SKPhysicsBody(circleOfRadius: bouncer.size.width / 2.0)bouncer.physicsBody?.isDynamic = falseaddChild(bouncer) SKPhysicsBody(texture: &lt;#T##SKTexture#&gt;, size: &lt;#T##CGSize#&gt;)之前都是SKPhysicsBody(circleOfRadius),或者SKPhysicsBody(rectangleOf: &lt;#T##CGSize#&gt;)来定义,虽然对生成SKPhysicsBody的效率会有很大的提高,但有时候需要让该物体的每个pixel都作为SKPhysicsBody的时候,就需要用到SKPhysicsBody(texture: &lt;#T##SKTexture#&gt;, size: &lt;#T##CGSize#&gt;),虽然会降低效率,但有时是有必要的。SpriteKit can create pixel-perfect collision detection by examining the pixels in a sprite’s texture. 123// let sprite = SKSpriteNode(imageNamed: &quot;enemy&quot;)sprite.physicsBody = SKPhysicsBody(texture: sprite.texture!, size: sprite.size) 节点的physicsBody?.categoryBitMask属性碰撞的时候,需要识别碰撞体,最简单的方式,是给节点设置一个name的值,但也可以给节点的physicsBody?.categoryBitMask添加值,这里的bit可以理解为是位运算的意思。注意：UInt8,UInt16,UInt32,UInt64 分别表示 8 位,16 位,32 位 和 64 位的无符号整数形式。比如: 12345// 设置物理体的标示符 &lt;&lt;左移运算符 左移一位，相当于扩大2倍let birdCategory: UInt32 = 1 &lt;&lt; 0 //1let worldCategory: UInt32 = 1 &lt;&lt; 1 //2let pipeCategory: UInt32 = 1 &lt;&lt; 2 //4let scoreCategory: UInt32 = 1 &lt;&lt; 3 //8 具体的例子见 ontactTestBitMask &amp;&amp; collisionBitMask 知识点。(会带上上面的四个标识符一起使用) 节点的physicsBody?的velocity速度属性可设置该节点的速度,比如在touchesBegan方法中,当用户点击屏幕,就对速度进行更改: 12345678910override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; // 省略其他代码 // 本来因为重力等原因dy是负值,用户点击的同时,值为0 bird.physicsBody?.velocity = CGVector(dx: 0, dy: 0) // 但一旦停止点击,dy的值又会变成负值,小鸟又会不断下降,这是因为 // self.physicsWorld.gravity = CGVector(dx: 0.0, dy: -3.0) 这个的预先设定 // 此时可以给其一个向上的速度或是力 bird.physicsBody?.applyImpulse(CGVector(dx: 0, dy: 10)) 节点的physicsBody?的applyImpulse方法在 “节点的physicsBody?的velocity速度属性”知识点的例子中已经出现。 节点的physicsBody?的angularVelocity属性angularVelocity 是指自身旋转的速度。 123// sprite.physicsBody = SKPhysicsBody(texture: sprite.texture!, size: sprite.size)sprite.physicsBody?.angularVelocity = 5 节点的physicsBody?angularDamping属性angularDamping 是指减少自身旋转的速度。 1234// sprite.physicsBody = SKPhysicsBody(texture: sprite.texture!, size: sprite.size)// sprite.physicsBody?.angularVelocity = 5sprite.physicsBody?.angularDamping = 2 节点的physicsBody?linearDamping属性linearDampin 是指减少linear上的移动速度。 1234// sprite.physicsBody = SKPhysicsBody(texture: sprite.texture!, size: sprite.size)// sprite.physicsBody?.velocity = CGVector(dx: -500, dy: 0)sprite.physicsBody?.linearDamping = 0 SKScene的physicsWorld属性SKScene的physicsWorld.gravity–重力属性其实感觉不能叫重力属性,因为你可以设置成各个方向都有引力。self.physicsWorld.gravity是CGVector数据类型。 1self.physicsWorld.gravity = CGVector(dx: 0.0, dy: -3.0) 以上代码,代表x方向没有正引力也没有负引力,y方向有3个负引力。 SKScene的physicsWorld.contactDelegate 代理物理世界的碰撞检测代理一般都设置为场景自己: 1self.physicsWorld.contactDelegate = self 此时场景需要遵循 SKPhysicsContactDelegate 的代理协议。 SKActionSKAction.rotate先加载一个图形: 1var slotGlow: SKSpriteNode = SKSpriteNode(imageNamed: &quot;slotGlowGood&quot;) 是这个样子的: 我们要让它沿着中心点始终在转: 123456789// 如何运动:// 1.旋转 -- rotate// 2.角度一个pi,即180度// 3.时间为10秒,就是旋转的快慢let spin = SKAction.rotate(byAngle: .pi, duration: 10)// 始终在旋转不停止let spinForever = SKAction.repeatForever(spin)// 让这个slotGlow运行这个运动模式slotGlow.run(spinForever) SKAction.moveBy(x:y:duration:)移动位置及持续时间。 123// charNode = SKSpriteNode(imageNamed: &quot;penguinGood&quot;)// charNode已可在主画面显示charNode.run(SKAction.moveBy(x: 0, y: 80, duration: 0.05)) SKAction.wait(forDuration:)等待。以秒计算。 1let delay = SKAction.wait(forDuration: 0.25) SKAction.animate(with: &lt;#T##[SKTexture]#&gt;, timePerFrame: &lt;#T##TimeInterval#&gt;)比如做一个小鸟飞翔的动画,可以拿到的小鸟的照片分别是bird-01&#x2F;bird-02&#x2F;bird-03,图像分别是:代码是: 1234567891011// bird = SKSpriteNode(imageNamed: &quot;bird-01&quot;)let birdTexture1 = SKTexture(imageNamed: &quot;bird-01&quot;)birdTexture1.filteringMode = .nearestlet birdTexture2 = SKTexture(imageNamed: &quot;bird-02&quot;)birdTexture2.filteringMode = .nearestlet birdTexture3 = SKTexture(imageNamed: &quot;bird-03&quot;)birdTexture3.filteringMode = .nearestlet anim = SKAction.animate(with: [birdTexture1,birdTexture2,birdTexture3], timePerFrame: 0.2)bird.run(SKAction.repeatForever(anim), withKey: &quot;fly&quot;) SKAction.run(block:)SKAction.run(block:) will run any code we want, provided as a closure. “Block” is Objective-C’s name for a Swift closure. 1let notVisible = SKAction.run &#123; [unowned self] in self.isVisible = false &#125; 为何要用SKAction.run来执行这段代码,而不是直接去执行呢?感觉是因为类似下面的SKAction.sequence()需要依序执行action和改变一些属性的情况。 SKSpriteNode.run(&lt;#T##action: SKAction##SKAction#&gt;, withKey: &lt;#T##String#&gt;)这里出现一个withKey参数,可以这么设置: 1bird.run(SKAction.repeatForever(anim), withKey: &quot;fly&quot;) 如果要停止这个动画,就可以使用到: 1bird.removeAction(forKey: &quot;fly&quot;) 还有一个让SKLabelNode显示的文字瞬间变大又还原的案例: 1scoreLabelNode.run(SKAction.sequence([SKAction.scale(to: 1.5, duration: TimeInterval(0.1)), SKAction.scale(to: 1.0, duration: TimeInterval(0.1))])) SKSpriteNode.removeAction(forKey: &lt;#T##String#&gt;)紧接着上面的例子,用法是: 1bird.removeAction(forKey: &quot;fly&quot;) SKAction.sequence()SKAction.sequence() takes an array of actions, and executes them in order. Each action won’t start executing until the previous one finished. 12345678func hit() &#123; isHit = true let delay = SKAction.wait(forDuration: 0.25) let hide = SKAction.moveBy(x: 0, y: -80, duration: 0.5) let notVisible = SKAction.run &#123; [unowned self] in self.isVisible = false &#125; charNode.run(SKAction.sequence([delay, hide, notVisible]))&#125; SKAction.group()An action group specifies that all actions inside it should execute simultaneously.这里要注意的一点是,SKAction.group()内的SKAction,是同时执行的,所以我们平时可以配合SKAction.sequence()一起使用,但要注意两者的明显不同之处。 123456let scaleOut = SKAction.scale(to: 0.001, duration: 0.2)let fadeOut = SKAction.fadeOut(withDuration: 0.2)let group = SKAction.group([scaleOut, fadeOut])let seq = SKAction.sequence([group, .removeFromParent()])node.run(seq) 背景闪电的案例使用到 SKAction.sequence() &#x2F; SKAction.run &#x2F; SKAction.wait &#x2F; SKScene.run效果图: 1234567891011121314151617// var skyColor = SKColor(red: 81.0/255.0, green: 192.0/255.0, blue: 201.0/255.0, alpha: 1.0)// self.backgroundColor = skyColor// 当系统检测到特定碰撞时,即调用该bgFlash方法:func bgFlash() &#123; let bgFlash = SKAction.run (&#123; self.backgroundColor = SKColor(red: 1, green: 0, blue: 0, alpha: 1.0) &#125;) let bgNormal = SKAction.run (&#123; self.backgroundColor = self.skyColor &#125;) let bgFlashAndNormal = SKAction.sequence([bgFlash, SKAction.wait(forDuration: TimeInterval(0.05)), bgNormal, SKAction.wait(forDuration: TimeInterval(0.05))]) self.run(SKAction.sequence([SKAction.repeat(bgFlashAndNormal, count: 4)]), withKey: &quot;flash&quot;) // 加了下面这行代码就没了效果,感觉是异步的原因, // 上一行代码还没执行完,下一行就开始执行了,所以无效了。 // self.removeAction(forKey: &quot;flash&quot;)&#125; “Game Over” 字样从天而降 的案例使用到SKScene的默认Bool属性isUserInteractionEnabled,值为true。 以下例子是在游戏结束的瞬间:1、玩家不能点击屏幕;2、Game Over 字样从天而降;3、玩家此时才能点击屏幕得到响应。 12345678910111213141516//lazy var gameOverLabel: SKLabelNode = &#123;// let label = SKLabelNode(fontNamed: &quot;Chalkduster&quot;)// label.text = &quot;Game Over&quot;// return label//&#125;()// SKScene的默认属性isUserInteractionEnabled为true,此时用户是可以随便点击屏幕并有响应的isUserInteractionEnabled = falseaddChild(gameOverLabel)gameOverLabel.position = CGPoint(x: self.size.width * 0.5, y: self.size.height)let delay = SKAction.wait(forDuration: TimeInterval(1))let move = SKAction.move(by: CGVector(dx: 0, dy: -self.size.height * 0.5), duration: 1)gameOverLabel.run(SKAction.sequence([delay, move]), completion: &#123; self.isUserInteractionEnabled = true&#125;) SKAction.playSoundFileNamed()SKAction.playSoundFileNamed()是在SKAction中用来播放声音的。 The three main sound file formats you’ll use are MP3, M4A and CAF, with the latter being a renamed AIFF file. AIFF is a pretty terrible file format when it comes to file size, but it’s much faster to load and use than MP3s and M4As, so you’ll use them often. 1run(SKAction.playSoundFileNamed(&quot;whackBad.caf&quot;, waitForCompletion: false)) 这里是直接run,其实是因为func是在GameScene中,所以可以直接用run。而若你是在其他SKNode中,个人认为是可以使用SKNode.run()的。注意:这里的run不同于SKAction.run(block:) SKaction.follow(&lt;#T##CGPath#&gt;, asOffset: &lt;#T##Bool#&gt;, orientToPath: &lt;#T##Bool#&gt;, speed: &lt;#T##CGFloat#&gt;)意思是action是跟随者着CGPath的路径进行。 1234567let path = UIBezierPath()path.move(to: .zero)path.addLine(to: CGPoint(x: xMovement, y: 1000))// orientToPath 的意思是跟着路径一起旋转角度。let move = SKAction.follow(path.cgPath, asOffset: true, orientToPath: true, speed: 200)node.run(move) 给这个node设置了一个SKAction,这个SKAction是跟随这贝塞尔曲线(但上面确实直线,应该是跟上面的path有关系)运动。 The follow() method takes three other parameters, all of which are useful. The first decides whether the path coordinates are absolute or are relative to the node’s current position. If you specify asOffset as true, it means any coordinates in your path are adjusted to take into account the node’s position.The third parameter to follow() is orientToPath and makes a complicated task into an easy one. When it’s set to true, the node will automatically rotate itself as it moves on the path so that it’s always facing down the path. Perfect for fireworks, and indeed most things! Finally, you can specify a speed to adjust how fast it moves along the path. SKPhysicsContactDelegateSKPhysicsContactDelegate协议 就类似于针对物理碰撞的处理器,所以一般都是符合SKScene协议的class(比如例子里就是GameScene) 需要另外去遵循的: 1class GameScene: SKScene, SKPhysicsContactDelegate &#123; 此外,在didMove(to:)中我们需要添加的: 123456789override func didMove(to view: SKView) &#123; // 之前这行代码,就是让整个屏幕作为一个物理属性范围 physicsBody = SKPhysicsBody(edgeLoopFrom: frame) // 让这整理屏幕作为一个物理属性范围,那么它的碰撞处理器是什么呢? // 是self,就是 class GameScene: SKScene, SKPhysicsContactDelegate &#123; // 这也是GameScene为什么要遵循SKPhysicsContactDelegate协议的原因 physicsWorld.contactDelegate = self contactTestBitMask &amp;&amp; collisionBitMaskThe collisionBitMask bitmask means “which nodes should I bump into?” By default, it’s set to everything, which is why our ball are already hitting each other and the bouncers. The contactTestBitMask bitmask means “which collisions do you want to know about?” and by default it’s set to nothing. So by setting contactTestBitMask to the value of collisionBitMask we’re saying, “tell me about every collision.” 所以下面的代码: 1ball.physicsBody!.contactTestBitMask = ball.physicsBody!.collisionBitMask ball.physicsBody!.collisionBitMask代表 球 的所有碰撞情况,前半句ball.physicsBody!.contactTestBitMask的意思是,哪些是需要进行上报的碰撞。整个连起来就是,每个球的所有碰撞都得上报碰撞事件。 下面是一个完整的关于多个物体碰撞的例子: 12345// 设置物理体的标示符 &lt;&lt;左移运算符 左移一位，相当于扩大2倍let birdCategory: UInt32 = 1 &lt;&lt; 0 //1 二进制表示是1let worldCategory: UInt32 = 1 &lt;&lt; 1 //2 二进制表示是10let pipeCategory: UInt32 = 1 &lt;&lt; 2 //4 二进制表示是100let scoreCategory: UInt32 = 1 &lt;&lt; 3 //8 二进制表示是1000 给每个物理体设置physicsBody?.categoryBitMask的标识符: 12345678// 给地面添加一个识别ground.physicsBody?.categoryBitMask = worldCategory// 给鸟添加一个识别bird.physicsBody?.categoryBitMask = birdCategory// 给管道添加一个识别pipe.physicsBody?.categoryBitMask = pipeCategory// 给得分墙添加一个识别contactNode.physicsBody?.categoryBitMask = scoreCategory 给所有对于鸟可能发生的碰撞进行定义: 1234bird.physicsBody?.collisionBitMask = worldCategory | pipeCategory | scoreCategory // 或运算,答案是14, 二进制表示是1110// 上面这行代码可以不写的,因为你不定义collisionBitMask的话,collisionBitMask就代表所有会发生的碰撞。// 但这样把所有可能发生的碰撞全写上,毕竟是笔记,尽量要全一点 给所有对于鸟来说需要上报通知的碰撞进行定义: 1234bird.physicsBody?.contactTestBitMask = worldCategory | pipeCategory | scoreCategory// 把以上三种会碰到的碰撞规定需要上报// 这三种碰撞是所有可能的碰撞,所以代码也可以这样写:// bird.physicsBody?.contactTestBitMask = bird.physicsBody?.collisionBitMask 以上是对鸟可能发生的碰撞以及需要上报通知的定义,你完全可以去定义 地面&#x2F;管道&#x2F;得分墙 的可能发生的碰撞以及需要上报通知的情况,毕竟这里代码参考的文章中就是这么写的。 https://www.jianshu.com/p/bc22ee0f87b4但觉得没必要,你只要定义鸟的collisionBitMask和contactTestBitMask部分就可以了,如果遇到更复杂的情况,倒是可以对类似 地面&#x2F;管道&#x2F;得分墙 进行细节上的再定义。 所以当碰撞发生的时候就可以去判断: 12345678910111213141516func didBegin(_ contact: SKPhysicsContact) &#123; // 当上报的是scoreCategory,就知道是和得分墙的碰撞,这是就要进行加分等操作了 if contact.bodyA.categoryBitMask == scoreCategory || contact.bodyB.categoryBitMask == scoreCategory &#123; score += 1 scoreLabelNode.text = String(score) scoreLabelNode.run(SKAction.sequence([SKAction.scale(to: 1.5, duration: TimeInterval(0.1)), SKAction.scale(to: 1.0, duration: TimeInterval(0.1))])) &#125; else &#123; // 当不是与得分墙的碰撞的话,就是鸟与管道或者地面的相撞了 // collisionBitMask 设置成 worldCategory,是防止与管道再次发生相撞,让其直接掉到地上, // 若设置为0,因为标识符没有0的,就会发生一种情况, // 那就是小鸟直接往下掉,掉出屏幕！ bird.physicsBody?.collisionBitMask = worldCategory overStatus() bgFlash() &#125;&#125; 但是,这样设置还是出现了问题,问题就是,当鸟撞上了得分墙了以后,它就被堵在了那里不能动了,所以鸟的collisionBitMask和contactTestBitMask都要去除scoreCategory: 12bird.physicsBody?.collisionBitMask = worldCategory | pipeCategorybird.physicsBody?.contactTestBitMask = worldCategory | pipeCategory 但是去除后,就不会有和得分墙的碰撞,也就无法产生得分了。这时候就要在得分墙上动脑筋了: 1contactNode.physicsBody?.contactTestBitMask = birdCategory 对于鸟的碰撞,contactNode需要去通知汇报碰撞情况,而此时因为鸟是被动一方,所以继续畅通无阻地通过这堵得分墙。 对于这个问题,总结一点,就是鸟设置的碰撞排除掉空气墙,而空气墙设置的碰撞要针对鸟,这样就行了。 func didBegin(_ contact: SKPhysicsContact) {这是SKPhysicsContactDelegate默认会有的一个方法。如果发生碰撞并上报事件了,就会调用该方法: 12345678910111213141516171819202122232425262728293031323334353637// 之前要给需要的SKSpriteNode节点取名字,比如// slotBase.name = &quot;good&quot;// slotBase.name = &quot;bad&quot;// ball.name = &quot;ball&quot;// 这里多说一句,可以给节点取名字,也可以给节点的physicsBody?.categoryBitMask添加值,这样更好,// 具体见 physicsBody?.categoryBitMask的讲解。func didBegin(_ contact: SKPhysicsContact) &#123; if contact.bodyA.node?.name == &quot;ball&quot; &#123; collisionBetween(ball: contact.bodyA.node!, object: contact.bodyB.node!) &#125; else if contact.bodyB.node?.name == &quot;ball&quot; &#123; collisionBetween(ball: contact.bodyB.node!, object: contact.bodyA.node!) &#125;&#125;func collisionBetween(ball: SKNode, object: SKNode) &#123; if object.name == &quot;good&quot; &#123; destroy(ball: ball) score += 1 &#125; else if object.name == &quot;bad&quot; &#123; destroy(ball: ball) score -= 1 &#125;&#125;func destroy(ball: SKNode) &#123; print(&quot;here&quot;) if let fireParticles = SKEmitterNode(fileNamed: &quot;FireParticles&quot;) &#123; fireParticles.position = ball.position addChild(fireParticles) &#125; let a = SKEmitterNode(fileNamed: &quot;FireParticles&quot;) // SKSpriteNode节点的移除一定要从Parent处移除 ball.removeFromParent()&#125; SKLabelNodeThe SKLabelNode class is somewhat similar to UILabel in that it has a text property, a font, a position, an alignment, and so on. 1234567// 创建一个SKLabelNode,字体使用&quot;粉笔灰&quot;scoreLabel = SKLabelNode(fontNamed: &quot;Chalkduster&quot;)// SKLabelNode的内容scoreLabel.text = &quot;Score: 0&quot;scoreLabel.horizontalAlignmentMode = .rightscoreLabel.position = CGPoint(x: 980, y: 700)addChild(scoreLabel) open func nodes(at p: CGPoint) -&gt; [SKNode]这方法是SKNode协议下的一个内置方法,作用是反馈在这个location的所有SKNode节点 1234567891011override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; if let touch = touches.first &#123; let location = touch.location(in: self) let objects = nodes(at: location) if objects.contains(editLabel) &#123; &#125; else &#123; &#125; 12345678910override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; guard let touch = touches.first else &#123; return &#125; var location = touch.location(in: self) for node in nodes(at: location) &#123; if node.name == &quot;player&quot; &#123; &#125; &#125;&#125; SKEmitterNode https://www.hackingwithswift.com/read/11/7/special-effects-skemitternode SpriteKit has a built-in particle editor to help you create effects like fire, snow, rain and smoke almost entirely through a graphical editor. The SKEmitterNode class is new and powerful: it’s designed to create high-performance particle effects in SpriteKit games, and all you need to do is provide it with the filename of the particles you designed and it will do the rest. SKEmitterNode(fileNamed:)的用例123456789func destroy(ball: SKNode) &#123; // 加载FireParticles.sks文件 if let fireParticles = SKEmitterNode(fileNamed: &quot;FireParticles&quot;) &#123; fireParticles.position = ball.position addChild(fireParticles) &#125; ball.removeFromParent()&#125; 就会有在ball被清除前,先出现一个爆炸的动画。在xCode中你可以点击该FireParticles.sks文件,就可以看见右侧面板上有标题叫”SpriteKit Particle Emitter”,可以在里面更改动画效果等。 SKEmitterNode的advanceSimulationTime(sec: TimeInterval)让SKEmitterNode提前多少秒渲染。 用例: 12starField = SKEmitterNode(fileNamed: &quot;starfield&quot;)!starField.position = CGPoint(x: 1024, y: 384) 效果是这样的:你会发现星空是从右边屏幕开始慢慢渲染的,但我们需要星空一开始就充满屏幕,这时候就需要用到SKEmitterNode的advanceSimulationTime(sec: TimeInterval)。 12// 提前渲染10秒的星空starField.advanceSimulationTime(10) 效果是这样的: .sks文件的制作还没涉及到.sks文件的制作,上例中,文件制作完预览是这样的: 文章中提了一笔如何创建该sks文件:Add a new file, but this time choose “Resource” under the iOS heading, then choose “SpriteKit Particle File” to see the list of options. 后续需要研究下怎么制作………………………. SKNodeSKNode doesn’t draw images like sprites or hold text like labels; it just sits in our scene at a position, holding other nodes as children.SKSpriteNode, SKLabelNode and SKEmitterNode, and they all come from SKNode. 1234567891011121314151617class WhackSlot: SKNode &#123; // 这里没有写init()方法,但可以有 // configure方法是自己写的,并不是本身固有的方法 func configure(at position: CGPoint) &#123; // 确定SKNode在什么位置 self.position = position // 确定这个SKNode显示什么图片 let sprite = SKSpriteNode(imageNamed: &quot;whackHole&quot;) addChild(sprite) // 还可以加入SKCropNode让这里有个遮罩之类 // 再给SKCropNode加入一个SKSpriteNode(imageNamed:)之类的 // 再实现其的动画效果 // 具体实现见https://www.hackingwithswift.com/read/14/2/getting-up-and-running-skcropnode &#125;&#125; SKNode.removeAllChildren()移除SKNode中的所有子节点。 123// var pipes: SKNode!pipes.removeAllChildren() SKNode.children – 获取所有节点children可以获取到所有的节点,它的定义是: [SKNode]。下面是获取到所有节点,并始终刷新,判断节点的x坐标在屏幕左侧-300的位置时,即将其删除的例子: 1234567override func update(_ currentTime: TimeInterval) &#123; for node in children &#123; if node.position.x &lt; -300 &#123; node.removeFromParent() &#125; &#125;&#125; isUserInteractionEnabled 属性 – 是否让用户点击交互一个SKNode,如果只是做背景之类不需要用户点击进行交互的话,就可以: 123// skNode: SKNodeskNode.isUserInteractionEnabled = false SKCropNodeSKCropNode is a special kind of SKNode subclass that uses an image as a cropping mask: anything in the colored part will be visible, anything in the transparent part will be invisible.SKCropNode是SKNode的子类。SKCropNode.maskNode得是个SKSpriteNode。SKCropNode.maskNode的作用就是:在SKCropNode.maskNode范围内,这是前提,SKCropNode这个node中的texture(素材),必须是要出现在maskNode范围内的才会显示。 示例: 123456789101112131415161718192021222324class WhackSlot: SKNode &#123; func configure(at position: CGPoint) &#123; self.position = position let sprite = SKSpriteNode(imageNamed: &quot;whackHole&quot;) addChild(sprite) let cropNode = SKCropNode() cropNode.position = CGPoint(x: 0, y: 15) // 把cropNode放在其他node之上 cropNode.zPosition = 1 // 若设置成cropNode.maskNode = nil 则charNode就会显示出来 cropNode.maskNode = SKSpriteNode(imageNamed: &quot;whackMask&quot;) charNode = SKSpriteNode(imageNamed: &quot;penguinGood&quot;) charNode.position = CGPoint(x: 0, y: -90) charNode.name = &quot;character&quot; cropNode.addChild(charNode) addChild(cropNode) &#125;&#125; 解释下代码:cropNode的位置在(0,15), cropNode.maskNode 是一张图片,可以理解成是cropNode的背景图,但实施其是一个人mask,在mask内的显示,不在的不显示。charNode的位置在(0,-90),它在 cropNode.maskNode 的下面,所以不显示这个charNode。后续会有代码让charNode往上升,就能看到了,不过这是后话。 I hope you noticed the important thing, which is that the character node is added to the crop node, and the crop node was added to the slot. This is because the crop node only crops nodes that are inside it, so we need to have a clear hierarchy: the slot has the hole and crop node as children, and the crop node has the character node as a child. AnchorPoint在SpriteKit的游戏开发中经常会使用到AnchorPoint锚点这一属性,这需要配合position属性一起使用。在SpriteKit中(0,0)这个点是在左下角,但UIKit中是左上角。锚点的类型是CGPoint类型数据,取值范围是(0,0)~(1,1)之间,如下图:。 我们以(0,0)为左上角来讲解:View的position为(50,50):1、 若AnchorPoint为(0.5,0.5), 就说明锚点取的是View的中心点, 则View的中心点位置是(50,50), 如下图:2、若AnchorPoint为(0,0),就说明锚点取的是View的左上角,则View的左上角位置是(50,50),如下图:3、若AnchorPoint为(1,1),就说明锚点取的是View的右下角,则View的右下角位置是(50,50),如下图: UIViewController 与 GameScene 的关系默认建立game后,会有GameScene.swift和GameViewController.swift这两个文件,要解释一下的是,GameViewController.swift中的UIViewController,掌管着GameScene.swift中的GameScene。 UIViewController的默认方法override func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?) { } 检测设备的 晃动&#x2F;shake&#x2F;摇晃 效果motionBegan()只能在view controller中设置,而不能在game scenes中设置。下面是在GameViewController.swift的UIViewController中建立一个方法,来调用GameScene.swift中的explodeFireworks方法: 12345678910111213class GameViewController: UIViewController &#123; // 省略必须的代码 override func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; // 感觉这行代码是检测主体的view是否是一个SKView guard let skView = view as? SKView else &#123; return &#125; // 感觉这行代码是检测SKView的scene是否是GameScene guard let gameScene = skView.scene as? GameScene else &#123; return &#125; // 如果上面检测都成立,就运行GameScene.swift文件中的GameScene类中的explodeFireworks方法。 gameScene.explodeFireworks() &#125;&#125; 注:在模拟器中使用”ctrl”+”cmd”+”z”来模拟设备的晃动效果。 NSCoding https://www.hackingwithswift.com/read/12/3/fixing-project-10-nscoding 一般都推荐使用Codable了,所以这里就不写关于NSCoding的笔记了。 UISlider如何取得滑动值123456// 在storyboard上建立一个slider@IBOutlet var intensity: UISlider!// 如何取得UISlider的滑动数值// 使用intensity.value即可intensity.value 如何跟踪滑动值的改变12345// 在storyboard上建立对应该Slider的action事件// 每次滑动Slider都会触发该方法@IBAction func intensityChanged(_ sender: Any) &#123;&#125; CoreImageCore Image is Apple’s high-speed image manipulation tookit. It does only one thing, which is to apply filters to images that manipulate them in various ways. 需要import1import CoreImage CIContextThe first is a Core Image context, which is the Core Image component that handles rendering. We create it here and use it throughout our app, because creating a context is computationally expensive so we don’t want to keep doing it and it’s best to re-use them where possible. 1234var context: CIContext!// viewDidLoad()context = CIContext() 具体的例子见下面的CIFilter的讲解。 CIFilter https://www.hackingwithswift.com/read/13/4/applying-filters-cicontext-cifilter(以上有多种filter的选择,对应值的转换,以及项目实际模拟出来的各种效果,如果需要的时候可以看一下)(也可以在用户导入照片的时候,提供必要的filter让其修改下照片效果等) The second is a Core Image filter, and will store whatever filter the user has activated. This filter will be given various input settings before we ask it to output a result for us to show in the image view. 1234567891011121314151617181920212223242526272829var currentFilter: CIFilter!// viewDidLoad()context = CIContext()// creates an example filter that will apply a sepia tone effect to images.currentFilter = CIFilter(name: &quot;CISepiaTone&quot;)// The CIImage data type is UIImage.let beginImage = CIImage(image: currentImage)// we send the result into the current Core Image Filter using the kCIInputImageKey. There are lots of Core Image key constants like this; at least this one is somewhat self-explanatory!currentFilter.setValue(beginImage, forKey: kCIInputImageKey)// The first line safely reads the output image from our current filter. guard let image = currentFilter.outputImage else &#123; return &#125;// The second line uses the value of our intensity slider to set the kCIInputIntensityKey value of our current Core Image filter. For sepia toning a value of 0 means &quot;no effect&quot; and 1 means &quot;fully sepia.&quot;// var intensity: UISlider!currentFilter.setValue(intensity.value, forKey: kCIInputIntensityKey)// 下面的 if 语句中的代码,我们也可以总结出:// 要想从CIImage -&gt; UIImage, 必须是:// CIImage -&gt; CGImage -&gt; UIImage.// -----------------------------------// it creates a new data type called CGImage from the output image of the current filter.if let cgimg = context.createCGImage(image, from: image.extent) &#123; // 转换成UIImageView需要的UIImage let processedImage = UIImage(cgImage: cgimg) // 放入UIImageView imageView.image = processedImage&#125; UIImageWriteToSavedPhotosAlbum()向用户的相册写入图片。 12345678910111213141516171819// 假设有一个UIButton的action是下面的func@IBAction func save(_ sender: Any) &#123; guard let image = imageView.image else &#123; return &#125; UIImageWriteToSavedPhotosAlbum(image, self, #selector(image(_:didFinishSavingWithError:contextInfo:)), nil)&#125;@objc func image(_ image: UIImage, didFinishSavingWithError error: Error?, contextInfo: UnsafeRawPointer) &#123; if let error = error &#123; // we got back an error! let ac = UIAlertController(title: &quot;Save error&quot;, message: error.localizedDescription, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) present(ac, animated: true) &#125; else &#123; let ac = UIAlertController(title: &quot;Saved!&quot;, message: &quot;Your altered image has been saved to your photos.&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) present(ac, animated: true) &#125;&#125; UIView.animate一般用法: 1UIView.animate(withDuration: &lt;#T##TimeInterval#&gt;, delay: &lt;#T##TimeInterval#&gt;, animations: &lt;#T##() -&gt; Void#&gt;) 更丝滑的用法:(使用到了usingSpringWithDamping &#x2F; initialSpringVelocity,是为了增加润滑度的) 1UIView.animate(withDuration: &lt;#T##TimeInterval#&gt;, delay: &lt;#T##TimeInterval#&gt;, usingSpringWithDamping: &lt;#T##CGFloat#&gt;, initialSpringVelocity: &lt;#T##CGFloat#&gt;, animations: &lt;#T##() -&gt; Void#&gt;) 案例: 123456789101112UIView.animate(withDuration: 1, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 5, options: [], animations: &#123; self.imageView.alpha = 0.1 self.imageView.backgroundColor = UIColor.green // 后续可以设置案件让其还原 // 比如 // self.imageView.alpha = 1.0 // self.imageView.backgroundColor = UIColor.clear // 这里补充一点 UIColor.clear 的定义 // open class var clear: UIColor &#123; get &#125; // 0.0 white, 0.0 alpha // 所以上面代码会让背景色变白并且透明度为0即不可见&#125; UIView.animate 的 completed 的trailing closure参数下面的代码可以在animate的动画结束之后再执行一段代码。 1234567891011UIView.animate(withDuration: 1, delay: 0, options: [], animations: &#123; switch self.currentAnimation &#123; case 0: break default: break &#125;&#125;) &#123; finished in sender.isHidden = false&#125; UIView.animate 的思考上面代码中,在UIView.animate中变化的是self.imageView.alpha。同样的情景,但换做是一个UIButton,”_ sender: UIButton”是其传来的参数,你使用sender.isHidden &#x3D; true, 是不会有过渡变化的,而你使用sender.alpha &#x3D; 0,就会带来过渡的变化。后者很好理解,因为alpha的取值是从0-1.0之前,但为什么sender.isHidden从false到true,也是让图像从有到无,为何就没有用呢? (还记得在SwfitUI中,withAnimation中好像是可以放入true或false的改变的,也会有动画效果的)教程中是这么讲的,”because isHidden is either true or false, it has no animatable values between.”上面代码还用到了backgroundColor,是不是颜色从一种到另一种,其中是带有值的过渡的,所以也是可行的。 使用需要是weak等去除强引用？没必要！For the animations closure we don’t need to use [weak self] because there’s no risk of strong reference cycles here – the closures passed to animate(withDuration:) method will be used once then thrown away. CGAffineTransform任何的UIView都可以使用CGAffineTransform。 一般用法案例: 123456789101112UIView.animate(withDuration: 1, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 5, options: [], animations: &#123; switch self.currentAnimation &#123; case 0: self.imageView.transform = CGAffineTransform(scaleX: 2, y: 2) case 1: self.imageView.transform = .identity default: break &#125;&#125; 这里有两个知识点: UIView.transform 可更改外形、大小、角度等; UIView.transform &#x3D; .identity 即可恢复原状。 CGAffineTransform还有的用法: 123456// 位移self.imageView.transform = CGAffineTransform(translationX: -256, y: -256)// 旋转self.imageView.transform = CGAffineTransform(rotationAngle: CGFloat.pi * 3.0 / 2.0)// 但要记住,它比较懒,怎么能最快到终点,就会选这个捷径,实际这个只逆时针转了90度 CGAffineTransform.identityCGAffineTransform也有identity,作用是恢复到transform之前的状态。 MapKitMKMapView及其的delegate在一个UIView中建立了一个MKMapView后,需要让UIView作为这个MKMapView的delegate的话,需要在storyboard中ctrl-drag这个MKMapView到UIView上面,就会出现让你选择delegate的情况,选择好了以后就可以了。 原文是这样写的:Using the assistant editor, please create an outlet for your map view called mapView. You should also set your view controller to be the delegate of the map view by Ctrl-dragging from the map view to the orange and white view controller button just above the layout area. You will also need to add import MapKit to ViewController.swift so it understands what MKMapView is.Note: If you don’t set the map’s delegate, the rest of this project won’t work too well. MKMapView的用例:在storyboard上生成一个map kit view。 mapType 更改显示地图的样式1234// @IBOutlet var mapView: MKMapView!// 显示卫星地图,还有其他的一些选择mapView.mapType = .satellite MKAnnotation – protocol在地图上显示图钉。遵循MKAnnotation协议的必须是class,不能是struct！！！遵循MKAnnotation协议的情况下,必须要有一个coordinate: CLLocationCoordinate2D的声明,如下: 123456789101112class Capital: NSObject, MKAnnotation &#123; var title: String? // 需要实现一个CLLocationCoordinate2D var coordinate: CLLocationCoordinate2D var info: String init(title: String, coordinate: CLLocationCoordinate2D, info: String) &#123; self.title = title self.coordinate = coordinate self.info = info &#125;&#125; 在viewDidLoad()中可以生成这个annotation: 12let london = Capital(title: &quot;London&quot;, coordinate: CLLocationCoordinate2D(latitude: 51.507222, longitude: -0.1275), info: &quot;Home to the 2012 Summer Olympics.&quot;)let oslo = Capital(title: &quot;Oslo&quot;, coordinate: CLLocationCoordinate2D(latitude: 59.95, longitude: 10.75), info: &quot;Founded over a thousand years ago.&quot;) 随后在地图上显示这些annotation: 12345678910// @IBOutlet var mapView: MKMapView!// 一起添加:// mapView.addAnnotations(&lt;#T##annotations: [MKAnnotation]##[MKAnnotation]#&gt;)mapView.addAnnotations([london, oslo])// 或者一个一个添加:// mapView.addAnnotation(&lt;#T##annotation: MKAnnotation##MKAnnotation#&gt;)mapView.addAnnotation(london)mapView.addAnnotation(oslo) func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? { https://www.hackingwithswift.com/read/16/3/annotations-and-accessory-views-mkpinannotationview Every time the map needs to show an annotation, it calls a viewFor method on its delegate. We don’t implement that method right now, so the default red pin is used with nothing special. 但首先要让View遵循 MKPinAnnotationView protocol : 1class ViewController: UIViewController, MKMapViewDelegate &#123; 接下来就是完成func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? { 1234567891011121314151617181920212223242526func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? &#123; // 1.If the annotation isn&#x27;t from a capital city, it must return nil so iOS uses a default view. guard annotation is Capital else &#123; return nil &#125; // 2.Define a reuse identifier. This is a string that will be used to ensure we reuse annotation views as much as possible. let identifier = &quot;Capital&quot; // 3.Try to dequeue an annotation view from the map view&#x27;s pool of unused views. var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: identifier) if annotationView == nil &#123; // 4.If it isn&#x27;t able to find a reusable view, create a new one using (MKPinAnnotationView is deprecated) and sets its canShowCallout property to true. This triggers the popup with the city name. annotationView = MKMarkerAnnotationView(annotation: annotation, reuseIdentifier: identifier) annotationView?.canShowCallout = true // 5. Create a new UIButton using the built-in .detailDisclosure type. This is a small blue &quot;i&quot; symbol with a circle around it. // we don&#x27;t need to use addTarget() to add an action to the button, because you&#x27;ll automatically be told by the map view using a calloutAccessoryControlTapped method. let btn = UIButton(type: .detailDisclosure) annotationView?.rightCalloutAccessoryView = btn &#125; else &#123; // 6. If it can reuse a view, update that view to use a different annotation. annotationView?.annotation = annotation &#125; return annotationView&#125; 接下来就是每个annotation被点击后实现方法了: 12345678910// calloutAccessoryControlTapped method can make the tapped button know to call it.func mapView(_ mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) &#123; guard let capital = view.annotation as? Capital else &#123; return &#125; let placeName = capital.title let placeInfo = capital.info let ac = UIAlertController(title: placeName, message: placeInfo, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) present(ac, animated: true)&#125; 实现效果是这样的: TimerTimer.scheduledTimer(timeInterval: &lt;#T##TimeInterval#&gt;, target: &lt;#T##Any#&gt;, selector: &lt;#T##Selector#&gt;, userInfo: &lt;#T##Any?#&gt;, repeats: &lt;#T##Bool#&gt;)多少个时间单位内(timeInterval), 执行什么代码(selector), 是否重复执行(repeats)。After creating a Timer, it should be created using Timer.scheduledTimer() method to activate it. 1Timer.scheduledTimer(timeInterval: 0.35, target: self, selector: #selector(createEnemy), userInfo: nil, repeats: true) invalidate() – Timer.scheduledTimer的停止让一个计时器停止: 123456// var gameTimer: Timer?// gameTimer = Timer.scheduledTimer(timeInterval: 0.35, target: self, selector: #selector(createEnemy), userInfo: nil, repeats: true)gameTimer?.invalidate()gameTimer = nil debugprint12345678910print(&quot;I&#x27;m inside the viewDidLoad() method!&quot;)print(1, 2, 3, 4, 5)// &quot;1 2 3 4 5\\n&quot;print(1, 2, 3, 4, 5, separator: &quot;-&quot;)// &quot;1-2-3-4-5\\n&quot;print(&quot;Some message&quot;, terminator: &quot;&quot;)// &quot;Some message&quot; assert一般用法两个参数,前面的条件不满足或是false,则显示预设的错误信息,并让测试时的程序崩溃。 1assert(1 == 1, &quot;Maths failure!&quot;) breakpoints Fn+F6 – 到breakpoint处时,一行一行地执行 Ctrl+Cmd+Y – 执行到下一个breakpoint 给Breakpoint加上条件例如在循环中每十次进行一次breakpoint:对着设定的breakpoint右键,跳出菜单中选择”edit breakpoint”,再跳出的菜单:在Condition中输入”i % 10 &#x3D;&#x3D; 0”即可。 Exception BreakpointException Breakpoint will be automatically triggered when an exception is thrown. Exceptions are errors that aren’t handled, and will cause your code to crash. With breakpoints, you can say “pause execution as soon as an exception is thrown,” so that you can examine your program state and see what the problem is. Cmd+8 调出“Show the Breakpoint navigator”,左下角按”+”按钮,调出如下菜单,选择”Exception Breakpoint”:进行必要的设置:The next time your code hits a fatal problem, the exception breakpoint will trigger and you can take action. 下面的图就是当出现错误的情况时,会出现 NSException: lldb窗口LLDB is the default debugger in Xcode on macOS and supports debugging C, Objective-C and C++ on the desktop and iOS devices and simulator. 在运行project时,可以在菜单栏 View &gt; Debug Area &gt; Activate Console, 可以看到下面的lldb窗口: 命令行:p – 同print,比如要打印变量i,”p i”即可。 View Debugging在运行项目后,在代码页面, 菜单栏的 Debug -&gt; View Debugging -&gt; Capture View Hierarchy 。如下图: Here’s the clever part: if you click and drag inside the hierarchy display, you’ll see you’re actually viewing a 3D representation of your view, which means you can look behind the layers to see what else is there. The hierarchy automatically puts some depth between each of its views, so they appear to pop off the canvas as you rotate them. This debug mode is perfect for times when you know you’ve placed your view but for some reason can’t see it – often you’ll find the view is behind something else by accident. 还可以使用下图中打红圈的快捷键打开 View Debugging: CADisplayLink https://www.hackingwithswift.com/example-code/system/how-to-synchronize-code-to-drawing-using-cadisplaylinkhttps://www.jianshu.com/p/5e8d783d377a CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和 selector 在屏幕刷新的时候调用。CADisplayLink比NSTimer好的地方是,后者会有延迟,而CADisplayLink的好处是,我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。 123let displayLink = CADisplayLink(target: self, selector: #selector(createEnemy))displayLink.preferredFrameRateRange = CAFrameRateRange(minimum: 1, maximum: 2)displayLink.add(to: .current, forMode: .common) 代码在Project17上跑的通,但有些疑问,为什么CAFrameRateRange(minimum: 0.5, maximum: 0.5)的时候就会疯狂执行,而数值大于1以后,就会正常一些。 这个模块,以后要做动画游戏的时候需要好好研究一下。笔记待后续补充。 info.plistplist是property list的缩写,它包含了app、插件(extensions)的元数据(metadata),这些是关于:what language is it, what version number is it, and so on。 extensionsafari extensions https://www.hackingwithswift.com/100 Day67-69 p.s.(2023-1-28)这章节的内容实在是太乱了,新东西太多,后续还要再理一下,如果确实要写extension的话,最好结合上述网页上的实例再看。 safari extensions必须要在safari的action menu中才能启动,类似于:这个extension是植入到Safari中的,它需要safari才会有用,而不是像其他程序一样可以独立运行。 生成一个在原有项目下的extension:Go to the File menu and choose New &gt; Target. When you’re asked to choose a template, select iOS &gt; Application Extension &gt; Action Extension, then click Next. For the name just call it Extension(or other name whatever you want), make sure Action Type is set to “Presents User Interface”, then click Finish.这样就在一个project中建立了一个extension,而我们给其取名”Extension”,最后我们在sfari的action menu中可以看到一个Extension的可点击项,上面图像中可以看到。 safari中就可以运行extension,安全性在哪里？实际上,你的extension与safari是不会通信的,因为系统安全原因,而在这其中,iOS起到了一个中间桥梁的作用,iOS在其中安全地传递数据。 extensionContext:母程序(parent app)就比如说你在safari里做了一个插件,那么这个safari就是母程序,插件就是extension。当我们的插件被建立后,extensionContext是用来让我们控制与母程序交互的东西。 inputItems:extensionContext?.inputItems是一个存有数据的数组,该数据是母程序发送给插件使用的。我们一般只关心第一个item,所以会写成extensionContext?.inputItems.first。 NSItemProvider:母程序发送给我们的数据都被包装成了一个个NSItemProvider。我们的程序把所有的数组数据中的第一个取出,而这个被取出的数据应当是一个NSItemProvider。 1if let inputItem = extensionContext?.inputItems.first as? NSExtensionItem &#123; 接下来我们把inputItem中的所有attachments,只取出第一个attachment,代码就是： 1if let itemProvider = inputItem.attachments?.first &#123; 合起来的代码就是: 123456if let inputItem = extensionContext?.inputItems.first as? NSExtensionItem &#123; if let itemProvider = inputItem.attachments?.first &#123; &#125; &#125;&#125; loadItem(forTypeIdentifier: )loadItem(forTypeIdentifier: )是要求数据提供者真正地去提供这个item给我们。因为它使用到了一个trailing closure,所以执行的是异步程序，这个方法会持续执行,这是因为有时候这个item提供者可能忙于载入或者发送数据。在这个trailing closure中,我们需要使用到 [weak self]去避免强引用,此外,我们还需要接受两个参数,第一个是item提供者给我们的一个dictionary,另一个是发生的任何error。 123itemProvider.loadItem(forTypeIdentifier: kUTTypePropertyList as String) &#123;[weak self] (dict, error) in // do stuff!&#125; 先要说一下的是,在Action.js中的代码中有一段: 12345// run及其代码的意思是:// 告知iOS这个JavaScript已经预处理完毕,把这个dictionary(里面的key分别是&quot;URL&quot;和&quot;title&quot;以及对应的值)给extension吧run: function(parameters) &#123; parameters.completionFunction(&#123; &quot;URL&quot;: document.URL, &quot;title&quot;: document.title &#125;);&#125; loadItem的trailing closure接收到这个dictionary并进行处理,这也是其是异步方法的愿意。&#x2F;&#x2F; do stuff中的代码依次是: 1guard let itemDictionary = dict as? NSDictionary else &#123; return &#125; NSDictionary是一个对我们来说是新的数据类型,但它来自旧时代的iOS代码,就把它看作是一个Swift中的dictionary吧。现在更多使用的是modern Swift dictionaries,而非NSDictionary。但这里NSDictionary是与插件配合使用的。打印了一下上面的itemDictionary: 1guard let javaScriptValues = itemDictionary[NSExtensionJavaScriptPreprocessingResultsKey] as? NSDictionary else &#123; return &#125; 这行代码中的key为NSExtensionJavaScriptPreprocessingResultsKey,这是从JavaScript中传递过来的数据的key。 如果你打印上面javaScriptValues的值,你会看到类似: 1234&#123; URL = &quot;https://www.apple.com/retail/code/&quot;; title = &quot;Apple Retail Store - Hour of Code Workshop&quot;;&#125; 接下来就可以设置插件中的这两个后续我们要使用的属性了: 12self?.pageTitle = javaScriptValues[&quot;title&quot;] as? String ?? &quot;&quot;self?.pageURL = javaScriptValues[&quot;URL&quot;] as? String ?? &quot;&quot; 完成代码是: 123456789101112131415if let inputItem = extensionContext?.inputItems.first as? NSExtensionItem &#123; if let itemProvider = inputItem.attachments?.first &#123; itemProvider.loadItem(forTypeIdentifier: kUTTypePropertyList as String) &#123;[weak self] (dict, error) in guard let itemDictionary = dict as? NSDictionary else &#123; return &#125; guard let javaScriptValues = itemDictionary[NSExtensionJavaScriptPreprocessingResultsKey] as? NSDictionary else &#123; return &#125; self?.pageTitle = javaScriptValues[&quot;title&quot;] as? String ?? &quot;&quot; self?.pageURL = javaScriptValues[&quot;URL&quot;] as? String ?? &quot;&quot; DispatchQueue.main.async &#123; self?.title = self?.pageTitle &#125; &#125; &#125;&#125; &#x2F;&#x2F; do stuff中的代码是经过简单编写的,但建议自己去建立一个extension,看一下默认模版中是怎么遍历所有的items和providers,并最终找到第一张图片的。 info.plist内的设置:先看一下设置后的info.plist内部的构成:有一个Information Property List。因为我们这里是一个插件,所以该list里面有一个NSExtension。这个NSExtension里面一般有三样东西:NSExtensionAttributes, NSExtensionMainStoryboard and NSExtensionPointIdentifier.这里我们只关心会改变我们的插件行为的NSExtensionAttributes。我们设置的目的是:一是设置接收的是什么数据,二是设置后期要执行的语言类型及具体文件名。在NSExtensionAttributes下面有一个NSExtensionActivationRule,Type是”String”,值是”TRUEPREDICATE”,把它修改Type为Dictionary,在里面“+”一个item,名字为”NSExtensionActivationSupportsWebPageWithMaxCount”,Type为String,值设为1。把这个值加到新设的Dictionary里面,是因为我们只想要收到网页数据(web pages),而对images或其他数据类型不感兴趣。接下来选择NSExtensionAttributes,在里面添加名为”NSExtensionJavaScriptPreprocessingFile”,Type为”String”,值为”Action”。这样设置,就是当插件被called的时候,我们需要运行JavaScript的预处理文件,文件名为Action.js。这样需要注意,这里你设置的值是”Action”而不是”Action.js”,因为iOS会帮我们把.js加上去的。 既然在info.plist中已经设置了要执行的”Action.js”文件,那么我们就要创建它:Right-click on your extension’s Info.plist file and choose New File. When you’re asked what template you want, choose iOS &gt; Other &gt; Empty, then name it Action.js, and put this text into it: 123456789101112131415161718var Action = function() &#123;&#125;;Action.prototype = &#123;// run及其代码的意思是:// 告知iOS这个JavaScript已经预处理完毕,把这个dictionary(里面的key分别是&quot;URL&quot;和&quot;title&quot;以及对应的值)给extension吧run: function(parameters) &#123; parameters.completionFunction(&#123; &quot;URL&quot;: document.URL, &quot;title&quot;: document.title &#125;);&#125;,finalize: function(parameters) &#123; var customJavaScript = parameters[&quot;customJavaScript&quot;]; eval(customJavaScript);&#125;&#125;;var ExtensionPreprocessingJS = new Action There are two functions: run() and finalize(). The first is called before your extension is run, and the other is called after.Apple expects the code to be exactly like this, so you shouldn’t change it other than to fill in the run() and finalize() functions. 设置到这里,我们在Project Navigator中可以看到的extenison是这样的:此外,在Build Phases的Compile Sources和Copy Bundle Resources中,应该是如上图这样,Action.js是在Copy Bundle Resources中,而不是在Compile Sources中。 最终的Action.js是这样的: 12345678910111213141516171819var Action = function() &#123;&#125;Action.prototype = &#123; run: function(parameters) &#123; // tell iOS the JavaScript has finished preprocessing, and give this data dictionary to the extension. // The data that is being sent has the keys &quot;URL&quot; and &quot;title&quot;, with the values being the page URL and page title. parameters.completionFunction(&#123; &quot;URL&quot;: document.URL, &quot;title&quot;: document.title &#125;);&#125;, finalize: function(parameters) &#123; var customJavaScript = parameters[&quot;customJavaScript&quot;]; eval(customJavaScript);&#125; &#125;;var ExtensionPreprocessingJS = new Action 在MainInterface.storyboard上建立一个UITextNode,让其auto layout,随后ctrl+drag让其在ActionViewController上对应属性: 1@IBOutlet var script: UITextView! 在extension界面的右上角加一个执行的按钮:(注意extension界面只有在被调用到插件功能的时候才会启用) 1navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .done, target: self, action: #selector(done)) 此时写下要执行的objc的方法: 123456789101112@objc func done() &#123; let item = NSExtensionItem() // 注意看在Action.js的finalize方法中定义到了 // var customJavaScript = parameters[&quot;customJavaScript&quot;]; let argument: NSDictionary = [&quot;customJavaScript&quot;: script.text] let webDictionary: NSDictionary = [NSExtensionJavaScriptFinalizeArgumentKey: argument] let customJavaScript = NSItemProvider(item: webDictionary, typeIdentifier: kUTTypePropertyList as String) item.attachments = [customJavaScript] // completeRequest(returningItems:)的调用会造成插件被关闭,并返回母程序,而且可以传回母程序任何我们定义的items。 extensionContext?.completeRequest(returningItems: [item])&#125; 可以观察一下:1、之前我们从safari接收到的是一个含有NSExtensionItem元素的列表,而这里extensionContext?.completeRequest(returningItems: [item]),最终传回safari的也是一个含有NSExtensionItem元素的列表。2、我们朝NSDictionary传递的key是NSExtensionJavaScriptFinalizeArgumentKey,对应的是Action.js的finalize方法,而之前我们一开始从safari取得的key是NSExtensionJavaScriptPreprocessingResultsKey,对应的是Action.js的run方法。这样就能说得通了。I realize that seems like far more effort than it ought to be, but it’s really just the reverse of what we are doing inside viewDidLoad(). NotificationCenter在我们的scenes背后,当有”键盘事件”、”应用进入后台”以及一些其他的事件,iOS会持续地向我们发出notification。我们可以对一些特定的notification加入observer进行回应,也可以进行数据的传递。 Fixing the keyboard https://www.hackingwithswift.com/read/19/7/fixing-the-keyboard-notificationcenter iOS上会有一个keyboard的问题:比如我们现在有一个可以输入多行的UITextView:我们可以看出这个UITextView占据屏幕的大小。如果我们执行,并调出键盘来一行行的打字,当打的字即将超过键盘所在的位置的时候,会发生什么事情呢？为什么会发生这样的事情?因为当你调出keyboard的时候,这个textView的可使用面积没有自动去调整,仍旧那么大,就会出现打的字出现下键盘下方并被遮盖的情况。 keyboardWillHideNotification &#x2F; keyboardWillChangeFrameNotification当键盘隐藏不用的时候,系统会发出keyboardWillHideNotification。当键盘隐藏不用、键盘状态发生改变(比如出现,或者屏幕从portrait专程landscape等等),系统都会发出keyboardWillChangeFrameNotification。看上去keyboardWillChangeFrameNotification已经涵盖了keyboardWillHideNotification,但有时候一些奇怪的场景还是需要用到keyboardWillHideNotification的(现在还没有碰到过)。 添加对这两个键盘事件的观察: 123let notificationCenter = NotificationCenter.defaultnotificationCenter.addObserver(self, selector: #selector(adjustForKeyboard), name: UIResponder.keyboardWillHideNotification, object: nil)notificationCenter.addObserver(self, selector: #selector(adjustForKeyboard), name: UIResponder.keyboardWillChangeFrameNotification, object: nil) 对应的adjustForKeyboard方法: 1234567891011121314151617181920// @IBOutlet var textView: UITextView!@objc func adjustForKeyboard(notificaiton: Notification) &#123; guard let keyboardValue = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue else &#123; return &#125; let keyboardScreenEndFrame = keyboardValue.cgRectValue let keyboardViewEndFrame = view.convert(keyboardScreenEndFrame, from: view.window) // 假如keyboard隐藏了,则textView的contentInset正常,即四周不做任何调整 if notification.name == UIResponder.keyboardWillHideNotification &#123; // textView.contentInset可以理解为是textView的padding,感觉不是margin textView.contentInset = .zero &#125; else &#123; // 此时一定是keyboard在使用的情况 textView.contentInset = UIEdgeInsets(top: 0, left: 0, bottom: keyboardViewEndFrame.height - view.safeAreaInsets.bottom, right: 0) // 这里bottom为何是keyboardViewEndFrame.height - view.safeAreaInsets？ // 因为经答应两个数值可以知道,keyboardViewEndFrame.height是从屏幕最下方开始的,包括了view.safeAreaInsets.bottom, // 而我们的textView开始设置的时候是不包含safeArea的,所以要减掉safeArea的范围。 &#125;&#125; 再对scroll indicator进行设置: 123456789101112@objc func adjustForKeyboard() &#123; // 省略上面的代码 /* 下面这三行代码是教程中加上去的,但操作下来感觉没什么用啊 */ // Scroll indicator insets control how big the scroll bars are relative to their view. textView.scrollIndicatorInsets = textView.contentInset // textView.selectedRange应该理解为是可选择或可使用的范围 let selectedRange = textView.selectedRange // 设置textView可滚动的范围 textView.scrollRangeToVisible(selectedRange) NotificationCenter的post的传输自制的提醒12let notificationCenter = NotificationCenter.defaultnotificationCenter.post(name: Notification.Name(&quot;UserLoggedIn&quot;), object: nil) If no other part of your app has subscribed to receive that notification, nothing will happen. But you can make any other objects subscribe to that notification – it could be one thing, or ten things, it doesn’t matter. This is the essence of loose coupling: you’re transmitting the event to everyone, with no direct knowledge of who your receivers are. UserNotifications – UN看下来,UserNotifications就是在程序中设置好,取得用户授权后,在固定时间点或此后的一段时间后,给用户的手机系统发送提醒信息的一个模块。 If you want to use the UserNotifications framework, you should import it: 1import UserNotifications UNUserNotificationCenter.requestAuthorization – 获取用户授权给用户发送提醒信息的权限,需要用户授权: 1234567891011let center = UNUserNotificationCenter.current()// options表示同意授权的权限包含: 提醒/app上标/声音 这三项// granted是一个Booleancenter.requestAuthorization(options: [.alert, .badge, .sound]) &#123; (granted, error) in if granted &#123; &#125; else &#123; &#125;&#125; 跳出来的是: UNNotificationRequest(identifier:, content:, trigger:)下面的代码设置的是TimeInterval的通知方式(UNTimeIntervalNotificationTrigger),5秒钟后,给系统发送通知信息,告知content中的内容: 12345678910111213141516171819let center = UNUserNotificationCenter.current()// UNNotificationRequest的content部分let content = UNMutableNotificationContent()content.title = &quot;Late wake up call&quot;content.body = &quot;The early bird catches the worm, but the second mouse gets the cheese.&quot;// -- to attach custom actionscontent.categoryIdentifier = &quot;alarm&quot;// -- to attach custom data to the notificationcontent.userInfo = [&quot;customData&quot;: &quot;fizzbuzz&quot;]// -- to specify a soundcontent.sound = UNNotificationSound.default// UNNotificationRequest的trigger部分let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)center.add(request) 也可以设置成Calendar的通知方式,每天10:30发送: (UNCalendarNotificationTrigger) 1234567891011121314151617181920212223242526let center = UNUserNotificationCenter.current()// cancel future scheduled notifications, to start over// 若再次启动的话,需要删除之前悬停着的提醒设定center.removeAllPendingNotificationRequests()let content = UNMutableNotificationContent()content.title = &quot;Late wake up call&quot;content.body = &quot;The early bird catches the worm, but the second mouse gets the cheese.&quot;// content.categoryIdentifier指你可以在notification中加入自定义的action,// 下面会用到的UNNotificationCategory(identifier:, actions: [], intentIdentifiers: [])的identifier必须对应指定是&quot;alarm&quot;content.categoryIdentifier = &quot;alarm&quot;// content.userInfo指你可以在notification中加入自定义的数据,content.userInfo = [&quot;customData&quot;: &quot;fizzbuzz&quot;]content.sound = UNNotificationSound.defaultvar dateComponents = DateComponents()dateComponents.hour = 10dateComponents.minute = 30let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)// 这里的identifier的指定(虽然在这个例子中可有可无),但它可以让你在之后 更新(update) 或 移除(remove) 提醒。// 你也可以通过 center.removeAllPendingNotificationRequests() 来移除 等待的(pending) 的提醒。let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)center.add(request) 你也可以设置一个 地理围栏(geofence),它可以基于你的地理位置来发动(trigger)通知提醒。 五秒钟后发送是这样的: Acting on responses – 根据用户点击选项来采取行动 https://www.hackingwithswift.com/read/21/3/acting-on-responses UNNotificationAction UNNotificationCategory使用UNNotificationAction和UNNotificationCategory,你可以针对跳出的提醒及用户的反应做出进一步的回应。UNNotificationCategory对应的是上面我们设置的content.categoryIdentifier &#x3D; “alarm”。UNNotificationAction设置的是用户选择点击后作出的回应。 123456789101112131415161718192021222324252627282930313233let center = UNUserNotificationCenter.current()// center.delegate = self 就必须让这个self符合UNUserNotificationCenterDelegate协议center.delegate = self// An identifier, which is a unique text string that gets sent to you when the button is tapped.// A title, which is what user’s see in the interface.// Options, which describe any special options that relate to the action. You can choose from .authenticationRequired, .destructive, and .foreground.// .foreground -- The action causes the app to launch in the foreground.// .destructive -- The action causes a destructive task.let show = UNNotificationAction(identifier: &quot;show&quot;, title: &quot;Tell me more...&quot;, options: .foreground)let show2 = UNNotificationAction(identifier: &quot;show2&quot;, title: &quot;Tell me another...&quot;, options: .authenticationRequired)// 此处就必须要对应上面讲到的 content.categoryIdentifier = &quot;alarm&quot;// 此处的intentIdentifiers--this is used to connect your notifications to intents, if you have created any.let category = UNNotificationCategory(identifier: &quot;alarm&quot;, actions: [show, show2], intentIdentifiers: [])center.setNotificationCategories([category])// 下面的代码是上面例子的重复,但要生成notification是必须的,所以就重复写了一遍let content = UNMutableNotificationContent()content.title = &quot;Late wake up call&quot;content.body = &quot;The early bird catches the worm, but the second mouse gets the cheese.&quot;content.categoryIdentifier = &quot;alarm&quot;content.userInfo = [&quot;customData&quot;: &quot;fizzbuzz&quot;]content.sound = UNNotificationSound.defaultvar dateComponents = DateComponents()dateComponents.hour = 10dateComponents.minute = 30let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)center.add(request) 效果是这样的: UNUserNotificationCenter的getNotificationSettings – 查看是否已获得用户的允许发送提醒感觉下面这样写比较好,查看是否获得用户授权发提醒,若未获授权,则请求授权;若已授权,则进一步设置提醒的内容和方式: 1234567891011121314151617181920212223242526272829303132333435363738func manageNotifications() &#123; let notificationCenter = UNUserNotificationCenter.current() notificationCenter.getNotificationSettings &#123; [weak self] (settings) in // user has not made a choice yet regarding accepting notifications if settings.authorizationStatus == .notDetermined &#123; // use this opportunity to explain why it could be useful let ac = UIAlertController(title: &quot;Daily reminder&quot;, message: &quot;Allow notifications to be reminded daily of playing Guess the Flag&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;Next&quot;, style: .default) &#123; _ in self?.requestNotificationsAuthorization() &#125;) self?.present(ac, animated: true) return &#125; // user already has accepted notifications if settings.authorizationStatus == .authorized &#123; self?.scheduleNotifications() &#125; &#125;&#125;func requestNotificationsAuthorization() &#123; let notificationCenter = UNUserNotificationCenter.current() notificationCenter.requestAuthorization(options: [.alert, .badge, .sound]) &#123; [weak self] granted, error in if granted &#123; self?.scheduleNotifications() &#125; else &#123; // explain how notifications can be activated let ac = UIAlertController(title: &quot;Notifications&quot;, message: &quot;Your choice has been saved.\\nShould you change your mind, head to \\&quot;Settings -&gt; Project21-Challenge3 -&gt; Notifications\\&quot; to update your preferences.&quot;, preferredStyle: .alert) ac.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default)) self?.present(ac, animated: true) &#125; &#125;&#125; didReceive – 处理上面设置的content.userInfo &#x3D; [“customData”: “fizzbuzz”]等传输数据UNUserNotificationCenterDelegate协议定义了userNotificationCenter方法,可以接收一个@escaping,来等待并处理传输的数据:(这不是必须要定义的方法,只是在需要处理传输的数据的时候才有必要) 1userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler 我们可以这样定义该方法: 123456789101112131415161718192021func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) &#123; let userInfo = response.notification.request.content.userInfo if let customData = userInfo[&quot;customData&quot;] as? String &#123; print(&quot;Custom data received: \\(customData)&quot;) switch response.actionIdentifier &#123; case UNNotificationDefaultActionIdentifier: // the user swiped to unlock print(&quot;Default identifier&quot;) case &quot;show&quot;: // 针对我们之前的三行代码: // let show = UNNotificationAction(identifier: &quot;show&quot;, title: &quot;Tell me more...&quot;, options: .foreground) // let category = UNNotificationCategory(identifier: &quot;alarm&quot;, actions: [show], intentIdentifiers: []) // center.setNotificationCategories([category]) print(&quot;Show more information...&quot;) // 你也可以再执行一遍scheduleNotifications()来设置新的提醒 default: break &#125; &#125; 很有趣的是,它只响应center.setNotificationCategories,就是你只有点了”Tell me more…”或者”Tell me another…”按钮才会执行该方法,很奇怪,难道它只针对UNNotificationCategory,为啥？center.setNotificationCategories的参数是[category],而category指向的actions是[show, show2, …],所以它只针对action来回应。 使用AVFoudation模块的AVPlayer播放声音文件在使用SpriteKit模块使用中,为何不使用其本身就有的SKAction.playSoundFileNamed()？而是要去使用AVAudioPlayer(contentsOf: URL)?教材中称是,AVAudioPlayer可以在你需要的时候,随时停止声音的播放。 基本使用方法: 123456if let path = Bundle.main.url(forResource: &quot;sliceBombFuse&quot;, withExtension: &quot;caf&quot;) &#123; if let sound = try? AVAudioPlayer(contentsOf: path) &#123; bombSoundEffect = sound sound.play() &#125;&#125; 你可以使用sound.stop()来停止播放。 NSAttributedStringAttributed strings are made up of two parts: a plain Swift string, plus a dictionary containing a series of attributes that describe how various segments of the string are formatted. NSAttributedString可以针对一串字符串,片段化地设置其的属性,而Label却只能整个设置。我们在使用UILabel, UITextField, UITextView, UIButton, UINavigationBar等等支持text属性的情况下,更建议使用attributedText。 12NSAttributedString(string: String, attributes: [NSAttributedString.Key: Any]?) The examples are in codes below. NSAttributedString.Key – 一般用法NSAttributedString.Key is the attributes that you can apply to text in an attributed string. 1234567891011import UIKitvar string = &quot;This is a test string.&quot;let attributes: [NSAttributedString.Key: Any] = [ .foregroundColor: UIColor.white, .backgroundColor: UIColor.red, .font: UIFont.boldSystemFont(ofSize: 36)]let attributedString = NSAttributedString(string: string, attributes: attributes) 效果是这样的:虽然我们可以在Label中设置字符串的属性,但你不能对该字符串的不同部分设置不同的属性,而NSAttributedString可以做到。 NSMutableAttributedString(string: String)可更改属性的NSString,即使你使用let来定义,如下: 12345678let string = &quot;This is a test string&quot;let attributedString = NSMutableAttributedString(string: string)attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 8), range: NSRange(location: 0, length: 4))attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 16), range: NSRange(location: 5, length: 2))attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 24), range: NSRange(location: 8, length: 1))attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 32), range: NSRange(location: 10, length: 4))attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 40), range: NSRange(location: 15, length: 6)) NSAttributedString.Key – 的其他属性There are lots of formatting options for attributed strings, including: Set .underlineStyle to a value from NSUnderlineStyle to strike out characters. Set .strikethroughStyle to a value from NSUnderlineStyle (no, that’s not a typo) to strike out characters. Set .paragraphStyle to an instance of NSMutableParagraphStyle to control text alignment and spacing. Set .link to be a URL to make clickable links in your strings. 1attributedString.addAttribute(.link, value: &quot;https://www.google.com&quot;, range: NSRange(location: 0, length: attributedString.length))","categories":[{"name":"Swift","slug":"Swift","permalink":"http://giantslayer1980.github.io/categories/Swift/"}],"tags":[]}],"categories":[{"name":"Swift","slug":"Swift","permalink":"http://giantslayer1980.github.io/categories/Swift/"}],"tags":[]}